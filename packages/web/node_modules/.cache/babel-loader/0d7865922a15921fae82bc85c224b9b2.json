{"ast":null,"code":"\"no use strict\";\n\n!function (window) {\n  if (typeof window.window != \"undefined\" && window.document) return;\n  if (window.require && window.define) return;\n  if (!window.console) {\n    window.console = function () {\n      var msgs = Array.prototype.slice.call(arguments, 0);\n      postMessage({\n        type: \"log\",\n        data: msgs\n      });\n    };\n    window.console.error = window.console.warn = window.console.log = window.console.trace = window.console;\n  }\n  window.window = window;\n  window.ace = window;\n  window.onerror = function (message, file, line, col, err) {\n    postMessage({\n      type: \"error\",\n      data: {\n        message: message,\n        data: err && err.data,\n        file: file,\n        line: line,\n        col: col,\n        stack: err && err.stack\n      }\n    });\n  };\n  window.normalizeModule = function (parentId, moduleName) {\n    // normalize plugin requires\n    if (moduleName.indexOf(\"!\") !== -1) {\n      var chunks = moduleName.split(\"!\");\n      return window.normalizeModule(parentId, chunks[0]) + \"!\" + window.normalizeModule(parentId, chunks[1]);\n    }\n    // normalize relative requires\n    if (moduleName.charAt(0) == \".\") {\n      var base = parentId.split(\"/\").slice(0, -1).join(\"/\");\n      moduleName = (base ? base + \"/\" : \"\") + moduleName;\n      while (moduleName.indexOf(\".\") !== -1 && previous != moduleName) {\n        var previous = moduleName;\n        moduleName = moduleName.replace(/^\\.\\//, \"\").replace(/\\/\\.\\//, \"/\").replace(/[^\\/]+\\/\\.\\.\\//, \"\");\n      }\n    }\n    return moduleName;\n  };\n  window.require = function require(parentId, id) {\n    if (!id) {\n      id = parentId;\n      parentId = null;\n    }\n    if (!id.charAt) throw new Error(\"worker.js require() accepts only (parentId, id) as arguments\");\n    id = window.normalizeModule(parentId, id);\n    var module = window.require.modules[id];\n    if (module) {\n      if (!module.initialized) {\n        module.initialized = true;\n        module.exports = module.factory().exports;\n      }\n      return module.exports;\n    }\n    if (!window.require.tlns) return console.log(\"unable to load \" + id);\n    var path = resolveModuleId(id, window.require.tlns);\n    if (path.slice(-3) != \".js\") path += \".js\";\n    window.require.id = id;\n    window.require.modules[id] = {}; // prevent infinite loop on broken modules\n    importScripts(path);\n    return window.require(parentId, id);\n  };\n  function resolveModuleId(id, paths) {\n    var testPath = id,\n      tail = \"\";\n    while (testPath) {\n      var alias = paths[testPath];\n      if (typeof alias == \"string\") {\n        return alias + tail;\n      } else if (alias) {\n        return alias.location.replace(/\\/*$/, \"/\") + (tail || alias.main || alias.name);\n      } else if (alias === false) {\n        return \"\";\n      }\n      var i = testPath.lastIndexOf(\"/\");\n      if (i === -1) break;\n      tail = testPath.substr(i) + tail;\n      testPath = testPath.slice(0, i);\n    }\n    return id;\n  }\n  window.require.modules = {};\n  window.require.tlns = {};\n  window.define = function (id, deps, _factory) {\n    if (arguments.length == 2) {\n      _factory = deps;\n      if (typeof id != \"string\") {\n        deps = id;\n        id = window.require.id;\n      }\n    } else if (arguments.length == 1) {\n      _factory = id;\n      deps = [];\n      id = window.require.id;\n    }\n    if (typeof _factory != \"function\") {\n      window.require.modules[id] = {\n        exports: _factory,\n        initialized: true\n      };\n      return;\n    }\n    if (!deps.length)\n      // If there is no dependencies, we inject \"require\", \"exports\" and\n      // \"module\" as dependencies, to provide CommonJS compatibility.\n      deps = [\"require\", \"exports\", \"module\"];\n    var req = function req(childId) {\n      return window.require(id, childId);\n    };\n    window.require.modules[id] = {\n      exports: {},\n      factory: function factory() {\n        var module = this;\n        var returnExports = _factory.apply(this, deps.slice(0, _factory.length).map(function (dep) {\n          switch (dep) {\n            // Because \"require\", \"exports\" and \"module\" aren't actual\n            // dependencies, we must handle them seperately.\n            case \"require\":\n              return req;\n            case \"exports\":\n              return module.exports;\n            case \"module\":\n              return module;\n            // But for all other dependencies, we can just go ahead and\n            // require them.\n            default:\n              return req(dep);\n          }\n        }));\n        if (returnExports) module.exports = returnExports;\n        return module;\n      }\n    };\n  };\n  window.define.amd = {};\n  window.require.tlns = {};\n  window.initBaseUrls = function initBaseUrls(topLevelNamespaces) {\n    for (var i in topLevelNamespaces) this.require.tlns[i] = topLevelNamespaces[i];\n  };\n  window.initSender = function initSender() {\n    var EventEmitter = window.require(\"ace/lib/event_emitter\").EventEmitter;\n    var oop = window.require(\"ace/lib/oop\");\n    var Sender = function Sender() {};\n    (function () {\n      oop.implement(this, EventEmitter);\n      this.callback = function (data, callbackId) {\n        postMessage({\n          type: \"call\",\n          id: callbackId,\n          data: data\n        });\n      };\n      this.emit = function (name, data) {\n        postMessage({\n          type: \"event\",\n          name: name,\n          data: data\n        });\n      };\n    }).call(Sender.prototype);\n    return new Sender();\n  };\n  var main = window.main = null;\n  var sender = window.sender = null;\n  window.onmessage = function (e) {\n    var msg = e.data;\n    if (msg.event && sender) {\n      sender._signal(msg.event, msg.data);\n    } else if (msg.command) {\n      if (main[msg.command]) main[msg.command].apply(main, msg.args);else if (window[msg.command]) window[msg.command].apply(window, msg.args);else throw new Error(\"Unknown command:\" + msg.command);\n    } else if (msg.init) {\n      window.initBaseUrls(msg.tlns);\n      sender = window.sender = window.initSender();\n      var clazz = this.require(msg.module)[msg.classname];\n      main = window.main = new clazz(sender);\n    }\n  };\n}(this);\nace.define(\"ace/lib/oop\", [], function (require, exports, module) {\n  \"use strict\";\n\n  exports.inherits = function (ctor, superCtor) {\n    ctor.super_ = superCtor;\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n  exports.mixin = function (obj, mixin) {\n    for (var key in mixin) {\n      obj[key] = mixin[key];\n    }\n    return obj;\n  };\n  exports.implement = function (proto, mixin) {\n    exports.mixin(proto, mixin);\n  };\n});\nace.define(\"ace/apply_delta\", [], function (require, exports, module) {\n  \"use strict\";\n\n  function throwDeltaError(delta, errorText) {\n    console.log(\"Invalid Delta:\", delta);\n    throw \"Invalid Delta: \" + errorText;\n  }\n  function positionInDocument(docLines, position) {\n    return position.row >= 0 && position.row < docLines.length && position.column >= 0 && position.column <= docLines[position.row].length;\n  }\n  function validateDelta(docLines, delta) {\n    if (delta.action != \"insert\" && delta.action != \"remove\") throwDeltaError(delta, \"delta.action must be 'insert' or 'remove'\");\n    if (!(delta.lines instanceof Array)) throwDeltaError(delta, \"delta.lines must be an Array\");\n    if (!delta.start || !delta.end) throwDeltaError(delta, \"delta.start/end must be an present\");\n    var start = delta.start;\n    if (!positionInDocument(docLines, delta.start)) throwDeltaError(delta, \"delta.start must be contained in document\");\n    var end = delta.end;\n    if (delta.action == \"remove\" && !positionInDocument(docLines, end)) throwDeltaError(delta, \"delta.end must contained in document for 'remove' actions\");\n    var numRangeRows = end.row - start.row;\n    var numRangeLastLineChars = end.column - (numRangeRows == 0 ? start.column : 0);\n    if (numRangeRows != delta.lines.length - 1 || delta.lines[numRangeRows].length != numRangeLastLineChars) throwDeltaError(delta, \"delta.range must match delta lines\");\n  }\n  exports.applyDelta = function (docLines, delta, doNotValidate) {\n    var row = delta.start.row;\n    var startColumn = delta.start.column;\n    var line = docLines[row] || \"\";\n    switch (delta.action) {\n      case \"insert\":\n        var lines = delta.lines;\n        if (lines.length === 1) {\n          docLines[row] = line.substring(0, startColumn) + delta.lines[0] + line.substring(startColumn);\n        } else {\n          var args = [row, 1].concat(delta.lines);\n          docLines.splice.apply(docLines, args);\n          docLines[row] = line.substring(0, startColumn) + docLines[row];\n          docLines[row + delta.lines.length - 1] += line.substring(startColumn);\n        }\n        break;\n      case \"remove\":\n        var endColumn = delta.end.column;\n        var endRow = delta.end.row;\n        if (row === endRow) {\n          docLines[row] = line.substring(0, startColumn) + line.substring(endColumn);\n        } else {\n          docLines.splice(row, endRow - row + 1, line.substring(0, startColumn) + docLines[endRow].substring(endColumn));\n        }\n        break;\n    }\n  };\n});\nace.define(\"ace/lib/event_emitter\", [], function (require, exports, module) {\n  \"use strict\";\n\n  var EventEmitter = {};\n  var stopPropagation = function stopPropagation() {\n    this.propagationStopped = true;\n  };\n  var preventDefault = function preventDefault() {\n    this.defaultPrevented = true;\n  };\n  EventEmitter._emit = EventEmitter._dispatchEvent = function (eventName, e) {\n    this._eventRegistry || (this._eventRegistry = {});\n    this._defaultHandlers || (this._defaultHandlers = {});\n    var listeners = this._eventRegistry[eventName] || [];\n    var defaultHandler = this._defaultHandlers[eventName];\n    if (!listeners.length && !defaultHandler) return;\n    if (typeof e != \"object\" || !e) e = {};\n    if (!e.type) e.type = eventName;\n    if (!e.stopPropagation) e.stopPropagation = stopPropagation;\n    if (!e.preventDefault) e.preventDefault = preventDefault;\n    listeners = listeners.slice();\n    for (var i = 0; i < listeners.length; i++) {\n      listeners[i](e, this);\n      if (e.propagationStopped) break;\n    }\n    if (defaultHandler && !e.defaultPrevented) return defaultHandler(e, this);\n  };\n  EventEmitter._signal = function (eventName, e) {\n    var listeners = (this._eventRegistry || {})[eventName];\n    if (!listeners) return;\n    listeners = listeners.slice();\n    for (var i = 0; i < listeners.length; i++) listeners[i](e, this);\n  };\n  EventEmitter.once = function (eventName, callback) {\n    var _self = this;\n    this.on(eventName, function newCallback() {\n      _self.off(eventName, newCallback);\n      callback.apply(null, arguments);\n    });\n    if (!callback) {\n      return new Promise(function (resolve) {\n        callback = resolve;\n      });\n    }\n  };\n  EventEmitter.setDefaultHandler = function (eventName, callback) {\n    var handlers = this._defaultHandlers;\n    if (!handlers) handlers = this._defaultHandlers = {\n      _disabled_: {}\n    };\n    if (handlers[eventName]) {\n      var old = handlers[eventName];\n      var disabled = handlers._disabled_[eventName];\n      if (!disabled) handlers._disabled_[eventName] = disabled = [];\n      disabled.push(old);\n      var i = disabled.indexOf(callback);\n      if (i != -1) disabled.splice(i, 1);\n    }\n    handlers[eventName] = callback;\n  };\n  EventEmitter.removeDefaultHandler = function (eventName, callback) {\n    var handlers = this._defaultHandlers;\n    if (!handlers) return;\n    var disabled = handlers._disabled_[eventName];\n    if (handlers[eventName] == callback) {\n      if (disabled) this.setDefaultHandler(eventName, disabled.pop());\n    } else if (disabled) {\n      var i = disabled.indexOf(callback);\n      if (i != -1) disabled.splice(i, 1);\n    }\n  };\n  EventEmitter.on = EventEmitter.addEventListener = function (eventName, callback, capturing) {\n    this._eventRegistry = this._eventRegistry || {};\n    var listeners = this._eventRegistry[eventName];\n    if (!listeners) listeners = this._eventRegistry[eventName] = [];\n    if (listeners.indexOf(callback) == -1) listeners[capturing ? \"unshift\" : \"push\"](callback);\n    return callback;\n  };\n  EventEmitter.off = EventEmitter.removeListener = EventEmitter.removeEventListener = function (eventName, callback) {\n    this._eventRegistry = this._eventRegistry || {};\n    var listeners = this._eventRegistry[eventName];\n    if (!listeners) return;\n    var index = listeners.indexOf(callback);\n    if (index !== -1) listeners.splice(index, 1);\n  };\n  EventEmitter.removeAllListeners = function (eventName) {\n    if (!eventName) this._eventRegistry = this._defaultHandlers = undefined;\n    if (this._eventRegistry) this._eventRegistry[eventName] = undefined;\n    if (this._defaultHandlers) this._defaultHandlers[eventName] = undefined;\n  };\n  exports.EventEmitter = EventEmitter;\n});\nace.define(\"ace/range\", [], function (require, exports, module) {\n  \"use strict\";\n\n  var comparePoints = function comparePoints(p1, p2) {\n    return p1.row - p2.row || p1.column - p2.column;\n  };\n  var Range = function Range(startRow, startColumn, endRow, endColumn) {\n    this.start = {\n      row: startRow,\n      column: startColumn\n    };\n    this.end = {\n      row: endRow,\n      column: endColumn\n    };\n  };\n  (function () {\n    this.isEqual = function (range) {\n      return this.start.row === range.start.row && this.end.row === range.end.row && this.start.column === range.start.column && this.end.column === range.end.column;\n    };\n    this.toString = function () {\n      return \"Range: [\" + this.start.row + \"/\" + this.start.column + \"] -> [\" + this.end.row + \"/\" + this.end.column + \"]\";\n    };\n    this.contains = function (row, column) {\n      return this.compare(row, column) == 0;\n    };\n    this.compareRange = function (range) {\n      var cmp,\n        end = range.end,\n        start = range.start;\n      cmp = this.compare(end.row, end.column);\n      if (cmp == 1) {\n        cmp = this.compare(start.row, start.column);\n        if (cmp == 1) {\n          return 2;\n        } else if (cmp == 0) {\n          return 1;\n        } else {\n          return 0;\n        }\n      } else if (cmp == -1) {\n        return -2;\n      } else {\n        cmp = this.compare(start.row, start.column);\n        if (cmp == -1) {\n          return -1;\n        } else if (cmp == 1) {\n          return 42;\n        } else {\n          return 0;\n        }\n      }\n    };\n    this.comparePoint = function (p) {\n      return this.compare(p.row, p.column);\n    };\n    this.containsRange = function (range) {\n      return this.comparePoint(range.start) == 0 && this.comparePoint(range.end) == 0;\n    };\n    this.intersects = function (range) {\n      var cmp = this.compareRange(range);\n      return cmp == -1 || cmp == 0 || cmp == 1;\n    };\n    this.isEnd = function (row, column) {\n      return this.end.row == row && this.end.column == column;\n    };\n    this.isStart = function (row, column) {\n      return this.start.row == row && this.start.column == column;\n    };\n    this.setStart = function (row, column) {\n      if (typeof row == \"object\") {\n        this.start.column = row.column;\n        this.start.row = row.row;\n      } else {\n        this.start.row = row;\n        this.start.column = column;\n      }\n    };\n    this.setEnd = function (row, column) {\n      if (typeof row == \"object\") {\n        this.end.column = row.column;\n        this.end.row = row.row;\n      } else {\n        this.end.row = row;\n        this.end.column = column;\n      }\n    };\n    this.inside = function (row, column) {\n      if (this.compare(row, column) == 0) {\n        if (this.isEnd(row, column) || this.isStart(row, column)) {\n          return false;\n        } else {\n          return true;\n        }\n      }\n      return false;\n    };\n    this.insideStart = function (row, column) {\n      if (this.compare(row, column) == 0) {\n        if (this.isEnd(row, column)) {\n          return false;\n        } else {\n          return true;\n        }\n      }\n      return false;\n    };\n    this.insideEnd = function (row, column) {\n      if (this.compare(row, column) == 0) {\n        if (this.isStart(row, column)) {\n          return false;\n        } else {\n          return true;\n        }\n      }\n      return false;\n    };\n    this.compare = function (row, column) {\n      if (!this.isMultiLine()) {\n        if (row === this.start.row) {\n          return column < this.start.column ? -1 : column > this.end.column ? 1 : 0;\n        }\n      }\n      if (row < this.start.row) return -1;\n      if (row > this.end.row) return 1;\n      if (this.start.row === row) return column >= this.start.column ? 0 : -1;\n      if (this.end.row === row) return column <= this.end.column ? 0 : 1;\n      return 0;\n    };\n    this.compareStart = function (row, column) {\n      if (this.start.row == row && this.start.column == column) {\n        return -1;\n      } else {\n        return this.compare(row, column);\n      }\n    };\n    this.compareEnd = function (row, column) {\n      if (this.end.row == row && this.end.column == column) {\n        return 1;\n      } else {\n        return this.compare(row, column);\n      }\n    };\n    this.compareInside = function (row, column) {\n      if (this.end.row == row && this.end.column == column) {\n        return 1;\n      } else if (this.start.row == row && this.start.column == column) {\n        return -1;\n      } else {\n        return this.compare(row, column);\n      }\n    };\n    this.clipRows = function (firstRow, lastRow) {\n      if (this.end.row > lastRow) var end = {\n        row: lastRow + 1,\n        column: 0\n      };else if (this.end.row < firstRow) var end = {\n        row: firstRow,\n        column: 0\n      };\n      if (this.start.row > lastRow) var start = {\n        row: lastRow + 1,\n        column: 0\n      };else if (this.start.row < firstRow) var start = {\n        row: firstRow,\n        column: 0\n      };\n      return Range.fromPoints(start || this.start, end || this.end);\n    };\n    this.extend = function (row, column) {\n      var cmp = this.compare(row, column);\n      if (cmp == 0) return this;else if (cmp == -1) var start = {\n        row: row,\n        column: column\n      };else var end = {\n        row: row,\n        column: column\n      };\n      return Range.fromPoints(start || this.start, end || this.end);\n    };\n    this.isEmpty = function () {\n      return this.start.row === this.end.row && this.start.column === this.end.column;\n    };\n    this.isMultiLine = function () {\n      return this.start.row !== this.end.row;\n    };\n    this.clone = function () {\n      return Range.fromPoints(this.start, this.end);\n    };\n    this.collapseRows = function () {\n      if (this.end.column == 0) return new Range(this.start.row, 0, Math.max(this.start.row, this.end.row - 1), 0);else return new Range(this.start.row, 0, this.end.row, 0);\n    };\n    this.toScreenRange = function (session) {\n      var screenPosStart = session.documentToScreenPosition(this.start);\n      var screenPosEnd = session.documentToScreenPosition(this.end);\n      return new Range(screenPosStart.row, screenPosStart.column, screenPosEnd.row, screenPosEnd.column);\n    };\n    this.moveBy = function (row, column) {\n      this.start.row += row;\n      this.start.column += column;\n      this.end.row += row;\n      this.end.column += column;\n    };\n  }).call(Range.prototype);\n  Range.fromPoints = function (start, end) {\n    return new Range(start.row, start.column, end.row, end.column);\n  };\n  Range.comparePoints = comparePoints;\n  Range.comparePoints = function (p1, p2) {\n    return p1.row - p2.row || p1.column - p2.column;\n  };\n  exports.Range = Range;\n});\nace.define(\"ace/anchor\", [], function (require, exports, module) {\n  \"use strict\";\n\n  var oop = require(\"./lib/oop\");\n  var EventEmitter = require(\"./lib/event_emitter\").EventEmitter;\n  var Anchor = exports.Anchor = function (doc, row, column) {\n    this.$onChange = this.onChange.bind(this);\n    this.attach(doc);\n    if (typeof column == \"undefined\") this.setPosition(row.row, row.column);else this.setPosition(row, column);\n  };\n  (function () {\n    oop.implement(this, EventEmitter);\n    this.getPosition = function () {\n      return this.$clipPositionToDocument(this.row, this.column);\n    };\n    this.getDocument = function () {\n      return this.document;\n    };\n    this.$insertRight = false;\n    this.onChange = function (delta) {\n      if (delta.start.row == delta.end.row && delta.start.row != this.row) return;\n      if (delta.start.row > this.row) return;\n      var point = $getTransformedPoint(delta, {\n        row: this.row,\n        column: this.column\n      }, this.$insertRight);\n      this.setPosition(point.row, point.column, true);\n    };\n    function $pointsInOrder(point1, point2, equalPointsInOrder) {\n      var bColIsAfter = equalPointsInOrder ? point1.column <= point2.column : point1.column < point2.column;\n      return point1.row < point2.row || point1.row == point2.row && bColIsAfter;\n    }\n    function $getTransformedPoint(delta, point, moveIfEqual) {\n      var deltaIsInsert = delta.action == \"insert\";\n      var deltaRowShift = (deltaIsInsert ? 1 : -1) * (delta.end.row - delta.start.row);\n      var deltaColShift = (deltaIsInsert ? 1 : -1) * (delta.end.column - delta.start.column);\n      var deltaStart = delta.start;\n      var deltaEnd = deltaIsInsert ? deltaStart : delta.end; // Collapse insert range.\n      if ($pointsInOrder(point, deltaStart, moveIfEqual)) {\n        return {\n          row: point.row,\n          column: point.column\n        };\n      }\n      if ($pointsInOrder(deltaEnd, point, !moveIfEqual)) {\n        return {\n          row: point.row + deltaRowShift,\n          column: point.column + (point.row == deltaEnd.row ? deltaColShift : 0)\n        };\n      }\n      return {\n        row: deltaStart.row,\n        column: deltaStart.column\n      };\n    }\n    this.setPosition = function (row, column, noClip) {\n      var pos;\n      if (noClip) {\n        pos = {\n          row: row,\n          column: column\n        };\n      } else {\n        pos = this.$clipPositionToDocument(row, column);\n      }\n      if (this.row == pos.row && this.column == pos.column) return;\n      var old = {\n        row: this.row,\n        column: this.column\n      };\n      this.row = pos.row;\n      this.column = pos.column;\n      this._signal(\"change\", {\n        old: old,\n        value: pos\n      });\n    };\n    this.detach = function () {\n      this.document.off(\"change\", this.$onChange);\n    };\n    this.attach = function (doc) {\n      this.document = doc || this.document;\n      this.document.on(\"change\", this.$onChange);\n    };\n    this.$clipPositionToDocument = function (row, column) {\n      var pos = {};\n      if (row >= this.document.getLength()) {\n        pos.row = Math.max(0, this.document.getLength() - 1);\n        pos.column = this.document.getLine(pos.row).length;\n      } else if (row < 0) {\n        pos.row = 0;\n        pos.column = 0;\n      } else {\n        pos.row = row;\n        pos.column = Math.min(this.document.getLine(pos.row).length, Math.max(0, column));\n      }\n      if (column < 0) pos.column = 0;\n      return pos;\n    };\n  }).call(Anchor.prototype);\n});\nace.define(\"ace/document\", [], function (require, exports, module) {\n  \"use strict\";\n\n  var oop = require(\"./lib/oop\");\n  var applyDelta = require(\"./apply_delta\").applyDelta;\n  var EventEmitter = require(\"./lib/event_emitter\").EventEmitter;\n  var Range = require(\"./range\").Range;\n  var Anchor = require(\"./anchor\").Anchor;\n  var Document = function Document(textOrLines) {\n    this.$lines = [\"\"];\n    if (textOrLines.length === 0) {\n      this.$lines = [\"\"];\n    } else if (Array.isArray(textOrLines)) {\n      this.insertMergedLines({\n        row: 0,\n        column: 0\n      }, textOrLines);\n    } else {\n      this.insert({\n        row: 0,\n        column: 0\n      }, textOrLines);\n    }\n  };\n  (function () {\n    oop.implement(this, EventEmitter);\n    this.setValue = function (text) {\n      var len = this.getLength() - 1;\n      this.remove(new Range(0, 0, len, this.getLine(len).length));\n      this.insert({\n        row: 0,\n        column: 0\n      }, text || \"\");\n    };\n    this.getValue = function () {\n      return this.getAllLines().join(this.getNewLineCharacter());\n    };\n    this.createAnchor = function (row, column) {\n      return new Anchor(this, row, column);\n    };\n    if (\"aaa\".split(/a/).length === 0) {\n      this.$split = function (text) {\n        return text.replace(/\\r\\n|\\r/g, \"\\n\").split(\"\\n\");\n      };\n    } else {\n      this.$split = function (text) {\n        return text.split(/\\r\\n|\\r|\\n/);\n      };\n    }\n    this.$detectNewLine = function (text) {\n      var match = text.match(/^.*?(\\r\\n|\\r|\\n)/m);\n      this.$autoNewLine = match ? match[1] : \"\\n\";\n      this._signal(\"changeNewLineMode\");\n    };\n    this.getNewLineCharacter = function () {\n      switch (this.$newLineMode) {\n        case \"windows\":\n          return \"\\r\\n\";\n        case \"unix\":\n          return \"\\n\";\n        default:\n          return this.$autoNewLine || \"\\n\";\n      }\n    };\n    this.$autoNewLine = \"\";\n    this.$newLineMode = \"auto\";\n    this.setNewLineMode = function (newLineMode) {\n      if (this.$newLineMode === newLineMode) return;\n      this.$newLineMode = newLineMode;\n      this._signal(\"changeNewLineMode\");\n    };\n    this.getNewLineMode = function () {\n      return this.$newLineMode;\n    };\n    this.isNewLine = function (text) {\n      return text == \"\\r\\n\" || text == \"\\r\" || text == \"\\n\";\n    };\n    this.getLine = function (row) {\n      return this.$lines[row] || \"\";\n    };\n    this.getLines = function (firstRow, lastRow) {\n      return this.$lines.slice(firstRow, lastRow + 1);\n    };\n    this.getAllLines = function () {\n      return this.getLines(0, this.getLength());\n    };\n    this.getLength = function () {\n      return this.$lines.length;\n    };\n    this.getTextRange = function (range) {\n      return this.getLinesForRange(range).join(this.getNewLineCharacter());\n    };\n    this.getLinesForRange = function (range) {\n      var lines;\n      if (range.start.row === range.end.row) {\n        lines = [this.getLine(range.start.row).substring(range.start.column, range.end.column)];\n      } else {\n        lines = this.getLines(range.start.row, range.end.row);\n        lines[0] = (lines[0] || \"\").substring(range.start.column);\n        var l = lines.length - 1;\n        if (range.end.row - range.start.row == l) lines[l] = lines[l].substring(0, range.end.column);\n      }\n      return lines;\n    };\n    this.insertLines = function (row, lines) {\n      console.warn(\"Use of document.insertLines is deprecated. Use the insertFullLines method instead.\");\n      return this.insertFullLines(row, lines);\n    };\n    this.removeLines = function (firstRow, lastRow) {\n      console.warn(\"Use of document.removeLines is deprecated. Use the removeFullLines method instead.\");\n      return this.removeFullLines(firstRow, lastRow);\n    };\n    this.insertNewLine = function (position) {\n      console.warn(\"Use of document.insertNewLine is deprecated. Use insertMergedLines(position, ['', '']) instead.\");\n      return this.insertMergedLines(position, [\"\", \"\"]);\n    };\n    this.insert = function (position, text) {\n      if (this.getLength() <= 1) this.$detectNewLine(text);\n      return this.insertMergedLines(position, this.$split(text));\n    };\n    this.insertInLine = function (position, text) {\n      var start = this.clippedPos(position.row, position.column);\n      var end = this.pos(position.row, position.column + text.length);\n      this.applyDelta({\n        start: start,\n        end: end,\n        action: \"insert\",\n        lines: [text]\n      }, true);\n      return this.clonePos(end);\n    };\n    this.clippedPos = function (row, column) {\n      var length = this.getLength();\n      if (row === undefined) {\n        row = length;\n      } else if (row < 0) {\n        row = 0;\n      } else if (row >= length) {\n        row = length - 1;\n        column = undefined;\n      }\n      var line = this.getLine(row);\n      if (column == undefined) column = line.length;\n      column = Math.min(Math.max(column, 0), line.length);\n      return {\n        row: row,\n        column: column\n      };\n    };\n    this.clonePos = function (pos) {\n      return {\n        row: pos.row,\n        column: pos.column\n      };\n    };\n    this.pos = function (row, column) {\n      return {\n        row: row,\n        column: column\n      };\n    };\n    this.$clipPosition = function (position) {\n      var length = this.getLength();\n      if (position.row >= length) {\n        position.row = Math.max(0, length - 1);\n        position.column = this.getLine(length - 1).length;\n      } else {\n        position.row = Math.max(0, position.row);\n        position.column = Math.min(Math.max(position.column, 0), this.getLine(position.row).length);\n      }\n      return position;\n    };\n    this.insertFullLines = function (row, lines) {\n      row = Math.min(Math.max(row, 0), this.getLength());\n      var column = 0;\n      if (row < this.getLength()) {\n        lines = lines.concat([\"\"]);\n        column = 0;\n      } else {\n        lines = [\"\"].concat(lines);\n        row--;\n        column = this.$lines[row].length;\n      }\n      this.insertMergedLines({\n        row: row,\n        column: column\n      }, lines);\n    };\n    this.insertMergedLines = function (position, lines) {\n      var start = this.clippedPos(position.row, position.column);\n      var end = {\n        row: start.row + lines.length - 1,\n        column: (lines.length == 1 ? start.column : 0) + lines[lines.length - 1].length\n      };\n      this.applyDelta({\n        start: start,\n        end: end,\n        action: \"insert\",\n        lines: lines\n      });\n      return this.clonePos(end);\n    };\n    this.remove = function (range) {\n      var start = this.clippedPos(range.start.row, range.start.column);\n      var end = this.clippedPos(range.end.row, range.end.column);\n      this.applyDelta({\n        start: start,\n        end: end,\n        action: \"remove\",\n        lines: this.getLinesForRange({\n          start: start,\n          end: end\n        })\n      });\n      return this.clonePos(start);\n    };\n    this.removeInLine = function (row, startColumn, endColumn) {\n      var start = this.clippedPos(row, startColumn);\n      var end = this.clippedPos(row, endColumn);\n      this.applyDelta({\n        start: start,\n        end: end,\n        action: \"remove\",\n        lines: this.getLinesForRange({\n          start: start,\n          end: end\n        })\n      }, true);\n      return this.clonePos(start);\n    };\n    this.removeFullLines = function (firstRow, lastRow) {\n      firstRow = Math.min(Math.max(0, firstRow), this.getLength() - 1);\n      lastRow = Math.min(Math.max(0, lastRow), this.getLength() - 1);\n      var deleteFirstNewLine = lastRow == this.getLength() - 1 && firstRow > 0;\n      var deleteLastNewLine = lastRow < this.getLength() - 1;\n      var startRow = deleteFirstNewLine ? firstRow - 1 : firstRow;\n      var startCol = deleteFirstNewLine ? this.getLine(startRow).length : 0;\n      var endRow = deleteLastNewLine ? lastRow + 1 : lastRow;\n      var endCol = deleteLastNewLine ? 0 : this.getLine(endRow).length;\n      var range = new Range(startRow, startCol, endRow, endCol);\n      var deletedLines = this.$lines.slice(firstRow, lastRow + 1);\n      this.applyDelta({\n        start: range.start,\n        end: range.end,\n        action: \"remove\",\n        lines: this.getLinesForRange(range)\n      });\n      return deletedLines;\n    };\n    this.removeNewLine = function (row) {\n      if (row < this.getLength() - 1 && row >= 0) {\n        this.applyDelta({\n          start: this.pos(row, this.getLine(row).length),\n          end: this.pos(row + 1, 0),\n          action: \"remove\",\n          lines: [\"\", \"\"]\n        });\n      }\n    };\n    this.replace = function (range, text) {\n      if (!(range instanceof Range)) range = Range.fromPoints(range.start, range.end);\n      if (text.length === 0 && range.isEmpty()) return range.start;\n      if (text == this.getTextRange(range)) return range.end;\n      this.remove(range);\n      var end;\n      if (text) {\n        end = this.insert(range.start, text);\n      } else {\n        end = range.start;\n      }\n      return end;\n    };\n    this.applyDeltas = function (deltas) {\n      for (var i = 0; i < deltas.length; i++) {\n        this.applyDelta(deltas[i]);\n      }\n    };\n    this.revertDeltas = function (deltas) {\n      for (var i = deltas.length - 1; i >= 0; i--) {\n        this.revertDelta(deltas[i]);\n      }\n    };\n    this.applyDelta = function (delta, doNotValidate) {\n      var isInsert = delta.action == \"insert\";\n      if (isInsert ? delta.lines.length <= 1 && !delta.lines[0] : !Range.comparePoints(delta.start, delta.end)) {\n        return;\n      }\n      if (isInsert && delta.lines.length > 20000) {\n        this.$splitAndapplyLargeDelta(delta, 20000);\n      } else {\n        applyDelta(this.$lines, delta, doNotValidate);\n        this._signal(\"change\", delta);\n      }\n    };\n    this.$safeApplyDelta = function (delta) {\n      var docLength = this.$lines.length;\n      if (delta.action == \"remove\" && delta.start.row < docLength && delta.end.row < docLength || delta.action == \"insert\" && delta.start.row <= docLength) {\n        this.applyDelta(delta);\n      }\n    };\n    this.$splitAndapplyLargeDelta = function (delta, MAX) {\n      var lines = delta.lines;\n      var l = lines.length - MAX + 1;\n      var row = delta.start.row;\n      var column = delta.start.column;\n      for (var from = 0, to = 0; from < l; from = to) {\n        to += MAX - 1;\n        var chunk = lines.slice(from, to);\n        chunk.push(\"\");\n        this.applyDelta({\n          start: this.pos(row + from, column),\n          end: this.pos(row + to, column = 0),\n          action: delta.action,\n          lines: chunk\n        }, true);\n      }\n      delta.lines = lines.slice(from);\n      delta.start.row = row + from;\n      delta.start.column = column;\n      this.applyDelta(delta, true);\n    };\n    this.revertDelta = function (delta) {\n      this.$safeApplyDelta({\n        start: this.clonePos(delta.start),\n        end: this.clonePos(delta.end),\n        action: delta.action == \"insert\" ? \"remove\" : \"insert\",\n        lines: delta.lines.slice()\n      });\n    };\n    this.indexToPosition = function (index, startRow) {\n      var lines = this.$lines || this.getAllLines();\n      var newlineLength = this.getNewLineCharacter().length;\n      for (var i = startRow || 0, l = lines.length; i < l; i++) {\n        index -= lines[i].length + newlineLength;\n        if (index < 0) return {\n          row: i,\n          column: index + lines[i].length + newlineLength\n        };\n      }\n      return {\n        row: l - 1,\n        column: index + lines[l - 1].length + newlineLength\n      };\n    };\n    this.positionToIndex = function (pos, startRow) {\n      var lines = this.$lines || this.getAllLines();\n      var newlineLength = this.getNewLineCharacter().length;\n      var index = 0;\n      var row = Math.min(pos.row, lines.length);\n      for (var i = startRow || 0; i < row; ++i) index += lines[i].length + newlineLength;\n      return index + pos.column;\n    };\n  }).call(Document.prototype);\n  exports.Document = Document;\n});\nace.define(\"ace/lib/lang\", [], function (require, exports, module) {\n  \"use strict\";\n\n  exports.last = function (a) {\n    return a[a.length - 1];\n  };\n  exports.stringReverse = function (string) {\n    return string.split(\"\").reverse().join(\"\");\n  };\n  exports.stringRepeat = function (string, count) {\n    var result = '';\n    while (count > 0) {\n      if (count & 1) result += string;\n      if (count >>= 1) string += string;\n    }\n    return result;\n  };\n  var trimBeginRegexp = /^\\s\\s*/;\n  var trimEndRegexp = /\\s\\s*$/;\n  exports.stringTrimLeft = function (string) {\n    return string.replace(trimBeginRegexp, '');\n  };\n  exports.stringTrimRight = function (string) {\n    return string.replace(trimEndRegexp, '');\n  };\n  exports.copyObject = function (obj) {\n    var copy = {};\n    for (var key in obj) {\n      copy[key] = obj[key];\n    }\n    return copy;\n  };\n  exports.copyArray = function (array) {\n    var copy = [];\n    for (var i = 0, l = array.length; i < l; i++) {\n      if (array[i] && typeof array[i] == \"object\") copy[i] = this.copyObject(array[i]);else copy[i] = array[i];\n    }\n    return copy;\n  };\n  exports.deepCopy = function deepCopy(obj) {\n    if (typeof obj !== \"object\" || !obj) return obj;\n    var copy;\n    if (Array.isArray(obj)) {\n      copy = [];\n      for (var key = 0; key < obj.length; key++) {\n        copy[key] = deepCopy(obj[key]);\n      }\n      return copy;\n    }\n    if (Object.prototype.toString.call(obj) !== \"[object Object]\") return obj;\n    copy = {};\n    for (var key in obj) copy[key] = deepCopy(obj[key]);\n    return copy;\n  };\n  exports.arrayToMap = function (arr) {\n    var map = {};\n    for (var i = 0; i < arr.length; i++) {\n      map[arr[i]] = 1;\n    }\n    return map;\n  };\n  exports.createMap = function (props) {\n    var map = Object.create(null);\n    for (var i in props) {\n      map[i] = props[i];\n    }\n    return map;\n  };\n  exports.arrayRemove = function (array, value) {\n    for (var i = 0; i <= array.length; i++) {\n      if (value === array[i]) {\n        array.splice(i, 1);\n      }\n    }\n  };\n  exports.escapeRegExp = function (str) {\n    return str.replace(/([.*+?^${}()|[\\]\\/\\\\])/g, '\\\\$1');\n  };\n  exports.escapeHTML = function (str) {\n    return (\"\" + str).replace(/&/g, \"&#38;\").replace(/\"/g, \"&#34;\").replace(/'/g, \"&#39;\").replace(/</g, \"&#60;\");\n  };\n  exports.getMatchOffsets = function (string, regExp) {\n    var matches = [];\n    string.replace(regExp, function (str) {\n      matches.push({\n        offset: arguments[arguments.length - 2],\n        length: str.length\n      });\n    });\n    return matches;\n  };\n  exports.deferredCall = function (fcn) {\n    var timer = null;\n    var callback = function callback() {\n      timer = null;\n      fcn();\n    };\n    var deferred = function deferred(timeout) {\n      deferred.cancel();\n      timer = setTimeout(callback, timeout || 0);\n      return deferred;\n    };\n    deferred.schedule = deferred;\n    deferred.call = function () {\n      this.cancel();\n      fcn();\n      return deferred;\n    };\n    deferred.cancel = function () {\n      clearTimeout(timer);\n      timer = null;\n      return deferred;\n    };\n    deferred.isPending = function () {\n      return timer;\n    };\n    return deferred;\n  };\n  exports.delayedCall = function (fcn, defaultTimeout) {\n    var timer = null;\n    var callback = function callback() {\n      timer = null;\n      fcn();\n    };\n    var _self = function _self(timeout) {\n      if (timer == null) timer = setTimeout(callback, timeout || defaultTimeout);\n    };\n    _self.delay = function (timeout) {\n      timer && clearTimeout(timer);\n      timer = setTimeout(callback, timeout || defaultTimeout);\n    };\n    _self.schedule = _self;\n    _self.call = function () {\n      this.cancel();\n      fcn();\n    };\n    _self.cancel = function () {\n      timer && clearTimeout(timer);\n      timer = null;\n    };\n    _self.isPending = function () {\n      return timer;\n    };\n    return _self;\n  };\n});\nace.define(\"ace/worker/mirror\", [], function (require, exports, module) {\n  \"use strict\";\n\n  var Document = require(\"../document\").Document;\n  var lang = require(\"../lib/lang\");\n  var Mirror = exports.Mirror = function (sender) {\n    this.sender = sender;\n    var doc = this.doc = new Document(\"\");\n    var deferredUpdate = this.deferredUpdate = lang.delayedCall(this.onUpdate.bind(this));\n    var _self = this;\n    sender.on(\"change\", function (e) {\n      var data = e.data;\n      if (data[0].start) {\n        doc.applyDeltas(data);\n      } else {\n        for (var i = 0; i < data.length; i += 2) {\n          var d, err;\n          if (Array.isArray(data[i + 1])) {\n            d = {\n              action: \"insert\",\n              start: data[i],\n              lines: data[i + 1]\n            };\n          } else {\n            d = {\n              action: \"remove\",\n              start: data[i],\n              end: data[i + 1]\n            };\n          }\n          if ((d.action == \"insert\" ? d.start : d.end).row >= doc.$lines.length) {\n            err = new Error(\"Invalid delta\");\n            err.data = {\n              path: _self.$path,\n              linesLength: doc.$lines.length,\n              start: d.start,\n              end: d.end\n            };\n            throw err;\n          }\n          doc.applyDelta(d, true);\n        }\n      }\n      if (_self.$timeout) return deferredUpdate.schedule(_self.$timeout);\n      _self.onUpdate();\n    });\n  };\n  (function () {\n    this.$timeout = 500;\n    this.setTimeout = function (timeout) {\n      this.$timeout = timeout;\n    };\n    this.setValue = function (value) {\n      this.doc.setValue(value);\n      this.deferredUpdate.schedule(this.$timeout);\n    };\n    this.getValue = function (callbackId) {\n      this.sender.callback(this.doc.getValue(), callbackId);\n    };\n    this.onUpdate = function () {};\n    this.isPending = function () {\n      return this.deferredUpdate.isPending();\n    };\n  }).call(Mirror.prototype);\n});\nace.define(\"ace/mode/lua/luaparse\", [], function (require, exports, module) {\n  (function (root, name, factory) {\n    factory(exports);\n  })(this, 'luaparse', function (exports) {\n    'use strict';\n\n    exports.version = \"0.3.1\";\n    var input, options, length, features, encodingMode;\n    var defaultOptions = exports.defaultOptions = {\n      wait: false,\n      comments: true,\n      scope: false,\n      locations: false,\n      ranges: false,\n      onCreateNode: null,\n      onCreateScope: null,\n      onDestroyScope: null,\n      onLocalDeclaration: null,\n      luaVersion: '5.3',\n      encodingMode: 'none'\n    };\n    function _encodeUTF(codepoint, highMask) {\n      highMask = highMask || 0;\n      if (codepoint < 0x80) {\n        return String.fromCharCode(codepoint);\n      } else if (codepoint < 0x800) {\n        return String.fromCharCode(highMask | 0xc0 | codepoint >> 6, highMask | 0x80 | codepoint & 0x3f);\n      } else if (codepoint < 0x10000) {\n        return String.fromCharCode(highMask | 0xe0 | codepoint >> 12, highMask | 0x80 | codepoint >> 6 & 0x3f, highMask | 0x80 | codepoint & 0x3f);\n      } else /* istanbul ignore else */if (codepoint < 0x110000) {\n          return String.fromCharCode(highMask | 0xf0 | codepoint >> 18, highMask | 0x80 | codepoint >> 12 & 0x3f, highMask | 0x80 | codepoint >> 6 & 0x3f, highMask | 0x80 | codepoint & 0x3f);\n        } else {\n          return null;\n        }\n    }\n    function toHex(num, digits) {\n      var result = num.toString(16);\n      while (result.length < digits) result = '0' + result;\n      return result;\n    }\n    function checkChars(rx) {\n      return function (s) {\n        var m = rx.exec(s);\n        if (!m) return s;\n        raise(null, errors.invalidCodeUnit, toHex(m[0].charCodeAt(0), 4).toUpperCase());\n      };\n    }\n    var encodingModes = {\n      'pseudo-latin1': {\n        fixup: checkChars(/[^\\x00-\\xff]/),\n        encodeByte: function encodeByte(value) {\n          if (value === null) return '';\n          return String.fromCharCode(value);\n        },\n        encodeUTF8: function encodeUTF8(codepoint) {\n          return _encodeUTF(codepoint);\n        }\n      },\n      'x-user-defined': {\n        fixup: checkChars(/[^\\x00-\\x7f\\uf780-\\uf7ff]/),\n        encodeByte: function encodeByte(value) {\n          if (value === null) return '';\n          if (value >= 0x80) return String.fromCharCode(value | 0xf700);\n          return String.fromCharCode(value);\n        },\n        encodeUTF8: function encodeUTF8(codepoint) {\n          return _encodeUTF(codepoint, 0xf700);\n        }\n      },\n      'none': {\n        discardStrings: true,\n        fixup: function fixup(s) {\n          return s;\n        },\n        encodeByte: function encodeByte(value) {\n          return '';\n        },\n        encodeUTF8: function encodeUTF8(codepoint) {\n          return '';\n        }\n      }\n    };\n    var EOF = 1,\n      StringLiteral = 2,\n      Keyword = 4,\n      Identifier = 8,\n      NumericLiteral = 16,\n      Punctuator = 32,\n      BooleanLiteral = 64,\n      NilLiteral = 128,\n      VarargLiteral = 256;\n    exports.tokenTypes = {\n      EOF: EOF,\n      StringLiteral: StringLiteral,\n      Keyword: Keyword,\n      Identifier: Identifier,\n      NumericLiteral: NumericLiteral,\n      Punctuator: Punctuator,\n      BooleanLiteral: BooleanLiteral,\n      NilLiteral: NilLiteral,\n      VarargLiteral: VarargLiteral\n    };\n    var errors = exports.errors = {\n      unexpected: 'unexpected %1 \\'%2\\' near \\'%3\\'',\n      unexpectedEOF: 'unexpected symbol near \\'<eof>\\'',\n      expected: '\\'%1\\' expected near \\'%2\\'',\n      expectedToken: '%1 expected near \\'%2\\'',\n      unfinishedString: 'unfinished string near \\'%1\\'',\n      malformedNumber: 'malformed number near \\'%1\\'',\n      decimalEscapeTooLarge: 'decimal escape too large near \\'%1\\'',\n      invalidEscape: 'invalid escape sequence near \\'%1\\'',\n      hexadecimalDigitExpected: 'hexadecimal digit expected near \\'%1\\'',\n      braceExpected: 'missing \\'%1\\' near \\'%2\\'',\n      tooLargeCodepoint: 'UTF-8 value too large near \\'%1\\'',\n      unfinishedLongString: 'unfinished long string (starting at line %1) near \\'%2\\'',\n      unfinishedLongComment: 'unfinished long comment (starting at line %1) near \\'%2\\'',\n      ambiguousSyntax: 'ambiguous syntax (function call x new statement) near \\'%1\\'',\n      noLoopToBreak: 'no loop to break near \\'%1\\'',\n      labelAlreadyDefined: 'label \\'%1\\' already defined on line %2',\n      labelNotVisible: 'no visible label \\'%1\\' for <goto>',\n      gotoJumpInLocalScope: '<goto %1> jumps into the scope of local \\'%2\\'',\n      cannotUseVararg: 'cannot use \\'...\\' outside a vararg function near \\'%1\\'',\n      invalidCodeUnit: 'code unit U+%1 is not allowed in the current encoding mode'\n    };\n    var ast = exports.ast = {\n      labelStatement: function labelStatement(label) {\n        return {\n          type: 'LabelStatement',\n          label: label\n        };\n      },\n      breakStatement: function breakStatement() {\n        return {\n          type: 'BreakStatement'\n        };\n      },\n      gotoStatement: function gotoStatement(label) {\n        return {\n          type: 'GotoStatement',\n          label: label\n        };\n      },\n      returnStatement: function returnStatement(args) {\n        return {\n          type: 'ReturnStatement',\n          'arguments': args\n        };\n      },\n      ifStatement: function ifStatement(clauses) {\n        return {\n          type: 'IfStatement',\n          clauses: clauses\n        };\n      },\n      ifClause: function ifClause(condition, body) {\n        return {\n          type: 'IfClause',\n          condition: condition,\n          body: body\n        };\n      },\n      elseifClause: function elseifClause(condition, body) {\n        return {\n          type: 'ElseifClause',\n          condition: condition,\n          body: body\n        };\n      },\n      elseClause: function elseClause(body) {\n        return {\n          type: 'ElseClause',\n          body: body\n        };\n      },\n      whileStatement: function whileStatement(condition, body) {\n        return {\n          type: 'WhileStatement',\n          condition: condition,\n          body: body\n        };\n      },\n      doStatement: function doStatement(body) {\n        return {\n          type: 'DoStatement',\n          body: body\n        };\n      },\n      repeatStatement: function repeatStatement(condition, body) {\n        return {\n          type: 'RepeatStatement',\n          condition: condition,\n          body: body\n        };\n      },\n      localStatement: function localStatement(variables, init) {\n        return {\n          type: 'LocalStatement',\n          variables: variables,\n          init: init\n        };\n      },\n      assignmentStatement: function assignmentStatement(variables, init) {\n        return {\n          type: 'AssignmentStatement',\n          variables: variables,\n          init: init\n        };\n      },\n      callStatement: function callStatement(expression) {\n        return {\n          type: 'CallStatement',\n          expression: expression\n        };\n      },\n      functionStatement: function functionStatement(identifier, parameters, isLocal, body) {\n        return {\n          type: 'FunctionDeclaration',\n          identifier: identifier,\n          isLocal: isLocal,\n          parameters: parameters,\n          body: body\n        };\n      },\n      forNumericStatement: function forNumericStatement(variable, start, end, step, body) {\n        return {\n          type: 'ForNumericStatement',\n          variable: variable,\n          start: start,\n          end: end,\n          step: step,\n          body: body\n        };\n      },\n      forGenericStatement: function forGenericStatement(variables, iterators, body) {\n        return {\n          type: 'ForGenericStatement',\n          variables: variables,\n          iterators: iterators,\n          body: body\n        };\n      },\n      chunk: function chunk(body) {\n        return {\n          type: 'Chunk',\n          body: body\n        };\n      },\n      identifier: function identifier(name) {\n        return {\n          type: 'Identifier',\n          name: name\n        };\n      },\n      literal: function literal(type, value, raw) {\n        type = type === StringLiteral ? 'StringLiteral' : type === NumericLiteral ? 'NumericLiteral' : type === BooleanLiteral ? 'BooleanLiteral' : type === NilLiteral ? 'NilLiteral' : 'VarargLiteral';\n        return {\n          type: type,\n          value: value,\n          raw: raw\n        };\n      },\n      tableKey: function tableKey(key, value) {\n        return {\n          type: 'TableKey',\n          key: key,\n          value: value\n        };\n      },\n      tableKeyString: function tableKeyString(key, value) {\n        return {\n          type: 'TableKeyString',\n          key: key,\n          value: value\n        };\n      },\n      tableValue: function tableValue(value) {\n        return {\n          type: 'TableValue',\n          value: value\n        };\n      },\n      tableConstructorExpression: function tableConstructorExpression(fields) {\n        return {\n          type: 'TableConstructorExpression',\n          fields: fields\n        };\n      },\n      binaryExpression: function binaryExpression(operator, left, right) {\n        var type = 'and' === operator || 'or' === operator ? 'LogicalExpression' : 'BinaryExpression';\n        return {\n          type: type,\n          operator: operator,\n          left: left,\n          right: right\n        };\n      },\n      unaryExpression: function unaryExpression(operator, argument) {\n        return {\n          type: 'UnaryExpression',\n          operator: operator,\n          argument: argument\n        };\n      },\n      memberExpression: function memberExpression(base, indexer, identifier) {\n        return {\n          type: 'MemberExpression',\n          indexer: indexer,\n          identifier: identifier,\n          base: base\n        };\n      },\n      indexExpression: function indexExpression(base, index) {\n        return {\n          type: 'IndexExpression',\n          base: base,\n          index: index\n        };\n      },\n      callExpression: function callExpression(base, args) {\n        return {\n          type: 'CallExpression',\n          base: base,\n          'arguments': args\n        };\n      },\n      tableCallExpression: function tableCallExpression(base, args) {\n        return {\n          type: 'TableCallExpression',\n          base: base,\n          'arguments': args\n        };\n      },\n      stringCallExpression: function stringCallExpression(base, argument) {\n        return {\n          type: 'StringCallExpression',\n          base: base,\n          argument: argument\n        };\n      },\n      comment: function comment(value, raw) {\n        return {\n          type: 'Comment',\n          value: value,\n          raw: raw\n        };\n      }\n    };\n    function finishNode(node) {\n      if (trackLocations) {\n        var location = locations.pop();\n        location.complete();\n        location.bless(node);\n      }\n      if (options.onCreateNode) options.onCreateNode(node);\n      return node;\n    }\n    var slice = Array.prototype.slice,\n      toString = Object.prototype.toString;\n    var indexOf = /* istanbul ignore next */function indexOf(array, element) {\n      for (var i = 0, length = array.length; i < length; ++i) {\n        if (array[i] === element) return i;\n      }\n      return -1;\n    };\n    if (Array.prototype.indexOf) indexOf = function indexOf(array, element) {\n      return array.indexOf(element);\n    };\n    function indexOfObject(array, property, element) {\n      for (var i = 0, length = array.length; i < length; ++i) {\n        if (array[i][property] === element) return i;\n      }\n      return -1;\n    }\n    function sprintf(format) {\n      var args = slice.call(arguments, 1);\n      format = format.replace(/%(\\d)/g, function (match, index) {\n        return '' + args[index - 1] || /* istanbul ignore next */'';\n      });\n      return format;\n    }\n    var assign = /* istanbul ignore next */function assign(dest) {\n      var args = slice.call(arguments, 1),\n        src,\n        prop;\n      for (var i = 0, length = args.length; i < length; ++i) {\n        src = args[i];\n        for (prop in src) if (Object.prototype.hasOwnProperty.call(src, prop)) {\n          dest[prop] = src[prop];\n        }\n      }\n      return dest;\n    };\n    if (Object.assign) assign = Object.assign;\n    exports.SyntaxError = SyntaxError;\n    function fixupError(e) {\n      if (!Object.create) return e;\n      return Object.create(e, {\n        'line': {\n          'writable': true,\n          value: e.line\n        },\n        'index': {\n          'writable': true,\n          value: e.index\n        },\n        'column': {\n          'writable': true,\n          value: e.column\n        }\n      });\n    }\n    function raise(token) {\n      var message = sprintf.apply(null, slice.call(arguments, 1)),\n        error,\n        col;\n      if (token === null || typeof token.line === 'undefined') {\n        col = index - lineStart + 1;\n        error = fixupError(new SyntaxError(sprintf('[%1:%2] %3', line, col, message)));\n        error.index = index;\n        error.line = line;\n        error.column = col;\n      } else {\n        col = token.range[0] - token.lineStart;\n        error = fixupError(new SyntaxError(sprintf('[%1:%2] %3', token.line, col, message)));\n        error.line = token.line;\n        error.index = token.range[0];\n        error.column = col;\n      }\n      throw error;\n    }\n    function tokenValue(token) {\n      var raw = input.slice(token.range[0], token.range[1]);\n      if (raw) return raw;\n      return token.value;\n    }\n    function raiseUnexpectedToken(type, token) {\n      raise(token, errors.expectedToken, type, tokenValue(token));\n    }\n    function unexpected(found) {\n      var near = tokenValue(lookahead);\n      if ('undefined' !== typeof found.type) {\n        var type;\n        switch (found.type) {\n          case StringLiteral:\n            type = 'string';\n            break;\n          case Keyword:\n            type = 'keyword';\n            break;\n          case Identifier:\n            type = 'identifier';\n            break;\n          case NumericLiteral:\n            type = 'number';\n            break;\n          case Punctuator:\n            type = 'symbol';\n            break;\n          case BooleanLiteral:\n            type = 'boolean';\n            break;\n          case NilLiteral:\n            return raise(found, errors.unexpected, 'symbol', 'nil', near);\n          case EOF:\n            return raise(found, errors.unexpectedEOF);\n        }\n        return raise(found, errors.unexpected, type, tokenValue(found), near);\n      }\n      return raise(found, errors.unexpected, 'symbol', found, near);\n    }\n    var index, token, previousToken, lookahead, comments, tokenStart, line, lineStart;\n    exports.lex = lex;\n    function lex() {\n      skipWhiteSpace();\n      while (45 === input.charCodeAt(index) && 45 === input.charCodeAt(index + 1)) {\n        scanComment();\n        skipWhiteSpace();\n      }\n      if (index >= length) return {\n        type: EOF,\n        value: '<eof>',\n        line: line,\n        lineStart: lineStart,\n        range: [index, index]\n      };\n      var charCode = input.charCodeAt(index),\n        next = input.charCodeAt(index + 1);\n      tokenStart = index;\n      if (isIdentifierStart(charCode)) return scanIdentifierOrKeyword();\n      switch (charCode) {\n        case 39:\n        case 34:\n          // '\"\n          return scanStringLiteral();\n        case 48:\n        case 49:\n        case 50:\n        case 51:\n        case 52:\n        case 53:\n        case 54:\n        case 55:\n        case 56:\n        case 57:\n          // 0-9\n          return scanNumericLiteral();\n        case 46:\n          // .\n          if (isDecDigit(next)) return scanNumericLiteral();\n          if (46 === next) {\n            if (46 === input.charCodeAt(index + 2)) return scanVarargLiteral();\n            return scanPunctuator('..');\n          }\n          return scanPunctuator('.');\n        case 61:\n          // =\n          if (61 === next) return scanPunctuator('==');\n          return scanPunctuator('=');\n        case 62:\n          // >\n          if (features.bitwiseOperators) if (62 === next) return scanPunctuator('>>');\n          if (61 === next) return scanPunctuator('>=');\n          return scanPunctuator('>');\n        case 60:\n          // <\n          if (features.bitwiseOperators) if (60 === next) return scanPunctuator('<<');\n          if (61 === next) return scanPunctuator('<=');\n          return scanPunctuator('<');\n        case 126:\n          // ~\n          if (61 === next) return scanPunctuator('~=');\n          if (!features.bitwiseOperators) break;\n          return scanPunctuator('~');\n        case 58:\n          // :\n          if (features.labels) if (58 === next) return scanPunctuator('::');\n          return scanPunctuator(':');\n        case 91:\n          // [\n          if (91 === next || 61 === next) return scanLongStringLiteral();\n          return scanPunctuator('[');\n        case 47:\n          // /\n          if (features.integerDivision) if (47 === next) return scanPunctuator('//');\n          return scanPunctuator('/');\n        case 38:\n        case 124:\n          // & |\n          if (!features.bitwiseOperators) break;\n        case 42:\n        case 94:\n        case 37:\n        case 44:\n        case 123:\n        case 125:\n        case 93:\n        case 40:\n        case 41:\n        case 59:\n        case 35:\n        case 45:\n        case 43:\n          // * ^ % , { } ] ( ) ; # - +\n          return scanPunctuator(input.charAt(index));\n      }\n      return unexpected(input.charAt(index));\n    }\n    function consumeEOL() {\n      var charCode = input.charCodeAt(index),\n        peekCharCode = input.charCodeAt(index + 1);\n      if (isLineTerminator(charCode)) {\n        if (10 === charCode && 13 === peekCharCode) ++index;\n        if (13 === charCode && 10 === peekCharCode) ++index;\n        ++line;\n        lineStart = ++index;\n        return true;\n      }\n      return false;\n    }\n    function skipWhiteSpace() {\n      while (index < length) {\n        var charCode = input.charCodeAt(index);\n        if (isWhiteSpace(charCode)) {\n          ++index;\n        } else if (!consumeEOL()) {\n          break;\n        }\n      }\n    }\n    function scanIdentifierOrKeyword() {\n      var value, type;\n      while (isIdentifierPart(input.charCodeAt(++index)));\n      value = encodingMode.fixup(input.slice(tokenStart, index));\n      if (isKeyword(value)) {\n        type = Keyword;\n      } else if ('true' === value || 'false' === value) {\n        type = BooleanLiteral;\n        value = 'true' === value;\n      } else if ('nil' === value) {\n        type = NilLiteral;\n        value = null;\n      } else {\n        type = Identifier;\n      }\n      return {\n        type: type,\n        value: value,\n        line: line,\n        lineStart: lineStart,\n        range: [tokenStart, index]\n      };\n    }\n    function scanPunctuator(value) {\n      index += value.length;\n      return {\n        type: Punctuator,\n        value: value,\n        line: line,\n        lineStart: lineStart,\n        range: [tokenStart, index]\n      };\n    }\n    function scanVarargLiteral() {\n      index += 3;\n      return {\n        type: VarargLiteral,\n        value: '...',\n        line: line,\n        lineStart: lineStart,\n        range: [tokenStart, index]\n      };\n    }\n    function scanStringLiteral() {\n      var delimiter = input.charCodeAt(index++),\n        beginLine = line,\n        beginLineStart = lineStart,\n        stringStart = index,\n        string = encodingMode.discardStrings ? null : '',\n        charCode;\n      for (;;) {\n        charCode = input.charCodeAt(index++);\n        if (delimiter === charCode) break;\n        if (index > length || isLineTerminator(charCode)) {\n          string += input.slice(stringStart, index - 1);\n          raise(null, errors.unfinishedString, input.slice(tokenStart, index - 1));\n        }\n        if (92 === charCode) {\n          // backslash\n          if (!encodingMode.discardStrings) {\n            var beforeEscape = input.slice(stringStart, index - 1);\n            string += encodingMode.fixup(beforeEscape);\n          }\n          var escapeValue = readEscapeSequence();\n          if (!encodingMode.discardStrings) string += escapeValue;\n          stringStart = index;\n        }\n      }\n      if (!encodingMode.discardStrings) {\n        string += encodingMode.encodeByte(null);\n        string += encodingMode.fixup(input.slice(stringStart, index - 1));\n      }\n      return {\n        type: StringLiteral,\n        value: string,\n        line: beginLine,\n        lineStart: beginLineStart,\n        lastLine: line,\n        lastLineStart: lineStart,\n        range: [tokenStart, index]\n      };\n    }\n    function scanLongStringLiteral() {\n      var beginLine = line,\n        beginLineStart = lineStart,\n        string = readLongString(false);\n      if (false === string) raise(token, errors.expected, '[', tokenValue(token));\n      return {\n        type: StringLiteral,\n        value: encodingMode.discardStrings ? null : encodingMode.fixup(string),\n        line: beginLine,\n        lineStart: beginLineStart,\n        lastLine: line,\n        lastLineStart: lineStart,\n        range: [tokenStart, index]\n      };\n    }\n    function scanNumericLiteral() {\n      var character = input.charAt(index),\n        next = input.charAt(index + 1);\n      var literal = '0' === character && 'xX'.indexOf(next || null) >= 0 ? readHexLiteral() : readDecLiteral();\n      var foundImaginaryUnit = readImaginaryUnitSuffix(),\n        foundInt64Suffix = readInt64Suffix();\n      if (foundInt64Suffix && (foundImaginaryUnit || literal.hasFractionPart)) {\n        raise(null, errors.malformedNumber, input.slice(tokenStart, index));\n      }\n      return {\n        type: NumericLiteral,\n        value: literal.value,\n        line: line,\n        lineStart: lineStart,\n        range: [tokenStart, index]\n      };\n    }\n    function readImaginaryUnitSuffix() {\n      if (!features.imaginaryNumbers) return;\n      if ('iI'.indexOf(input.charAt(index) || null) >= 0) {\n        ++index;\n        return true;\n      } else {\n        return false;\n      }\n    }\n    function readInt64Suffix() {\n      if (!features.integerSuffixes) return;\n      if ('uU'.indexOf(input.charAt(index) || null) >= 0) {\n        ++index;\n        if ('lL'.indexOf(input.charAt(index) || null) >= 0) {\n          ++index;\n          if ('lL'.indexOf(input.charAt(index) || null) >= 0) {\n            ++index;\n            return 'ULL';\n          } else {\n            raise(null, errors.malformedNumber, input.slice(tokenStart, index));\n          }\n        } else {\n          raise(null, errors.malformedNumber, input.slice(tokenStart, index));\n        }\n      } else if ('lL'.indexOf(input.charAt(index) || null) >= 0) {\n        ++index;\n        if ('lL'.indexOf(input.charAt(index) || null) >= 0) {\n          ++index;\n          return 'LL';\n        } else {\n          raise(null, errors.malformedNumber, input.slice(tokenStart, index));\n        }\n      }\n    }\n    function readHexLiteral() {\n      var fraction = 0 // defaults to 0 as it gets summed\n        ,\n        binaryExponent = 1 // defaults to 1 as it gets multiplied\n        ,\n        binarySign = 1 // positive\n        ,\n        digit,\n        fractionStart,\n        exponentStart,\n        digitStart;\n      digitStart = index += 2; // Skip 0x part\n      if (!isHexDigit(input.charCodeAt(index))) raise(null, errors.malformedNumber, input.slice(tokenStart, index));\n      while (isHexDigit(input.charCodeAt(index))) ++index;\n      digit = parseInt(input.slice(digitStart, index), 16);\n      var foundFraction = false;\n      if ('.' === input.charAt(index)) {\n        foundFraction = true;\n        fractionStart = ++index;\n        while (isHexDigit(input.charCodeAt(index))) ++index;\n        fraction = input.slice(fractionStart, index);\n        fraction = fractionStart === index ? 0 : parseInt(fraction, 16) / Math.pow(16, index - fractionStart);\n      }\n      var foundBinaryExponent = false;\n      if ('pP'.indexOf(input.charAt(index) || null) >= 0) {\n        foundBinaryExponent = true;\n        ++index;\n        if ('+-'.indexOf(input.charAt(index) || null) >= 0) binarySign = '+' === input.charAt(index++) ? 1 : -1;\n        exponentStart = index;\n        if (!isDecDigit(input.charCodeAt(index))) raise(null, errors.malformedNumber, input.slice(tokenStart, index));\n        while (isDecDigit(input.charCodeAt(index))) ++index;\n        binaryExponent = input.slice(exponentStart, index);\n        binaryExponent = Math.pow(2, binaryExponent * binarySign);\n      }\n      return {\n        value: (digit + fraction) * binaryExponent,\n        hasFractionPart: foundFraction || foundBinaryExponent\n      };\n    }\n    function readDecLiteral() {\n      while (isDecDigit(input.charCodeAt(index))) ++index;\n      var foundFraction = false;\n      if ('.' === input.charAt(index)) {\n        foundFraction = true;\n        ++index;\n        while (isDecDigit(input.charCodeAt(index))) ++index;\n      }\n      var foundExponent = false;\n      if ('eE'.indexOf(input.charAt(index) || null) >= 0) {\n        foundExponent = true;\n        ++index;\n        if ('+-'.indexOf(input.charAt(index) || null) >= 0) ++index;\n        if (!isDecDigit(input.charCodeAt(index))) raise(null, errors.malformedNumber, input.slice(tokenStart, index));\n        while (isDecDigit(input.charCodeAt(index))) ++index;\n      }\n      return {\n        value: parseFloat(input.slice(tokenStart, index)),\n        hasFractionPart: foundFraction || foundExponent\n      };\n    }\n    function readUnicodeEscapeSequence() {\n      var sequenceStart = index++;\n      if (input.charAt(index++) !== '{') raise(null, errors.braceExpected, '{', '\\\\' + input.slice(sequenceStart, index));\n      if (!isHexDigit(input.charCodeAt(index))) raise(null, errors.hexadecimalDigitExpected, '\\\\' + input.slice(sequenceStart, index));\n      while (input.charCodeAt(index) === 0x30) ++index;\n      var escStart = index;\n      while (isHexDigit(input.charCodeAt(index))) {\n        ++index;\n        if (index - escStart > 6) raise(null, errors.tooLargeCodepoint, '\\\\' + input.slice(sequenceStart, index));\n      }\n      var b = input.charAt(index++);\n      if (b !== '}') {\n        if (b === '\"' || b === \"'\") raise(null, errors.braceExpected, '}', '\\\\' + input.slice(sequenceStart, index--));else raise(null, errors.hexadecimalDigitExpected, '\\\\' + input.slice(sequenceStart, index));\n      }\n      var codepoint = parseInt(input.slice(escStart, index - 1) || '0', 16);\n      var frag = '\\\\' + input.slice(sequenceStart, index);\n      if (codepoint > 0x10ffff) {\n        raise(null, errors.tooLargeCodepoint, frag);\n      }\n      return encodingMode.encodeUTF8(codepoint, frag);\n    }\n    function readEscapeSequence() {\n      var sequenceStart = index;\n      switch (input.charAt(index)) {\n        case 'a':\n          ++index;\n          return '\\x07';\n        case 'n':\n          ++index;\n          return '\\n';\n        case 'r':\n          ++index;\n          return '\\r';\n        case 't':\n          ++index;\n          return '\\t';\n        case 'v':\n          ++index;\n          return '\\x0b';\n        case 'b':\n          ++index;\n          return '\\b';\n        case 'f':\n          ++index;\n          return '\\f';\n        case '\\r':\n        case '\\n':\n          consumeEOL();\n          return '\\n';\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n          while (isDecDigit(input.charCodeAt(index)) && index - sequenceStart < 3) ++index;\n          var frag = input.slice(sequenceStart, index);\n          var ddd = parseInt(frag, 10);\n          if (ddd > 255) {\n            raise(null, errors.decimalEscapeTooLarge, '\\\\' + ddd);\n          }\n          return encodingMode.encodeByte(ddd, '\\\\' + frag);\n        case 'z':\n          if (features.skipWhitespaceEscape) {\n            ++index;\n            skipWhiteSpace();\n            return '';\n          }\n          break;\n        case 'x':\n          if (features.hexEscapes) {\n            if (isHexDigit(input.charCodeAt(index + 1)) && isHexDigit(input.charCodeAt(index + 2))) {\n              index += 3;\n              return encodingMode.encodeByte(parseInt(input.slice(sequenceStart + 1, index), 16), '\\\\' + input.slice(sequenceStart, index));\n            }\n            raise(null, errors.hexadecimalDigitExpected, '\\\\' + input.slice(sequenceStart, index + 2));\n          }\n          break;\n        case 'u':\n          if (features.unicodeEscapes) return readUnicodeEscapeSequence();\n          break;\n        case '\\\\':\n        case '\"':\n        case \"'\":\n          return input.charAt(index++);\n      }\n      if (features.strictEscapes) raise(null, errors.invalidEscape, '\\\\' + input.slice(sequenceStart, index + 1));\n      return input.charAt(index++);\n    }\n    function scanComment() {\n      tokenStart = index;\n      index += 2; // --\n\n      var character = input.charAt(index),\n        content = '',\n        isLong = false,\n        commentStart = index,\n        lineStartComment = lineStart,\n        lineComment = line;\n      if ('[' === character) {\n        content = readLongString(true);\n        if (false === content) content = character;else isLong = true;\n      }\n      if (!isLong) {\n        while (index < length) {\n          if (isLineTerminator(input.charCodeAt(index))) break;\n          ++index;\n        }\n        if (options.comments) content = input.slice(commentStart, index);\n      }\n      if (options.comments) {\n        var node = ast.comment(content, input.slice(tokenStart, index));\n        if (options.locations) {\n          node.loc = {\n            start: {\n              line: lineComment,\n              column: tokenStart - lineStartComment\n            },\n            end: {\n              line: line,\n              column: index - lineStart\n            }\n          };\n        }\n        if (options.ranges) {\n          node.range = [tokenStart, index];\n        }\n        if (options.onCreateNode) options.onCreateNode(node);\n        comments.push(node);\n      }\n    }\n    function readLongString(isComment) {\n      var level = 0,\n        content = '',\n        terminator = false,\n        character,\n        stringStart,\n        firstLine = line;\n      ++index; // [\n      while ('=' === input.charAt(index + level)) ++level;\n      if ('[' !== input.charAt(index + level)) return false;\n      index += level + 1;\n      if (isLineTerminator(input.charCodeAt(index))) consumeEOL();\n      stringStart = index;\n      while (index < length) {\n        while (isLineTerminator(input.charCodeAt(index))) consumeEOL();\n        character = input.charAt(index++);\n        if (']' === character) {\n          terminator = true;\n          for (var i = 0; i < level; ++i) {\n            if ('=' !== input.charAt(index + i)) terminator = false;\n          }\n          if (']' !== input.charAt(index + level)) terminator = false;\n        }\n        if (terminator) {\n          content += input.slice(stringStart, index - 1);\n          index += level + 1;\n          return content;\n        }\n      }\n      raise(null, isComment ? errors.unfinishedLongComment : errors.unfinishedLongString, firstLine, '<eof>');\n    }\n    function next() {\n      previousToken = token;\n      token = lookahead;\n      lookahead = lex();\n    }\n    function consume(value) {\n      if (value === token.value) {\n        next();\n        return true;\n      }\n      return false;\n    }\n    function expect(value) {\n      if (value === token.value) next();else raise(token, errors.expected, value, tokenValue(token));\n    }\n    function isWhiteSpace(charCode) {\n      return 9 === charCode || 32 === charCode || 0xB === charCode || 0xC === charCode;\n    }\n    function isLineTerminator(charCode) {\n      return 10 === charCode || 13 === charCode;\n    }\n    function isDecDigit(charCode) {\n      return charCode >= 48 && charCode <= 57;\n    }\n    function isHexDigit(charCode) {\n      return charCode >= 48 && charCode <= 57 || charCode >= 97 && charCode <= 102 || charCode >= 65 && charCode <= 70;\n    }\n    function isIdentifierStart(charCode) {\n      if (charCode >= 65 && charCode <= 90 || charCode >= 97 && charCode <= 122 || 95 === charCode) return true;\n      if (features.extendedIdentifiers && charCode >= 128) return true;\n      return false;\n    }\n    function isIdentifierPart(charCode) {\n      if (charCode >= 65 && charCode <= 90 || charCode >= 97 && charCode <= 122 || 95 === charCode || charCode >= 48 && charCode <= 57) return true;\n      if (features.extendedIdentifiers && charCode >= 128) return true;\n      return false;\n    }\n    function isKeyword(id) {\n      switch (id.length) {\n        case 2:\n          return 'do' === id || 'if' === id || 'in' === id || 'or' === id;\n        case 3:\n          return 'and' === id || 'end' === id || 'for' === id || 'not' === id;\n        case 4:\n          if ('else' === id || 'then' === id) return true;\n          if (features.labels && !features.contextualGoto) return 'goto' === id;\n          return false;\n        case 5:\n          return 'break' === id || 'local' === id || 'until' === id || 'while' === id;\n        case 6:\n          return 'elseif' === id || 'repeat' === id || 'return' === id;\n        case 8:\n          return 'function' === id;\n      }\n      return false;\n    }\n    function isUnary(token) {\n      if (Punctuator === token.type) return '#-~'.indexOf(token.value) >= 0;\n      if (Keyword === token.type) return 'not' === token.value;\n      return false;\n    }\n    function isBlockFollow(token) {\n      if (EOF === token.type) return true;\n      if (Keyword !== token.type) return false;\n      switch (token.value) {\n        case 'else':\n        case 'elseif':\n        case 'end':\n        case 'until':\n          return true;\n        default:\n          return false;\n      }\n    }\n    var scopes, scopeDepth, globals;\n    function createScope() {\n      var scope = scopes[scopeDepth++].slice();\n      scopes.push(scope);\n      if (options.onCreateScope) options.onCreateScope();\n    }\n    function destroyScope() {\n      var scope = scopes.pop();\n      --scopeDepth;\n      if (options.onDestroyScope) options.onDestroyScope();\n    }\n    function scopeIdentifierName(name) {\n      if (options.onLocalDeclaration) options.onLocalDeclaration(name);\n      if (-1 !== indexOf(scopes[scopeDepth], name)) return;\n      scopes[scopeDepth].push(name);\n    }\n    function scopeIdentifier(node) {\n      scopeIdentifierName(node.name);\n      attachScope(node, true);\n    }\n    function attachScope(node, isLocal) {\n      if (!isLocal && -1 === indexOfObject(globals, 'name', node.name)) globals.push(node);\n      node.isLocal = isLocal;\n    }\n    function scopeHasName(name) {\n      return -1 !== indexOf(scopes[scopeDepth], name);\n    }\n    var locations = [],\n      trackLocations;\n    function createLocationMarker() {\n      return new Marker(token);\n    }\n    function Marker(token) {\n      if (options.locations) {\n        this.loc = {\n          start: {\n            line: token.line,\n            column: token.range[0] - token.lineStart\n          },\n          end: {\n            line: 0,\n            column: 0\n          }\n        };\n      }\n      if (options.ranges) this.range = [token.range[0], 0];\n    }\n    Marker.prototype.complete = function () {\n      if (options.locations) {\n        this.loc.end.line = previousToken.lastLine || previousToken.line;\n        this.loc.end.column = previousToken.range[1] - (previousToken.lastLineStart || previousToken.lineStart);\n      }\n      if (options.ranges) {\n        this.range[1] = previousToken.range[1];\n      }\n    };\n    Marker.prototype.bless = function (node) {\n      if (this.loc) {\n        var loc = this.loc;\n        node.loc = {\n          start: {\n            line: loc.start.line,\n            column: loc.start.column\n          },\n          end: {\n            line: loc.end.line,\n            column: loc.end.column\n          }\n        };\n      }\n      if (this.range) {\n        node.range = [this.range[0], this.range[1]];\n      }\n    };\n    function markLocation() {\n      if (trackLocations) locations.push(createLocationMarker());\n    }\n    function pushLocation(marker) {\n      if (trackLocations) locations.push(marker);\n    }\n    function FullFlowContext() {\n      this.scopes = [];\n      this.pendingGotos = [];\n    }\n    FullFlowContext.prototype.isInLoop = function () {\n      var i = this.scopes.length;\n      while (i-- > 0) {\n        if (this.scopes[i].isLoop) return true;\n      }\n      return false;\n    };\n    FullFlowContext.prototype.pushScope = function (isLoop) {\n      var scope = {\n        labels: {},\n        locals: [],\n        deferredGotos: [],\n        isLoop: !!isLoop\n      };\n      this.scopes.push(scope);\n    };\n    FullFlowContext.prototype.popScope = function () {\n      for (var i = 0; i < this.pendingGotos.length; ++i) {\n        var theGoto = this.pendingGotos[i];\n        if (theGoto.maxDepth >= this.scopes.length) if (--theGoto.maxDepth <= 0) raise(theGoto.token, errors.labelNotVisible, theGoto.target);\n      }\n      this.scopes.pop();\n    };\n    FullFlowContext.prototype.addGoto = function (target, token) {\n      var localCounts = [];\n      for (var i = 0; i < this.scopes.length; ++i) {\n        var scope = this.scopes[i];\n        localCounts.push(scope.locals.length);\n        if (Object.prototype.hasOwnProperty.call(scope.labels, target)) return;\n      }\n      this.pendingGotos.push({\n        maxDepth: this.scopes.length,\n        target: target,\n        token: token,\n        localCounts: localCounts\n      });\n    };\n    FullFlowContext.prototype.addLabel = function (name, token) {\n      var scope = this.currentScope();\n      if (Object.prototype.hasOwnProperty.call(scope.labels, name)) {\n        raise(token, errors.labelAlreadyDefined, name, scope.labels[name].line);\n      } else {\n        var newGotos = [];\n        for (var i = 0; i < this.pendingGotos.length; ++i) {\n          var theGoto = this.pendingGotos[i];\n          if (theGoto.maxDepth >= this.scopes.length && theGoto.target === name) {\n            if (theGoto.localCounts[this.scopes.length - 1] < scope.locals.length) {\n              scope.deferredGotos.push(theGoto);\n            }\n            continue;\n          }\n          newGotos.push(theGoto);\n        }\n        this.pendingGotos = newGotos;\n      }\n      scope.labels[name] = {\n        localCount: scope.locals.length,\n        line: token.line\n      };\n    };\n    FullFlowContext.prototype.addLocal = function (name, token) {\n      this.currentScope().locals.push({\n        name: name,\n        token: token\n      });\n    };\n    FullFlowContext.prototype.currentScope = function () {\n      return this.scopes[this.scopes.length - 1];\n    };\n    FullFlowContext.prototype.raiseDeferredErrors = function () {\n      var scope = this.currentScope();\n      var bads = scope.deferredGotos;\n      for (var i = 0; i < bads.length; ++i) {\n        var theGoto = bads[i];\n        raise(theGoto.token, errors.gotoJumpInLocalScope, theGoto.target, scope.locals[theGoto.localCounts[this.scopes.length - 1]].name);\n      }\n    };\n    function LoopFlowContext() {\n      this.level = 0;\n      this.loopLevels = [];\n    }\n    LoopFlowContext.prototype.isInLoop = function () {\n      return !!this.loopLevels.length;\n    };\n    LoopFlowContext.prototype.pushScope = function (isLoop) {\n      ++this.level;\n      if (isLoop) this.loopLevels.push(this.level);\n    };\n    LoopFlowContext.prototype.popScope = function () {\n      var levels = this.loopLevels;\n      var levlen = levels.length;\n      if (levlen) {\n        if (levels[levlen - 1] === this.level) levels.pop();\n      }\n      --this.level;\n    };\n    LoopFlowContext.prototype.addGoto = LoopFlowContext.prototype.addLabel = function () {\n      throw new Error('This should never happen');\n    };\n    LoopFlowContext.prototype.addLocal = LoopFlowContext.prototype.raiseDeferredErrors = function () {};\n    function makeFlowContext() {\n      return features.labels ? new FullFlowContext() : new LoopFlowContext();\n    }\n    function parseChunk() {\n      next();\n      markLocation();\n      if (options.scope) createScope();\n      var flowContext = makeFlowContext();\n      flowContext.allowVararg = true;\n      flowContext.pushScope();\n      var body = parseBlock(flowContext);\n      flowContext.popScope();\n      if (options.scope) destroyScope();\n      if (EOF !== token.type) unexpected(token);\n      if (trackLocations && !body.length) previousToken = token;\n      return finishNode(ast.chunk(body));\n    }\n    function parseBlock(flowContext) {\n      var block = [],\n        statement;\n      while (!isBlockFollow(token)) {\n        if ('return' === token.value || !features.relaxedBreak && 'break' === token.value) {\n          block.push(parseStatement(flowContext));\n          break;\n        }\n        statement = parseStatement(flowContext);\n        consume(';');\n        if (statement) block.push(statement);\n      }\n      return block;\n    }\n    function parseStatement(flowContext) {\n      markLocation();\n      if (Punctuator === token.type) {\n        if (consume('::')) return parseLabelStatement(flowContext);\n      }\n      if (features.emptyStatement) {\n        if (consume(';')) {\n          if (trackLocations) locations.pop();\n          return;\n        }\n      }\n      flowContext.raiseDeferredErrors();\n      if (Keyword === token.type) {\n        switch (token.value) {\n          case 'local':\n            next();\n            return parseLocalStatement(flowContext);\n          case 'if':\n            next();\n            return parseIfStatement(flowContext);\n          case 'return':\n            next();\n            return parseReturnStatement(flowContext);\n          case 'function':\n            next();\n            var name = parseFunctionName();\n            return parseFunctionDeclaration(name);\n          case 'while':\n            next();\n            return parseWhileStatement(flowContext);\n          case 'for':\n            next();\n            return parseForStatement(flowContext);\n          case 'repeat':\n            next();\n            return parseRepeatStatement(flowContext);\n          case 'break':\n            next();\n            if (!flowContext.isInLoop()) raise(token, errors.noLoopToBreak, token.value);\n            return parseBreakStatement();\n          case 'do':\n            next();\n            return parseDoStatement(flowContext);\n          case 'goto':\n            next();\n            return parseGotoStatement(flowContext);\n        }\n      }\n      if (features.contextualGoto && token.type === Identifier && token.value === 'goto' && lookahead.type === Identifier && lookahead.value !== 'goto') {\n        next();\n        return parseGotoStatement(flowContext);\n      }\n      if (trackLocations) locations.pop();\n      return parseAssignmentOrCallStatement(flowContext);\n    }\n    function parseLabelStatement(flowContext) {\n      var nameToken = token,\n        label = parseIdentifier();\n      if (options.scope) {\n        scopeIdentifierName('::' + nameToken.value + '::');\n        attachScope(label, true);\n      }\n      expect('::');\n      flowContext.addLabel(nameToken.value, nameToken);\n      return finishNode(ast.labelStatement(label));\n    }\n    function parseBreakStatement() {\n      return finishNode(ast.breakStatement());\n    }\n    function parseGotoStatement(flowContext) {\n      var name = token.value,\n        gotoToken = previousToken,\n        label = parseIdentifier();\n      flowContext.addGoto(name, gotoToken);\n      return finishNode(ast.gotoStatement(label));\n    }\n    function parseDoStatement(flowContext) {\n      if (options.scope) createScope();\n      flowContext.pushScope();\n      var body = parseBlock(flowContext);\n      flowContext.popScope();\n      if (options.scope) destroyScope();\n      expect('end');\n      return finishNode(ast.doStatement(body));\n    }\n    function parseWhileStatement(flowContext) {\n      var condition = parseExpectedExpression(flowContext);\n      expect('do');\n      if (options.scope) createScope();\n      flowContext.pushScope(true);\n      var body = parseBlock(flowContext);\n      flowContext.popScope();\n      if (options.scope) destroyScope();\n      expect('end');\n      return finishNode(ast.whileStatement(condition, body));\n    }\n    function parseRepeatStatement(flowContext) {\n      if (options.scope) createScope();\n      flowContext.pushScope(true);\n      var body = parseBlock(flowContext);\n      expect('until');\n      flowContext.raiseDeferredErrors();\n      var condition = parseExpectedExpression(flowContext);\n      flowContext.popScope();\n      if (options.scope) destroyScope();\n      return finishNode(ast.repeatStatement(condition, body));\n    }\n    function parseReturnStatement(flowContext) {\n      var expressions = [];\n      if ('end' !== token.value) {\n        var expression = parseExpression(flowContext);\n        if (null != expression) expressions.push(expression);\n        while (consume(',')) {\n          expression = parseExpectedExpression(flowContext);\n          expressions.push(expression);\n        }\n        consume(';'); // grammar tells us ; is optional here.\n      }\n\n      return finishNode(ast.returnStatement(expressions));\n    }\n    function parseIfStatement(flowContext) {\n      var clauses = [],\n        condition,\n        body,\n        marker;\n      if (trackLocations) {\n        marker = locations[locations.length - 1];\n        locations.push(marker);\n      }\n      condition = parseExpectedExpression(flowContext);\n      expect('then');\n      if (options.scope) createScope();\n      flowContext.pushScope();\n      body = parseBlock(flowContext);\n      flowContext.popScope();\n      if (options.scope) destroyScope();\n      clauses.push(finishNode(ast.ifClause(condition, body)));\n      if (trackLocations) marker = createLocationMarker();\n      while (consume('elseif')) {\n        pushLocation(marker);\n        condition = parseExpectedExpression(flowContext);\n        expect('then');\n        if (options.scope) createScope();\n        flowContext.pushScope();\n        body = parseBlock(flowContext);\n        flowContext.popScope();\n        if (options.scope) destroyScope();\n        clauses.push(finishNode(ast.elseifClause(condition, body)));\n        if (trackLocations) marker = createLocationMarker();\n      }\n      if (consume('else')) {\n        if (trackLocations) {\n          marker = new Marker(previousToken);\n          locations.push(marker);\n        }\n        if (options.scope) createScope();\n        flowContext.pushScope();\n        body = parseBlock(flowContext);\n        flowContext.popScope();\n        if (options.scope) destroyScope();\n        clauses.push(finishNode(ast.elseClause(body)));\n      }\n      expect('end');\n      return finishNode(ast.ifStatement(clauses));\n    }\n    function parseForStatement(flowContext) {\n      var variable = parseIdentifier(),\n        body;\n      if (options.scope) {\n        createScope();\n        scopeIdentifier(variable);\n      }\n      if (consume('=')) {\n        var start = parseExpectedExpression(flowContext);\n        expect(',');\n        var end = parseExpectedExpression(flowContext);\n        var step = consume(',') ? parseExpectedExpression(flowContext) : null;\n        expect('do');\n        flowContext.pushScope(true);\n        body = parseBlock(flowContext);\n        flowContext.popScope();\n        expect('end');\n        if (options.scope) destroyScope();\n        return finishNode(ast.forNumericStatement(variable, start, end, step, body));\n      } else {\n        var variables = [variable];\n        while (consume(',')) {\n          variable = parseIdentifier();\n          if (options.scope) scopeIdentifier(variable);\n          variables.push(variable);\n        }\n        expect('in');\n        var iterators = [];\n        do {\n          var expression = parseExpectedExpression(flowContext);\n          iterators.push(expression);\n        } while (consume(','));\n        expect('do');\n        flowContext.pushScope(true);\n        body = parseBlock(flowContext);\n        flowContext.popScope();\n        expect('end');\n        if (options.scope) destroyScope();\n        return finishNode(ast.forGenericStatement(variables, iterators, body));\n      }\n    }\n    function parseLocalStatement(flowContext) {\n      var name,\n        declToken = previousToken;\n      if (Identifier === token.type) {\n        var variables = [],\n          init = [];\n        do {\n          name = parseIdentifier();\n          variables.push(name);\n          flowContext.addLocal(name.name, declToken);\n        } while (consume(','));\n        if (consume('=')) {\n          do {\n            var expression = parseExpectedExpression(flowContext);\n            init.push(expression);\n          } while (consume(','));\n        }\n        if (options.scope) {\n          for (var i = 0, l = variables.length; i < l; ++i) {\n            scopeIdentifier(variables[i]);\n          }\n        }\n        return finishNode(ast.localStatement(variables, init));\n      }\n      if (consume('function')) {\n        name = parseIdentifier();\n        flowContext.addLocal(name.name, declToken);\n        if (options.scope) {\n          scopeIdentifier(name);\n          createScope();\n        }\n        return parseFunctionDeclaration(name, true);\n      } else {\n        raiseUnexpectedToken('<name>', token);\n      }\n    }\n    function parseAssignmentOrCallStatement(flowContext) {\n      var previous = token,\n        marker,\n        startMarker;\n      var lvalue, base, name;\n      var targets = [];\n      if (trackLocations) startMarker = createLocationMarker();\n      do {\n        if (trackLocations) marker = createLocationMarker();\n        if (Identifier === token.type) {\n          name = token.value;\n          base = parseIdentifier();\n          if (options.scope) attachScope(base, scopeHasName(name));\n          lvalue = true;\n        } else if ('(' === token.value) {\n          next();\n          base = parseExpectedExpression(flowContext);\n          expect(')');\n          lvalue = false;\n        } else {\n          return unexpected(token);\n        }\n        both: for (;;) {\n          var newBase;\n          switch (StringLiteral === token.type ? '\"' : token.value) {\n            case '.':\n            case '[':\n              lvalue = true;\n              break;\n            case ':':\n            case '(':\n            case '{':\n            case '\"':\n              lvalue = null;\n              break;\n            default:\n              break both;\n          }\n          base = parsePrefixExpressionPart(base, marker, flowContext);\n        }\n        targets.push(base);\n        if (',' !== token.value) break;\n        if (!lvalue) {\n          return unexpected(token);\n        }\n        next();\n      } while (true);\n      if (targets.length === 1 && lvalue === null) {\n        pushLocation(marker);\n        return finishNode(ast.callStatement(targets[0]));\n      } else if (!lvalue) {\n        return unexpected(token);\n      }\n      expect('=');\n      var values = [];\n      do {\n        values.push(parseExpectedExpression(flowContext));\n      } while (consume(','));\n      pushLocation(startMarker);\n      return finishNode(ast.assignmentStatement(targets, values));\n    }\n    function parseIdentifier() {\n      markLocation();\n      var identifier = token.value;\n      if (Identifier !== token.type) raiseUnexpectedToken('<name>', token);\n      next();\n      return finishNode(ast.identifier(identifier));\n    }\n    function parseFunctionDeclaration(name, isLocal) {\n      var flowContext = makeFlowContext();\n      flowContext.pushScope();\n      var parameters = [];\n      expect('(');\n      if (!consume(')')) {\n        while (true) {\n          if (Identifier === token.type) {\n            var parameter = parseIdentifier();\n            if (options.scope) scopeIdentifier(parameter);\n            parameters.push(parameter);\n            if (consume(',')) continue;\n          } else if (VarargLiteral === token.type) {\n            flowContext.allowVararg = true;\n            parameters.push(parsePrimaryExpression(flowContext));\n          } else {\n            raiseUnexpectedToken('<name> or \\'...\\'', token);\n          }\n          expect(')');\n          break;\n        }\n      }\n      var body = parseBlock(flowContext);\n      flowContext.popScope();\n      expect('end');\n      if (options.scope) destroyScope();\n      isLocal = isLocal || false;\n      return finishNode(ast.functionStatement(name, parameters, isLocal, body));\n    }\n    function parseFunctionName() {\n      var base, name, marker;\n      if (trackLocations) marker = createLocationMarker();\n      base = parseIdentifier();\n      if (options.scope) {\n        attachScope(base, scopeHasName(base.name));\n        createScope();\n      }\n      while (consume('.')) {\n        pushLocation(marker);\n        name = parseIdentifier();\n        base = finishNode(ast.memberExpression(base, '.', name));\n      }\n      if (consume(':')) {\n        pushLocation(marker);\n        name = parseIdentifier();\n        base = finishNode(ast.memberExpression(base, ':', name));\n        if (options.scope) scopeIdentifierName('self');\n      }\n      return base;\n    }\n    function parseTableConstructor(flowContext) {\n      var fields = [],\n        key,\n        value;\n      while (true) {\n        markLocation();\n        if (Punctuator === token.type && consume('[')) {\n          key = parseExpectedExpression(flowContext);\n          expect(']');\n          expect('=');\n          value = parseExpectedExpression(flowContext);\n          fields.push(finishNode(ast.tableKey(key, value)));\n        } else if (Identifier === token.type) {\n          if ('=' === lookahead.value) {\n            key = parseIdentifier();\n            next();\n            value = parseExpectedExpression(flowContext);\n            fields.push(finishNode(ast.tableKeyString(key, value)));\n          } else {\n            value = parseExpectedExpression(flowContext);\n            fields.push(finishNode(ast.tableValue(value)));\n          }\n        } else {\n          if (null == (value = parseExpression(flowContext))) {\n            locations.pop();\n            break;\n          }\n          fields.push(finishNode(ast.tableValue(value)));\n        }\n        if (',;'.indexOf(token.value) >= 0) {\n          next();\n          continue;\n        }\n        break;\n      }\n      expect('}');\n      return finishNode(ast.tableConstructorExpression(fields));\n    }\n    function parseExpression(flowContext) {\n      var expression = parseSubExpression(0, flowContext);\n      return expression;\n    }\n    function parseExpectedExpression(flowContext) {\n      var expression = parseExpression(flowContext);\n      if (null == expression) raiseUnexpectedToken('<expression>', token);else return expression;\n    }\n    function binaryPrecedence(operator) {\n      var charCode = operator.charCodeAt(0),\n        length = operator.length;\n      if (1 === length) {\n        switch (charCode) {\n          case 94:\n            return 12;\n          // ^\n          case 42:\n          case 47:\n          case 37:\n            return 10;\n          // * / %\n          case 43:\n          case 45:\n            return 9;\n          // + -\n          case 38:\n            return 6;\n          // &\n          case 126:\n            return 5;\n          // ~\n          case 124:\n            return 4;\n          // |\n          case 60:\n          case 62:\n            return 3;\n          // < >\n        }\n      } else if (2 === length) {\n        switch (charCode) {\n          case 47:\n            return 10;\n          // //\n          case 46:\n            return 8;\n          // ..\n          case 60:\n          case 62:\n            if ('<<' === operator || '>>' === operator) return 7; // << >>\n            return 3;\n          // <= >=\n          case 61:\n          case 126:\n            return 3;\n          // == ~=\n          case 111:\n            return 1;\n          // or\n        }\n      } else if (97 === charCode && 'and' === operator) return 2;\n      return 0;\n    }\n    function parseSubExpression(minPrecedence, flowContext) {\n      var operator = token.value,\n        expression,\n        marker;\n      if (trackLocations) marker = createLocationMarker();\n      if (isUnary(token)) {\n        markLocation();\n        next();\n        var argument = parseSubExpression(10, flowContext);\n        if (argument == null) raiseUnexpectedToken('<expression>', token);\n        expression = finishNode(ast.unaryExpression(operator, argument));\n      }\n      if (null == expression) {\n        expression = parsePrimaryExpression(flowContext);\n        if (null == expression) {\n          expression = parsePrefixExpression(flowContext);\n        }\n      }\n      if (null == expression) return null;\n      var precedence;\n      while (true) {\n        operator = token.value;\n        precedence = Punctuator === token.type || Keyword === token.type ? binaryPrecedence(operator) : 0;\n        if (precedence === 0 || precedence <= minPrecedence) break;\n        if ('^' === operator || '..' === operator) --precedence;\n        next();\n        var right = parseSubExpression(precedence, flowContext);\n        if (null == right) raiseUnexpectedToken('<expression>', token);\n        if (trackLocations) locations.push(marker);\n        expression = finishNode(ast.binaryExpression(operator, expression, right));\n      }\n      return expression;\n    }\n    function parsePrefixExpressionPart(base, marker, flowContext) {\n      var expression, identifier;\n      if (Punctuator === token.type) {\n        switch (token.value) {\n          case '[':\n            pushLocation(marker);\n            next();\n            expression = parseExpectedExpression(flowContext);\n            expect(']');\n            return finishNode(ast.indexExpression(base, expression));\n          case '.':\n            pushLocation(marker);\n            next();\n            identifier = parseIdentifier();\n            return finishNode(ast.memberExpression(base, '.', identifier));\n          case ':':\n            pushLocation(marker);\n            next();\n            identifier = parseIdentifier();\n            base = finishNode(ast.memberExpression(base, ':', identifier));\n            pushLocation(marker);\n            return parseCallExpression(base, flowContext);\n          case '(':\n          case '{':\n            // args\n            pushLocation(marker);\n            return parseCallExpression(base, flowContext);\n        }\n      } else if (StringLiteral === token.type) {\n        pushLocation(marker);\n        return parseCallExpression(base, flowContext);\n      }\n      return null;\n    }\n    function parsePrefixExpression(flowContext) {\n      var base, name, marker;\n      if (trackLocations) marker = createLocationMarker();\n      if (Identifier === token.type) {\n        name = token.value;\n        base = parseIdentifier();\n        if (options.scope) attachScope(base, scopeHasName(name));\n      } else if (consume('(')) {\n        base = parseExpectedExpression(flowContext);\n        expect(')');\n      } else {\n        return null;\n      }\n      for (;;) {\n        var newBase = parsePrefixExpressionPart(base, marker, flowContext);\n        if (newBase === null) break;\n        base = newBase;\n      }\n      return base;\n    }\n    function parseCallExpression(base, flowContext) {\n      if (Punctuator === token.type) {\n        switch (token.value) {\n          case '(':\n            if (!features.emptyStatement) {\n              if (token.line !== previousToken.line) raise(null, errors.ambiguousSyntax, token.value);\n            }\n            next();\n            var expressions = [];\n            var expression = parseExpression(flowContext);\n            if (null != expression) expressions.push(expression);\n            while (consume(',')) {\n              expression = parseExpectedExpression(flowContext);\n              expressions.push(expression);\n            }\n            expect(')');\n            return finishNode(ast.callExpression(base, expressions));\n          case '{':\n            markLocation();\n            next();\n            var table = parseTableConstructor(flowContext);\n            return finishNode(ast.tableCallExpression(base, table));\n        }\n      } else if (StringLiteral === token.type) {\n        return finishNode(ast.stringCallExpression(base, parsePrimaryExpression(flowContext)));\n      }\n      raiseUnexpectedToken('function arguments', token);\n    }\n    function parsePrimaryExpression(flowContext) {\n      var literals = StringLiteral | NumericLiteral | BooleanLiteral | NilLiteral | VarargLiteral,\n        value = token.value,\n        type = token.type,\n        marker;\n      if (trackLocations) marker = createLocationMarker();\n      if (type === VarargLiteral && !flowContext.allowVararg) {\n        raise(token, errors.cannotUseVararg, token.value);\n      }\n      if (type & literals) {\n        pushLocation(marker);\n        var raw = input.slice(token.range[0], token.range[1]);\n        next();\n        return finishNode(ast.literal(type, value, raw));\n      } else if (Keyword === type && 'function' === value) {\n        pushLocation(marker);\n        next();\n        if (options.scope) createScope();\n        return parseFunctionDeclaration(null);\n      } else if (consume('{')) {\n        pushLocation(marker);\n        return parseTableConstructor(flowContext);\n      }\n    }\n    exports.parse = parse;\n    var versionFeatures = {\n      '5.1': {},\n      '5.2': {\n        labels: true,\n        emptyStatement: true,\n        hexEscapes: true,\n        skipWhitespaceEscape: true,\n        strictEscapes: true,\n        relaxedBreak: true\n      },\n      '5.3': {\n        labels: true,\n        emptyStatement: true,\n        hexEscapes: true,\n        skipWhitespaceEscape: true,\n        strictEscapes: true,\n        unicodeEscapes: true,\n        bitwiseOperators: true,\n        integerDivision: true,\n        relaxedBreak: true\n      },\n      'LuaJIT': {\n        labels: true,\n        contextualGoto: true,\n        hexEscapes: true,\n        skipWhitespaceEscape: true,\n        strictEscapes: true,\n        unicodeEscapes: true,\n        imaginaryNumbers: true,\n        integerSuffixes: true\n      }\n    };\n    function parse(_input, _options) {\n      if ('undefined' === typeof _options && 'object' === typeof _input) {\n        _options = _input;\n        _input = undefined;\n      }\n      if (!_options) _options = {};\n      input = _input || '';\n      options = assign({}, defaultOptions, _options);\n      index = 0;\n      line = 1;\n      lineStart = 0;\n      length = input.length;\n      scopes = [[]];\n      scopeDepth = 0;\n      globals = [];\n      locations = [];\n      if (!Object.prototype.hasOwnProperty.call(versionFeatures, options.luaVersion)) {\n        throw new Error(sprintf(\"Lua version '%1' not supported\", options.luaVersion));\n      }\n      features = assign({}, versionFeatures[options.luaVersion]);\n      if (options.extendedIdentifiers !== void 0) features.extendedIdentifiers = !!options.extendedIdentifiers;\n      if (!Object.prototype.hasOwnProperty.call(encodingModes, options.encodingMode)) {\n        throw new Error(sprintf(\"Encoding mode '%1' not supported\", options.encodingMode));\n      }\n      encodingMode = encodingModes[options.encodingMode];\n      if (options.comments) comments = [];\n      if (!options.wait) return end();\n      return exports;\n    }\n    exports.write = write;\n    function write(_input) {\n      input += String(_input);\n      length = input.length;\n      return exports;\n    }\n    exports.end = end;\n    function end(_input) {\n      if ('undefined' !== typeof _input) write(_input);\n      if (input && input.substr(0, 2) === '#!') input = input.replace(/^.*/, function (line) {\n        return line.replace(/./g, ' ');\n      });\n      length = input.length;\n      trackLocations = options.locations || options.ranges;\n      lookahead = lex();\n      var chunk = parseChunk();\n      if (options.comments) chunk.comments = comments;\n      if (options.scope) chunk.globals = globals;\n      if (locations.length > 0) throw new Error('Location tracking failed. This is most likely a bug in luaparse');\n      return chunk;\n    }\n  });\n});\nace.define(\"ace/mode/lua_worker\", [], function (require, exports, module) {\n  \"use strict\";\n\n  var oop = require(\"../lib/oop\");\n  var Mirror = require(\"../worker/mirror\").Mirror;\n  var luaparse = require(\"../mode/lua/luaparse\");\n  var Worker = exports.Worker = function (sender) {\n    Mirror.call(this, sender);\n    this.setTimeout(500);\n  };\n  oop.inherits(Worker, Mirror);\n  (function () {\n    this.onUpdate = function () {\n      var value = this.doc.getValue();\n      var errors = [];\n      try {\n        luaparse.parse(value);\n      } catch (e) {\n        if (e instanceof luaparse.SyntaxError) {\n          errors.push({\n            row: e.line - 1,\n            column: e.column,\n            text: e.message,\n            type: \"error\"\n          });\n        }\n      }\n      this.sender.emit(\"annotate\", errors);\n    };\n  }).call(Worker.prototype);\n});","map":null,"metadata":{},"sourceType":"script"}