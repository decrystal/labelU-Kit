{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return _extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    _extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar ace_builds_1 = require(\"ace-builds\");\nvar PropTypes = require(\"prop-types\");\nvar React = require(\"react\");\nvar isEqual = require(\"lodash.isequal\");\nvar editorOptions_1 = require(\"./editorOptions\");\nvar ace = (0, editorOptions_1.getAceInstance)();\nvar ReactAce = /** @class */function (_super) {\n  __extends(ReactAce, _super);\n  function ReactAce(props) {\n    var _this = _super.call(this, props) || this;\n    editorOptions_1.editorEvents.forEach(function (method) {\n      _this[method] = _this[method].bind(_this);\n    });\n    _this.debounce = editorOptions_1.debounce;\n    return _this;\n  }\n  ReactAce.prototype.isInShadow = function (node) {\n    var parent = node && node.parentNode;\n    while (parent) {\n      if (parent.toString() === \"[object ShadowRoot]\") {\n        return true;\n      }\n      parent = parent.parentNode;\n    }\n    return false;\n  };\n  ReactAce.prototype.componentDidMount = function () {\n    var _this = this;\n    var _a = this.props,\n      className = _a.className,\n      onBeforeLoad = _a.onBeforeLoad,\n      onValidate = _a.onValidate,\n      mode = _a.mode,\n      focus = _a.focus,\n      theme = _a.theme,\n      fontSize = _a.fontSize,\n      value = _a.value,\n      defaultValue = _a.defaultValue,\n      showGutter = _a.showGutter,\n      wrapEnabled = _a.wrapEnabled,\n      showPrintMargin = _a.showPrintMargin,\n      _b = _a.scrollMargin,\n      scrollMargin = _b === void 0 ? [0, 0, 0, 0] : _b,\n      keyboardHandler = _a.keyboardHandler,\n      onLoad = _a.onLoad,\n      commands = _a.commands,\n      annotations = _a.annotations,\n      markers = _a.markers,\n      placeholder = _a.placeholder;\n    this.editor = ace.edit(this.refEditor);\n    if (onBeforeLoad) {\n      onBeforeLoad(ace);\n    }\n    var editorProps = Object.keys(this.props.editorProps);\n    for (var i = 0; i < editorProps.length; i++) {\n      this.editor[editorProps[i]] = this.props.editorProps[editorProps[i]];\n    }\n    if (this.props.debounceChangePeriod) {\n      this.onChange = this.debounce(this.onChange, this.props.debounceChangePeriod);\n    }\n    this.editor.renderer.setScrollMargin(scrollMargin[0], scrollMargin[1], scrollMargin[2], scrollMargin[3]);\n    if (this.isInShadow(this.refEditor)) {\n      this.editor.renderer.attachToShadowRoot();\n    }\n    this.editor.getSession().setMode(typeof mode === \"string\" ? \"ace/mode/\".concat(mode) : mode);\n    if (theme && theme !== \"\") this.editor.setTheme(\"ace/theme/\".concat(theme));\n    this.editor.setFontSize(typeof fontSize === \"number\" ? \"\".concat(fontSize, \"px\") : fontSize);\n    this.editor.getSession().setValue(!defaultValue ? value || \"\" : defaultValue);\n    if (this.props.navigateToFileEnd) {\n      this.editor.navigateFileEnd();\n    }\n    this.editor.renderer.setShowGutter(showGutter);\n    this.editor.getSession().setUseWrapMode(wrapEnabled);\n    this.editor.setShowPrintMargin(showPrintMargin);\n    this.editor.on(\"focus\", this.onFocus);\n    this.editor.on(\"blur\", this.onBlur);\n    this.editor.on(\"copy\", this.onCopy);\n    this.editor.on(\"paste\", this.onPaste);\n    this.editor.on(\"change\", this.onChange);\n    this.editor.on(\"input\", this.onInput);\n    if (placeholder) {\n      this.updatePlaceholder();\n    }\n    this.editor.getSession().selection.on(\"changeSelection\", this.onSelectionChange);\n    this.editor.getSession().selection.on(\"changeCursor\", this.onCursorChange);\n    if (onValidate) {\n      // @ts-ignore types don't include\n      this.editor.getSession().on(\"changeAnnotation\", function () {\n        // tslint:disable-next-line:no-shadowed-variable\n        var annotations = _this.editor.getSession().getAnnotations();\n        _this.props.onValidate(annotations);\n      });\n    }\n    this.editor.session.on(\"changeScrollTop\", this.onScroll);\n    this.editor.getSession().setAnnotations(annotations || []);\n    if (markers && markers.length > 0) {\n      this.handleMarkers(markers);\n    }\n    // get a list of possible options to avoid 'misspelled option errors'\n    var availableOptions = this.editor.$options;\n    editorOptions_1.editorOptions.forEach(function (option) {\n      if (availableOptions.hasOwnProperty(option)) {\n        // @ts-ignore\n        _this.editor.setOption(option, _this.props[option]);\n      } else if (_this.props[option]) {\n        console.warn(\"ReactAce: editor option \".concat(option, \" was activated but not found. Did you need to import a related tool or did you possibly mispell the option?\"));\n      }\n    });\n    this.handleOptions(this.props);\n    if (Array.isArray(commands)) {\n      commands.forEach(function (command) {\n        if (typeof command.exec === \"string\") {\n          _this.editor.commands.bindKey(command.bindKey, command.exec);\n        } else {\n          _this.editor.commands.addCommand(command);\n        }\n      });\n    }\n    if (keyboardHandler) {\n      this.editor.setKeyboardHandler(\"ace/keyboard/\" + keyboardHandler);\n    }\n    if (className) {\n      this.refEditor.className += \" \" + className;\n    }\n    if (onLoad) {\n      onLoad(this.editor);\n    }\n    this.editor.resize();\n    if (focus) {\n      this.editor.focus();\n    }\n  };\n  ReactAce.prototype.componentDidUpdate = function (prevProps) {\n    var oldProps = prevProps;\n    var nextProps = this.props;\n    for (var i = 0; i < editorOptions_1.editorOptions.length; i++) {\n      var option = editorOptions_1.editorOptions[i];\n      if (nextProps[option] !== oldProps[option]) {\n        // @ts-ignore\n        this.editor.setOption(option, nextProps[option]);\n      }\n    }\n    if (nextProps.className !== oldProps.className) {\n      var appliedClasses = this.refEditor.className;\n      var appliedClassesArray_1 = appliedClasses.trim().split(\" \");\n      var oldClassesArray = oldProps.className.trim().split(\" \");\n      oldClassesArray.forEach(function (oldClass) {\n        var index = appliedClassesArray_1.indexOf(oldClass);\n        appliedClassesArray_1.splice(index, 1);\n      });\n      this.refEditor.className = \" \" + nextProps.className + \" \" + appliedClassesArray_1.join(\" \");\n    }\n    // First process editor value, as it may create a new session (see issue #300)\n    var valueChanged = this.editor && nextProps.value != null && this.editor.getValue() !== nextProps.value;\n    if (valueChanged) {\n      // editor.setValue is a synchronous function call, change event is emitted before setValue return.\n      this.silent = true;\n      var pos = this.editor.session.selection.toJSON();\n      this.editor.setValue(nextProps.value, nextProps.cursorStart);\n      this.editor.session.selection.fromJSON(pos);\n      this.silent = false;\n    }\n    if (nextProps.placeholder !== oldProps.placeholder) {\n      this.updatePlaceholder();\n    }\n    if (nextProps.mode !== oldProps.mode) {\n      this.editor.getSession().setMode(typeof nextProps.mode === \"string\" ? \"ace/mode/\".concat(nextProps.mode) : nextProps.mode);\n    }\n    if (nextProps.theme !== oldProps.theme) {\n      this.editor.setTheme(\"ace/theme/\" + nextProps.theme);\n    }\n    if (nextProps.keyboardHandler !== oldProps.keyboardHandler) {\n      if (nextProps.keyboardHandler) {\n        this.editor.setKeyboardHandler(\"ace/keyboard/\" + nextProps.keyboardHandler);\n      } else {\n        this.editor.setKeyboardHandler(null);\n      }\n    }\n    if (nextProps.fontSize !== oldProps.fontSize) {\n      this.editor.setFontSize(typeof nextProps.fontSize === \"number\" ? \"\".concat(nextProps.fontSize, \"px\") : nextProps.fontSize);\n    }\n    if (nextProps.wrapEnabled !== oldProps.wrapEnabled) {\n      this.editor.getSession().setUseWrapMode(nextProps.wrapEnabled);\n    }\n    if (nextProps.showPrintMargin !== oldProps.showPrintMargin) {\n      this.editor.setShowPrintMargin(nextProps.showPrintMargin);\n    }\n    if (nextProps.showGutter !== oldProps.showGutter) {\n      this.editor.renderer.setShowGutter(nextProps.showGutter);\n    }\n    if (!isEqual(nextProps.setOptions, oldProps.setOptions)) {\n      this.handleOptions(nextProps);\n    }\n    // if the value or annotations changed, set the annotations\n    // changing the value may create create a new session which will require annotations to be re-set\n    if (valueChanged || !isEqual(nextProps.annotations, oldProps.annotations)) {\n      this.editor.getSession().setAnnotations(nextProps.annotations || []);\n    }\n    if (!isEqual(nextProps.markers, oldProps.markers) && Array.isArray(nextProps.markers)) {\n      this.handleMarkers(nextProps.markers);\n    }\n    // this doesn't look like it works at all....\n    if (!isEqual(nextProps.scrollMargin, oldProps.scrollMargin)) {\n      this.handleScrollMargins(nextProps.scrollMargin);\n    }\n    if (prevProps.height !== this.props.height || prevProps.width !== this.props.width) {\n      this.editor.resize();\n    }\n    if (this.props.focus && !prevProps.focus) {\n      this.editor.focus();\n    }\n  };\n  ReactAce.prototype.handleScrollMargins = function (margins) {\n    if (margins === void 0) {\n      margins = [0, 0, 0, 0];\n    }\n    this.editor.renderer.setScrollMargin(margins[0], margins[1], margins[2], margins[3]);\n  };\n  ReactAce.prototype.componentWillUnmount = function () {\n    if (this.editor) {\n      this.editor.destroy();\n      this.editor = null;\n    }\n  };\n  ReactAce.prototype.onChange = function (event) {\n    if (this.props.onChange && !this.silent) {\n      var value = this.editor.getValue();\n      this.props.onChange(value, event);\n    }\n  };\n  ReactAce.prototype.onSelectionChange = function (event) {\n    if (this.props.onSelectionChange) {\n      var value = this.editor.getSelection();\n      this.props.onSelectionChange(value, event);\n    }\n  };\n  ReactAce.prototype.onCursorChange = function (event) {\n    if (this.props.onCursorChange) {\n      var value = this.editor.getSelection();\n      this.props.onCursorChange(value, event);\n    }\n  };\n  ReactAce.prototype.onInput = function (event) {\n    if (this.props.onInput) {\n      this.props.onInput(event);\n    }\n    if (this.props.placeholder) {\n      this.updatePlaceholder();\n    }\n  };\n  ReactAce.prototype.onFocus = function (event) {\n    if (this.props.onFocus) {\n      this.props.onFocus(event, this.editor);\n    }\n  };\n  ReactAce.prototype.onBlur = function (event) {\n    if (this.props.onBlur) {\n      this.props.onBlur(event, this.editor);\n    }\n  };\n  ReactAce.prototype.onCopy = function (_a) {\n    var text = _a.text;\n    if (this.props.onCopy) {\n      this.props.onCopy(text);\n    }\n  };\n  ReactAce.prototype.onPaste = function (_a) {\n    var text = _a.text;\n    if (this.props.onPaste) {\n      this.props.onPaste(text);\n    }\n  };\n  ReactAce.prototype.onScroll = function () {\n    if (this.props.onScroll) {\n      this.props.onScroll(this.editor);\n    }\n  };\n  ReactAce.prototype.handleOptions = function (props) {\n    var setOptions = Object.keys(props.setOptions);\n    for (var y = 0; y < setOptions.length; y++) {\n      // @ts-ignore\n      this.editor.setOption(setOptions[y], props.setOptions[setOptions[y]]);\n    }\n  };\n  ReactAce.prototype.handleMarkers = function (markers) {\n    var _this = this;\n    // remove foreground markers\n    var currentMarkers = this.editor.getSession().getMarkers(true);\n    for (var i in currentMarkers) {\n      if (currentMarkers.hasOwnProperty(i)) {\n        this.editor.getSession().removeMarker(currentMarkers[i].id);\n      }\n    }\n    // remove background markers except active line marker and selected word marker\n    currentMarkers = this.editor.getSession().getMarkers(false);\n    for (var i in currentMarkers) {\n      if (currentMarkers.hasOwnProperty(i) && currentMarkers[i].clazz !== \"ace_active-line\" && currentMarkers[i].clazz !== \"ace_selected-word\") {\n        this.editor.getSession().removeMarker(currentMarkers[i].id);\n      }\n    }\n    // add new markers\n    markers.forEach(function (_a) {\n      var startRow = _a.startRow,\n        startCol = _a.startCol,\n        endRow = _a.endRow,\n        endCol = _a.endCol,\n        className = _a.className,\n        type = _a.type,\n        _b = _a.inFront,\n        inFront = _b === void 0 ? false : _b;\n      var range = new ace_builds_1.Range(startRow, startCol, endRow, endCol);\n      _this.editor.getSession().addMarker(range, className, type, inFront);\n    });\n  };\n  ReactAce.prototype.updatePlaceholder = function () {\n    // Adapted from https://stackoverflow.com/questions/26695708/how-can-i-add-placeholder-text-when-the-editor-is-empty\n    var editor = this.editor;\n    var placeholder = this.props.placeholder;\n    var showPlaceholder = !editor.session.getValue().length;\n    var node = editor.renderer.placeholderNode;\n    if (!showPlaceholder && node) {\n      editor.renderer.scroller.removeChild(editor.renderer.placeholderNode);\n      editor.renderer.placeholderNode = null;\n    } else if (showPlaceholder && !node) {\n      node = editor.renderer.placeholderNode = document.createElement(\"div\");\n      node.textContent = placeholder || \"\";\n      node.className = \"ace_comment ace_placeholder\";\n      node.style.padding = \"0 9px\";\n      node.style.position = \"absolute\";\n      node.style.zIndex = \"3\";\n      editor.renderer.scroller.appendChild(node);\n    } else if (showPlaceholder && node) {\n      node.textContent = placeholder;\n    }\n  };\n  ReactAce.prototype.updateRef = function (item) {\n    this.refEditor = item;\n  };\n  ReactAce.prototype.render = function () {\n    var _a = this.props,\n      name = _a.name,\n      width = _a.width,\n      height = _a.height,\n      style = _a.style;\n    var divStyle = __assign({\n      width: width,\n      height: height\n    }, style);\n    return React.createElement(\"div\", {\n      ref: this.updateRef,\n      id: name,\n      style: divStyle\n    });\n  };\n  ReactAce.propTypes = {\n    mode: PropTypes.oneOfType([PropTypes.string, PropTypes.object]),\n    focus: PropTypes.bool,\n    theme: PropTypes.string,\n    name: PropTypes.string,\n    className: PropTypes.string,\n    height: PropTypes.string,\n    width: PropTypes.string,\n    fontSize: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),\n    showGutter: PropTypes.bool,\n    onChange: PropTypes.func,\n    onCopy: PropTypes.func,\n    onPaste: PropTypes.func,\n    onFocus: PropTypes.func,\n    onInput: PropTypes.func,\n    onBlur: PropTypes.func,\n    onScroll: PropTypes.func,\n    value: PropTypes.string,\n    defaultValue: PropTypes.string,\n    onLoad: PropTypes.func,\n    onSelectionChange: PropTypes.func,\n    onCursorChange: PropTypes.func,\n    onBeforeLoad: PropTypes.func,\n    onValidate: PropTypes.func,\n    minLines: PropTypes.number,\n    maxLines: PropTypes.number,\n    readOnly: PropTypes.bool,\n    highlightActiveLine: PropTypes.bool,\n    tabSize: PropTypes.number,\n    showPrintMargin: PropTypes.bool,\n    cursorStart: PropTypes.number,\n    debounceChangePeriod: PropTypes.number,\n    editorProps: PropTypes.object,\n    setOptions: PropTypes.object,\n    style: PropTypes.object,\n    scrollMargin: PropTypes.array,\n    annotations: PropTypes.array,\n    markers: PropTypes.array,\n    keyboardHandler: PropTypes.string,\n    wrapEnabled: PropTypes.bool,\n    enableSnippets: PropTypes.bool,\n    enableBasicAutocompletion: PropTypes.oneOfType([PropTypes.bool, PropTypes.array]),\n    enableLiveAutocompletion: PropTypes.oneOfType([PropTypes.bool, PropTypes.array]),\n    navigateToFileEnd: PropTypes.bool,\n    commands: PropTypes.array,\n    placeholder: PropTypes.string\n  };\n  ReactAce.defaultProps = {\n    name: \"ace-editor\",\n    focus: false,\n    mode: \"\",\n    theme: \"\",\n    height: \"500px\",\n    width: \"500px\",\n    fontSize: 12,\n    enableSnippets: false,\n    showGutter: true,\n    onChange: null,\n    onPaste: null,\n    onLoad: null,\n    onScroll: null,\n    minLines: null,\n    maxLines: null,\n    readOnly: false,\n    highlightActiveLine: true,\n    showPrintMargin: true,\n    tabSize: 4,\n    cursorStart: 1,\n    editorProps: {},\n    style: {},\n    scrollMargin: [0, 0, 0, 0],\n    setOptions: {},\n    wrapEnabled: false,\n    enableBasicAutocompletion: false,\n    enableLiveAutocompletion: false,\n    placeholder: null,\n    navigateToFileEnd: true\n  };\n  return ReactAce;\n}(React.Component);\nexports.default = ReactAce;","map":null,"metadata":{},"sourceType":"script"}