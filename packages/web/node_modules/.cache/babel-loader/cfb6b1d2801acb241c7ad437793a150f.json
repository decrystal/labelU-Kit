{"ast":null,"code":"\"no use strict\";\n\n!function (window) {\n  if (typeof window.window != \"undefined\" && window.document) return;\n  if (window.require && window.define) return;\n  if (!window.console) {\n    window.console = function () {\n      var msgs = Array.prototype.slice.call(arguments, 0);\n      postMessage({\n        type: \"log\",\n        data: msgs\n      });\n    };\n    window.console.error = window.console.warn = window.console.log = window.console.trace = window.console;\n  }\n  window.window = window;\n  window.ace = window;\n  window.onerror = function (message, file, line, col, err) {\n    postMessage({\n      type: \"error\",\n      data: {\n        message: message,\n        data: err && err.data,\n        file: file,\n        line: line,\n        col: col,\n        stack: err && err.stack\n      }\n    });\n  };\n  window.normalizeModule = function (parentId, moduleName) {\n    // normalize plugin requires\n    if (moduleName.indexOf(\"!\") !== -1) {\n      var chunks = moduleName.split(\"!\");\n      return window.normalizeModule(parentId, chunks[0]) + \"!\" + window.normalizeModule(parentId, chunks[1]);\n    }\n    // normalize relative requires\n    if (moduleName.charAt(0) == \".\") {\n      var base = parentId.split(\"/\").slice(0, -1).join(\"/\");\n      moduleName = (base ? base + \"/\" : \"\") + moduleName;\n      while (moduleName.indexOf(\".\") !== -1 && previous != moduleName) {\n        var previous = moduleName;\n        moduleName = moduleName.replace(/^\\.\\//, \"\").replace(/\\/\\.\\//, \"/\").replace(/[^\\/]+\\/\\.\\.\\//, \"\");\n      }\n    }\n    return moduleName;\n  };\n  window.require = function require(parentId, id) {\n    if (!id) {\n      id = parentId;\n      parentId = null;\n    }\n    if (!id.charAt) throw new Error(\"worker.js require() accepts only (parentId, id) as arguments\");\n    id = window.normalizeModule(parentId, id);\n    var module = window.require.modules[id];\n    if (module) {\n      if (!module.initialized) {\n        module.initialized = true;\n        module.exports = module.factory().exports;\n      }\n      return module.exports;\n    }\n    if (!window.require.tlns) return console.log(\"unable to load \" + id);\n    var path = resolveModuleId(id, window.require.tlns);\n    if (path.slice(-3) != \".js\") path += \".js\";\n    window.require.id = id;\n    window.require.modules[id] = {}; // prevent infinite loop on broken modules\n    importScripts(path);\n    return window.require(parentId, id);\n  };\n  function resolveModuleId(id, paths) {\n    var testPath = id,\n      tail = \"\";\n    while (testPath) {\n      var alias = paths[testPath];\n      if (typeof alias == \"string\") {\n        return alias + tail;\n      } else if (alias) {\n        return alias.location.replace(/\\/*$/, \"/\") + (tail || alias.main || alias.name);\n      } else if (alias === false) {\n        return \"\";\n      }\n      var i = testPath.lastIndexOf(\"/\");\n      if (i === -1) break;\n      tail = testPath.substr(i) + tail;\n      testPath = testPath.slice(0, i);\n    }\n    return id;\n  }\n  window.require.modules = {};\n  window.require.tlns = {};\n  window.define = function (id, deps, _factory) {\n    if (arguments.length == 2) {\n      _factory = deps;\n      if (typeof id != \"string\") {\n        deps = id;\n        id = window.require.id;\n      }\n    } else if (arguments.length == 1) {\n      _factory = id;\n      deps = [];\n      id = window.require.id;\n    }\n    if (typeof _factory != \"function\") {\n      window.require.modules[id] = {\n        exports: _factory,\n        initialized: true\n      };\n      return;\n    }\n    if (!deps.length)\n      // If there is no dependencies, we inject \"require\", \"exports\" and\n      // \"module\" as dependencies, to provide CommonJS compatibility.\n      deps = [\"require\", \"exports\", \"module\"];\n    var req = function req(childId) {\n      return window.require(id, childId);\n    };\n    window.require.modules[id] = {\n      exports: {},\n      factory: function factory() {\n        var module = this;\n        var returnExports = _factory.apply(this, deps.slice(0, _factory.length).map(function (dep) {\n          switch (dep) {\n            // Because \"require\", \"exports\" and \"module\" aren't actual\n            // dependencies, we must handle them seperately.\n            case \"require\":\n              return req;\n            case \"exports\":\n              return module.exports;\n            case \"module\":\n              return module;\n            // But for all other dependencies, we can just go ahead and\n            // require them.\n            default:\n              return req(dep);\n          }\n        }));\n        if (returnExports) module.exports = returnExports;\n        return module;\n      }\n    };\n  };\n  window.define.amd = {};\n  window.require.tlns = {};\n  window.initBaseUrls = function initBaseUrls(topLevelNamespaces) {\n    for (var i in topLevelNamespaces) this.require.tlns[i] = topLevelNamespaces[i];\n  };\n  window.initSender = function initSender() {\n    var EventEmitter = window.require(\"ace/lib/event_emitter\").EventEmitter;\n    var oop = window.require(\"ace/lib/oop\");\n    var Sender = function Sender() {};\n    (function () {\n      oop.implement(this, EventEmitter);\n      this.callback = function (data, callbackId) {\n        postMessage({\n          type: \"call\",\n          id: callbackId,\n          data: data\n        });\n      };\n      this.emit = function (name, data) {\n        postMessage({\n          type: \"event\",\n          name: name,\n          data: data\n        });\n      };\n    }).call(Sender.prototype);\n    return new Sender();\n  };\n  var main = window.main = null;\n  var sender = window.sender = null;\n  window.onmessage = function (e) {\n    var msg = e.data;\n    if (msg.event && sender) {\n      sender._signal(msg.event, msg.data);\n    } else if (msg.command) {\n      if (main[msg.command]) main[msg.command].apply(main, msg.args);else if (window[msg.command]) window[msg.command].apply(window, msg.args);else throw new Error(\"Unknown command:\" + msg.command);\n    } else if (msg.init) {\n      window.initBaseUrls(msg.tlns);\n      sender = window.sender = window.initSender();\n      var clazz = this.require(msg.module)[msg.classname];\n      main = window.main = new clazz(sender);\n    }\n  };\n}(this);\nace.define(\"ace/lib/oop\", [], function (require, exports, module) {\n  \"use strict\";\n\n  exports.inherits = function (ctor, superCtor) {\n    ctor.super_ = superCtor;\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n  exports.mixin = function (obj, mixin) {\n    for (var key in mixin) {\n      obj[key] = mixin[key];\n    }\n    return obj;\n  };\n  exports.implement = function (proto, mixin) {\n    exports.mixin(proto, mixin);\n  };\n});\nace.define(\"ace/lib/lang\", [], function (require, exports, module) {\n  \"use strict\";\n\n  exports.last = function (a) {\n    return a[a.length - 1];\n  };\n  exports.stringReverse = function (string) {\n    return string.split(\"\").reverse().join(\"\");\n  };\n  exports.stringRepeat = function (string, count) {\n    var result = '';\n    while (count > 0) {\n      if (count & 1) result += string;\n      if (count >>= 1) string += string;\n    }\n    return result;\n  };\n  var trimBeginRegexp = /^\\s\\s*/;\n  var trimEndRegexp = /\\s\\s*$/;\n  exports.stringTrimLeft = function (string) {\n    return string.replace(trimBeginRegexp, '');\n  };\n  exports.stringTrimRight = function (string) {\n    return string.replace(trimEndRegexp, '');\n  };\n  exports.copyObject = function (obj) {\n    var copy = {};\n    for (var key in obj) {\n      copy[key] = obj[key];\n    }\n    return copy;\n  };\n  exports.copyArray = function (array) {\n    var copy = [];\n    for (var i = 0, l = array.length; i < l; i++) {\n      if (array[i] && typeof array[i] == \"object\") copy[i] = this.copyObject(array[i]);else copy[i] = array[i];\n    }\n    return copy;\n  };\n  exports.deepCopy = function deepCopy(obj) {\n    if (typeof obj !== \"object\" || !obj) return obj;\n    var copy;\n    if (Array.isArray(obj)) {\n      copy = [];\n      for (var key = 0; key < obj.length; key++) {\n        copy[key] = deepCopy(obj[key]);\n      }\n      return copy;\n    }\n    if (Object.prototype.toString.call(obj) !== \"[object Object]\") return obj;\n    copy = {};\n    for (var key in obj) copy[key] = deepCopy(obj[key]);\n    return copy;\n  };\n  exports.arrayToMap = function (arr) {\n    var map = {};\n    for (var i = 0; i < arr.length; i++) {\n      map[arr[i]] = 1;\n    }\n    return map;\n  };\n  exports.createMap = function (props) {\n    var map = Object.create(null);\n    for (var i in props) {\n      map[i] = props[i];\n    }\n    return map;\n  };\n  exports.arrayRemove = function (array, value) {\n    for (var i = 0; i <= array.length; i++) {\n      if (value === array[i]) {\n        array.splice(i, 1);\n      }\n    }\n  };\n  exports.escapeRegExp = function (str) {\n    return str.replace(/([.*+?^${}()|[\\]\\/\\\\])/g, '\\\\$1');\n  };\n  exports.escapeHTML = function (str) {\n    return (\"\" + str).replace(/&/g, \"&#38;\").replace(/\"/g, \"&#34;\").replace(/'/g, \"&#39;\").replace(/</g, \"&#60;\");\n  };\n  exports.getMatchOffsets = function (string, regExp) {\n    var matches = [];\n    string.replace(regExp, function (str) {\n      matches.push({\n        offset: arguments[arguments.length - 2],\n        length: str.length\n      });\n    });\n    return matches;\n  };\n  exports.deferredCall = function (fcn) {\n    var timer = null;\n    var callback = function callback() {\n      timer = null;\n      fcn();\n    };\n    var deferred = function deferred(timeout) {\n      deferred.cancel();\n      timer = setTimeout(callback, timeout || 0);\n      return deferred;\n    };\n    deferred.schedule = deferred;\n    deferred.call = function () {\n      this.cancel();\n      fcn();\n      return deferred;\n    };\n    deferred.cancel = function () {\n      clearTimeout(timer);\n      timer = null;\n      return deferred;\n    };\n    deferred.isPending = function () {\n      return timer;\n    };\n    return deferred;\n  };\n  exports.delayedCall = function (fcn, defaultTimeout) {\n    var timer = null;\n    var callback = function callback() {\n      timer = null;\n      fcn();\n    };\n    var _self = function _self(timeout) {\n      if (timer == null) timer = setTimeout(callback, timeout || defaultTimeout);\n    };\n    _self.delay = function (timeout) {\n      timer && clearTimeout(timer);\n      timer = setTimeout(callback, timeout || defaultTimeout);\n    };\n    _self.schedule = _self;\n    _self.call = function () {\n      this.cancel();\n      fcn();\n    };\n    _self.cancel = function () {\n      timer && clearTimeout(timer);\n      timer = null;\n    };\n    _self.isPending = function () {\n      return timer;\n    };\n    return _self;\n  };\n});\nace.define(\"ace/apply_delta\", [], function (require, exports, module) {\n  \"use strict\";\n\n  function throwDeltaError(delta, errorText) {\n    console.log(\"Invalid Delta:\", delta);\n    throw \"Invalid Delta: \" + errorText;\n  }\n  function positionInDocument(docLines, position) {\n    return position.row >= 0 && position.row < docLines.length && position.column >= 0 && position.column <= docLines[position.row].length;\n  }\n  function validateDelta(docLines, delta) {\n    if (delta.action != \"insert\" && delta.action != \"remove\") throwDeltaError(delta, \"delta.action must be 'insert' or 'remove'\");\n    if (!(delta.lines instanceof Array)) throwDeltaError(delta, \"delta.lines must be an Array\");\n    if (!delta.start || !delta.end) throwDeltaError(delta, \"delta.start/end must be an present\");\n    var start = delta.start;\n    if (!positionInDocument(docLines, delta.start)) throwDeltaError(delta, \"delta.start must be contained in document\");\n    var end = delta.end;\n    if (delta.action == \"remove\" && !positionInDocument(docLines, end)) throwDeltaError(delta, \"delta.end must contained in document for 'remove' actions\");\n    var numRangeRows = end.row - start.row;\n    var numRangeLastLineChars = end.column - (numRangeRows == 0 ? start.column : 0);\n    if (numRangeRows != delta.lines.length - 1 || delta.lines[numRangeRows].length != numRangeLastLineChars) throwDeltaError(delta, \"delta.range must match delta lines\");\n  }\n  exports.applyDelta = function (docLines, delta, doNotValidate) {\n    var row = delta.start.row;\n    var startColumn = delta.start.column;\n    var line = docLines[row] || \"\";\n    switch (delta.action) {\n      case \"insert\":\n        var lines = delta.lines;\n        if (lines.length === 1) {\n          docLines[row] = line.substring(0, startColumn) + delta.lines[0] + line.substring(startColumn);\n        } else {\n          var args = [row, 1].concat(delta.lines);\n          docLines.splice.apply(docLines, args);\n          docLines[row] = line.substring(0, startColumn) + docLines[row];\n          docLines[row + delta.lines.length - 1] += line.substring(startColumn);\n        }\n        break;\n      case \"remove\":\n        var endColumn = delta.end.column;\n        var endRow = delta.end.row;\n        if (row === endRow) {\n          docLines[row] = line.substring(0, startColumn) + line.substring(endColumn);\n        } else {\n          docLines.splice(row, endRow - row + 1, line.substring(0, startColumn) + docLines[endRow].substring(endColumn));\n        }\n        break;\n    }\n  };\n});\nace.define(\"ace/lib/event_emitter\", [], function (require, exports, module) {\n  \"use strict\";\n\n  var EventEmitter = {};\n  var stopPropagation = function stopPropagation() {\n    this.propagationStopped = true;\n  };\n  var preventDefault = function preventDefault() {\n    this.defaultPrevented = true;\n  };\n  EventEmitter._emit = EventEmitter._dispatchEvent = function (eventName, e) {\n    this._eventRegistry || (this._eventRegistry = {});\n    this._defaultHandlers || (this._defaultHandlers = {});\n    var listeners = this._eventRegistry[eventName] || [];\n    var defaultHandler = this._defaultHandlers[eventName];\n    if (!listeners.length && !defaultHandler) return;\n    if (typeof e != \"object\" || !e) e = {};\n    if (!e.type) e.type = eventName;\n    if (!e.stopPropagation) e.stopPropagation = stopPropagation;\n    if (!e.preventDefault) e.preventDefault = preventDefault;\n    listeners = listeners.slice();\n    for (var i = 0; i < listeners.length; i++) {\n      listeners[i](e, this);\n      if (e.propagationStopped) break;\n    }\n    if (defaultHandler && !e.defaultPrevented) return defaultHandler(e, this);\n  };\n  EventEmitter._signal = function (eventName, e) {\n    var listeners = (this._eventRegistry || {})[eventName];\n    if (!listeners) return;\n    listeners = listeners.slice();\n    for (var i = 0; i < listeners.length; i++) listeners[i](e, this);\n  };\n  EventEmitter.once = function (eventName, callback) {\n    var _self = this;\n    this.on(eventName, function newCallback() {\n      _self.off(eventName, newCallback);\n      callback.apply(null, arguments);\n    });\n    if (!callback) {\n      return new Promise(function (resolve) {\n        callback = resolve;\n      });\n    }\n  };\n  EventEmitter.setDefaultHandler = function (eventName, callback) {\n    var handlers = this._defaultHandlers;\n    if (!handlers) handlers = this._defaultHandlers = {\n      _disabled_: {}\n    };\n    if (handlers[eventName]) {\n      var old = handlers[eventName];\n      var disabled = handlers._disabled_[eventName];\n      if (!disabled) handlers._disabled_[eventName] = disabled = [];\n      disabled.push(old);\n      var i = disabled.indexOf(callback);\n      if (i != -1) disabled.splice(i, 1);\n    }\n    handlers[eventName] = callback;\n  };\n  EventEmitter.removeDefaultHandler = function (eventName, callback) {\n    var handlers = this._defaultHandlers;\n    if (!handlers) return;\n    var disabled = handlers._disabled_[eventName];\n    if (handlers[eventName] == callback) {\n      if (disabled) this.setDefaultHandler(eventName, disabled.pop());\n    } else if (disabled) {\n      var i = disabled.indexOf(callback);\n      if (i != -1) disabled.splice(i, 1);\n    }\n  };\n  EventEmitter.on = EventEmitter.addEventListener = function (eventName, callback, capturing) {\n    this._eventRegistry = this._eventRegistry || {};\n    var listeners = this._eventRegistry[eventName];\n    if (!listeners) listeners = this._eventRegistry[eventName] = [];\n    if (listeners.indexOf(callback) == -1) listeners[capturing ? \"unshift\" : \"push\"](callback);\n    return callback;\n  };\n  EventEmitter.off = EventEmitter.removeListener = EventEmitter.removeEventListener = function (eventName, callback) {\n    this._eventRegistry = this._eventRegistry || {};\n    var listeners = this._eventRegistry[eventName];\n    if (!listeners) return;\n    var index = listeners.indexOf(callback);\n    if (index !== -1) listeners.splice(index, 1);\n  };\n  EventEmitter.removeAllListeners = function (eventName) {\n    if (!eventName) this._eventRegistry = this._defaultHandlers = undefined;\n    if (this._eventRegistry) this._eventRegistry[eventName] = undefined;\n    if (this._defaultHandlers) this._defaultHandlers[eventName] = undefined;\n  };\n  exports.EventEmitter = EventEmitter;\n});\nace.define(\"ace/range\", [], function (require, exports, module) {\n  \"use strict\";\n\n  var comparePoints = function comparePoints(p1, p2) {\n    return p1.row - p2.row || p1.column - p2.column;\n  };\n  var Range = function Range(startRow, startColumn, endRow, endColumn) {\n    this.start = {\n      row: startRow,\n      column: startColumn\n    };\n    this.end = {\n      row: endRow,\n      column: endColumn\n    };\n  };\n  (function () {\n    this.isEqual = function (range) {\n      return this.start.row === range.start.row && this.end.row === range.end.row && this.start.column === range.start.column && this.end.column === range.end.column;\n    };\n    this.toString = function () {\n      return \"Range: [\" + this.start.row + \"/\" + this.start.column + \"] -> [\" + this.end.row + \"/\" + this.end.column + \"]\";\n    };\n    this.contains = function (row, column) {\n      return this.compare(row, column) == 0;\n    };\n    this.compareRange = function (range) {\n      var cmp,\n        end = range.end,\n        start = range.start;\n      cmp = this.compare(end.row, end.column);\n      if (cmp == 1) {\n        cmp = this.compare(start.row, start.column);\n        if (cmp == 1) {\n          return 2;\n        } else if (cmp == 0) {\n          return 1;\n        } else {\n          return 0;\n        }\n      } else if (cmp == -1) {\n        return -2;\n      } else {\n        cmp = this.compare(start.row, start.column);\n        if (cmp == -1) {\n          return -1;\n        } else if (cmp == 1) {\n          return 42;\n        } else {\n          return 0;\n        }\n      }\n    };\n    this.comparePoint = function (p) {\n      return this.compare(p.row, p.column);\n    };\n    this.containsRange = function (range) {\n      return this.comparePoint(range.start) == 0 && this.comparePoint(range.end) == 0;\n    };\n    this.intersects = function (range) {\n      var cmp = this.compareRange(range);\n      return cmp == -1 || cmp == 0 || cmp == 1;\n    };\n    this.isEnd = function (row, column) {\n      return this.end.row == row && this.end.column == column;\n    };\n    this.isStart = function (row, column) {\n      return this.start.row == row && this.start.column == column;\n    };\n    this.setStart = function (row, column) {\n      if (typeof row == \"object\") {\n        this.start.column = row.column;\n        this.start.row = row.row;\n      } else {\n        this.start.row = row;\n        this.start.column = column;\n      }\n    };\n    this.setEnd = function (row, column) {\n      if (typeof row == \"object\") {\n        this.end.column = row.column;\n        this.end.row = row.row;\n      } else {\n        this.end.row = row;\n        this.end.column = column;\n      }\n    };\n    this.inside = function (row, column) {\n      if (this.compare(row, column) == 0) {\n        if (this.isEnd(row, column) || this.isStart(row, column)) {\n          return false;\n        } else {\n          return true;\n        }\n      }\n      return false;\n    };\n    this.insideStart = function (row, column) {\n      if (this.compare(row, column) == 0) {\n        if (this.isEnd(row, column)) {\n          return false;\n        } else {\n          return true;\n        }\n      }\n      return false;\n    };\n    this.insideEnd = function (row, column) {\n      if (this.compare(row, column) == 0) {\n        if (this.isStart(row, column)) {\n          return false;\n        } else {\n          return true;\n        }\n      }\n      return false;\n    };\n    this.compare = function (row, column) {\n      if (!this.isMultiLine()) {\n        if (row === this.start.row) {\n          return column < this.start.column ? -1 : column > this.end.column ? 1 : 0;\n        }\n      }\n      if (row < this.start.row) return -1;\n      if (row > this.end.row) return 1;\n      if (this.start.row === row) return column >= this.start.column ? 0 : -1;\n      if (this.end.row === row) return column <= this.end.column ? 0 : 1;\n      return 0;\n    };\n    this.compareStart = function (row, column) {\n      if (this.start.row == row && this.start.column == column) {\n        return -1;\n      } else {\n        return this.compare(row, column);\n      }\n    };\n    this.compareEnd = function (row, column) {\n      if (this.end.row == row && this.end.column == column) {\n        return 1;\n      } else {\n        return this.compare(row, column);\n      }\n    };\n    this.compareInside = function (row, column) {\n      if (this.end.row == row && this.end.column == column) {\n        return 1;\n      } else if (this.start.row == row && this.start.column == column) {\n        return -1;\n      } else {\n        return this.compare(row, column);\n      }\n    };\n    this.clipRows = function (firstRow, lastRow) {\n      if (this.end.row > lastRow) var end = {\n        row: lastRow + 1,\n        column: 0\n      };else if (this.end.row < firstRow) var end = {\n        row: firstRow,\n        column: 0\n      };\n      if (this.start.row > lastRow) var start = {\n        row: lastRow + 1,\n        column: 0\n      };else if (this.start.row < firstRow) var start = {\n        row: firstRow,\n        column: 0\n      };\n      return Range.fromPoints(start || this.start, end || this.end);\n    };\n    this.extend = function (row, column) {\n      var cmp = this.compare(row, column);\n      if (cmp == 0) return this;else if (cmp == -1) var start = {\n        row: row,\n        column: column\n      };else var end = {\n        row: row,\n        column: column\n      };\n      return Range.fromPoints(start || this.start, end || this.end);\n    };\n    this.isEmpty = function () {\n      return this.start.row === this.end.row && this.start.column === this.end.column;\n    };\n    this.isMultiLine = function () {\n      return this.start.row !== this.end.row;\n    };\n    this.clone = function () {\n      return Range.fromPoints(this.start, this.end);\n    };\n    this.collapseRows = function () {\n      if (this.end.column == 0) return new Range(this.start.row, 0, Math.max(this.start.row, this.end.row - 1), 0);else return new Range(this.start.row, 0, this.end.row, 0);\n    };\n    this.toScreenRange = function (session) {\n      var screenPosStart = session.documentToScreenPosition(this.start);\n      var screenPosEnd = session.documentToScreenPosition(this.end);\n      return new Range(screenPosStart.row, screenPosStart.column, screenPosEnd.row, screenPosEnd.column);\n    };\n    this.moveBy = function (row, column) {\n      this.start.row += row;\n      this.start.column += column;\n      this.end.row += row;\n      this.end.column += column;\n    };\n  }).call(Range.prototype);\n  Range.fromPoints = function (start, end) {\n    return new Range(start.row, start.column, end.row, end.column);\n  };\n  Range.comparePoints = comparePoints;\n  Range.comparePoints = function (p1, p2) {\n    return p1.row - p2.row || p1.column - p2.column;\n  };\n  exports.Range = Range;\n});\nace.define(\"ace/anchor\", [], function (require, exports, module) {\n  \"use strict\";\n\n  var oop = require(\"./lib/oop\");\n  var EventEmitter = require(\"./lib/event_emitter\").EventEmitter;\n  var Anchor = exports.Anchor = function (doc, row, column) {\n    this.$onChange = this.onChange.bind(this);\n    this.attach(doc);\n    if (typeof column == \"undefined\") this.setPosition(row.row, row.column);else this.setPosition(row, column);\n  };\n  (function () {\n    oop.implement(this, EventEmitter);\n    this.getPosition = function () {\n      return this.$clipPositionToDocument(this.row, this.column);\n    };\n    this.getDocument = function () {\n      return this.document;\n    };\n    this.$insertRight = false;\n    this.onChange = function (delta) {\n      if (delta.start.row == delta.end.row && delta.start.row != this.row) return;\n      if (delta.start.row > this.row) return;\n      var point = $getTransformedPoint(delta, {\n        row: this.row,\n        column: this.column\n      }, this.$insertRight);\n      this.setPosition(point.row, point.column, true);\n    };\n    function $pointsInOrder(point1, point2, equalPointsInOrder) {\n      var bColIsAfter = equalPointsInOrder ? point1.column <= point2.column : point1.column < point2.column;\n      return point1.row < point2.row || point1.row == point2.row && bColIsAfter;\n    }\n    function $getTransformedPoint(delta, point, moveIfEqual) {\n      var deltaIsInsert = delta.action == \"insert\";\n      var deltaRowShift = (deltaIsInsert ? 1 : -1) * (delta.end.row - delta.start.row);\n      var deltaColShift = (deltaIsInsert ? 1 : -1) * (delta.end.column - delta.start.column);\n      var deltaStart = delta.start;\n      var deltaEnd = deltaIsInsert ? deltaStart : delta.end; // Collapse insert range.\n      if ($pointsInOrder(point, deltaStart, moveIfEqual)) {\n        return {\n          row: point.row,\n          column: point.column\n        };\n      }\n      if ($pointsInOrder(deltaEnd, point, !moveIfEqual)) {\n        return {\n          row: point.row + deltaRowShift,\n          column: point.column + (point.row == deltaEnd.row ? deltaColShift : 0)\n        };\n      }\n      return {\n        row: deltaStart.row,\n        column: deltaStart.column\n      };\n    }\n    this.setPosition = function (row, column, noClip) {\n      var pos;\n      if (noClip) {\n        pos = {\n          row: row,\n          column: column\n        };\n      } else {\n        pos = this.$clipPositionToDocument(row, column);\n      }\n      if (this.row == pos.row && this.column == pos.column) return;\n      var old = {\n        row: this.row,\n        column: this.column\n      };\n      this.row = pos.row;\n      this.column = pos.column;\n      this._signal(\"change\", {\n        old: old,\n        value: pos\n      });\n    };\n    this.detach = function () {\n      this.document.off(\"change\", this.$onChange);\n    };\n    this.attach = function (doc) {\n      this.document = doc || this.document;\n      this.document.on(\"change\", this.$onChange);\n    };\n    this.$clipPositionToDocument = function (row, column) {\n      var pos = {};\n      if (row >= this.document.getLength()) {\n        pos.row = Math.max(0, this.document.getLength() - 1);\n        pos.column = this.document.getLine(pos.row).length;\n      } else if (row < 0) {\n        pos.row = 0;\n        pos.column = 0;\n      } else {\n        pos.row = row;\n        pos.column = Math.min(this.document.getLine(pos.row).length, Math.max(0, column));\n      }\n      if (column < 0) pos.column = 0;\n      return pos;\n    };\n  }).call(Anchor.prototype);\n});\nace.define(\"ace/document\", [], function (require, exports, module) {\n  \"use strict\";\n\n  var oop = require(\"./lib/oop\");\n  var applyDelta = require(\"./apply_delta\").applyDelta;\n  var EventEmitter = require(\"./lib/event_emitter\").EventEmitter;\n  var Range = require(\"./range\").Range;\n  var Anchor = require(\"./anchor\").Anchor;\n  var Document = function Document(textOrLines) {\n    this.$lines = [\"\"];\n    if (textOrLines.length === 0) {\n      this.$lines = [\"\"];\n    } else if (Array.isArray(textOrLines)) {\n      this.insertMergedLines({\n        row: 0,\n        column: 0\n      }, textOrLines);\n    } else {\n      this.insert({\n        row: 0,\n        column: 0\n      }, textOrLines);\n    }\n  };\n  (function () {\n    oop.implement(this, EventEmitter);\n    this.setValue = function (text) {\n      var len = this.getLength() - 1;\n      this.remove(new Range(0, 0, len, this.getLine(len).length));\n      this.insert({\n        row: 0,\n        column: 0\n      }, text || \"\");\n    };\n    this.getValue = function () {\n      return this.getAllLines().join(this.getNewLineCharacter());\n    };\n    this.createAnchor = function (row, column) {\n      return new Anchor(this, row, column);\n    };\n    if (\"aaa\".split(/a/).length === 0) {\n      this.$split = function (text) {\n        return text.replace(/\\r\\n|\\r/g, \"\\n\").split(\"\\n\");\n      };\n    } else {\n      this.$split = function (text) {\n        return text.split(/\\r\\n|\\r|\\n/);\n      };\n    }\n    this.$detectNewLine = function (text) {\n      var match = text.match(/^.*?(\\r\\n|\\r|\\n)/m);\n      this.$autoNewLine = match ? match[1] : \"\\n\";\n      this._signal(\"changeNewLineMode\");\n    };\n    this.getNewLineCharacter = function () {\n      switch (this.$newLineMode) {\n        case \"windows\":\n          return \"\\r\\n\";\n        case \"unix\":\n          return \"\\n\";\n        default:\n          return this.$autoNewLine || \"\\n\";\n      }\n    };\n    this.$autoNewLine = \"\";\n    this.$newLineMode = \"auto\";\n    this.setNewLineMode = function (newLineMode) {\n      if (this.$newLineMode === newLineMode) return;\n      this.$newLineMode = newLineMode;\n      this._signal(\"changeNewLineMode\");\n    };\n    this.getNewLineMode = function () {\n      return this.$newLineMode;\n    };\n    this.isNewLine = function (text) {\n      return text == \"\\r\\n\" || text == \"\\r\" || text == \"\\n\";\n    };\n    this.getLine = function (row) {\n      return this.$lines[row] || \"\";\n    };\n    this.getLines = function (firstRow, lastRow) {\n      return this.$lines.slice(firstRow, lastRow + 1);\n    };\n    this.getAllLines = function () {\n      return this.getLines(0, this.getLength());\n    };\n    this.getLength = function () {\n      return this.$lines.length;\n    };\n    this.getTextRange = function (range) {\n      return this.getLinesForRange(range).join(this.getNewLineCharacter());\n    };\n    this.getLinesForRange = function (range) {\n      var lines;\n      if (range.start.row === range.end.row) {\n        lines = [this.getLine(range.start.row).substring(range.start.column, range.end.column)];\n      } else {\n        lines = this.getLines(range.start.row, range.end.row);\n        lines[0] = (lines[0] || \"\").substring(range.start.column);\n        var l = lines.length - 1;\n        if (range.end.row - range.start.row == l) lines[l] = lines[l].substring(0, range.end.column);\n      }\n      return lines;\n    };\n    this.insertLines = function (row, lines) {\n      console.warn(\"Use of document.insertLines is deprecated. Use the insertFullLines method instead.\");\n      return this.insertFullLines(row, lines);\n    };\n    this.removeLines = function (firstRow, lastRow) {\n      console.warn(\"Use of document.removeLines is deprecated. Use the removeFullLines method instead.\");\n      return this.removeFullLines(firstRow, lastRow);\n    };\n    this.insertNewLine = function (position) {\n      console.warn(\"Use of document.insertNewLine is deprecated. Use insertMergedLines(position, ['', '']) instead.\");\n      return this.insertMergedLines(position, [\"\", \"\"]);\n    };\n    this.insert = function (position, text) {\n      if (this.getLength() <= 1) this.$detectNewLine(text);\n      return this.insertMergedLines(position, this.$split(text));\n    };\n    this.insertInLine = function (position, text) {\n      var start = this.clippedPos(position.row, position.column);\n      var end = this.pos(position.row, position.column + text.length);\n      this.applyDelta({\n        start: start,\n        end: end,\n        action: \"insert\",\n        lines: [text]\n      }, true);\n      return this.clonePos(end);\n    };\n    this.clippedPos = function (row, column) {\n      var length = this.getLength();\n      if (row === undefined) {\n        row = length;\n      } else if (row < 0) {\n        row = 0;\n      } else if (row >= length) {\n        row = length - 1;\n        column = undefined;\n      }\n      var line = this.getLine(row);\n      if (column == undefined) column = line.length;\n      column = Math.min(Math.max(column, 0), line.length);\n      return {\n        row: row,\n        column: column\n      };\n    };\n    this.clonePos = function (pos) {\n      return {\n        row: pos.row,\n        column: pos.column\n      };\n    };\n    this.pos = function (row, column) {\n      return {\n        row: row,\n        column: column\n      };\n    };\n    this.$clipPosition = function (position) {\n      var length = this.getLength();\n      if (position.row >= length) {\n        position.row = Math.max(0, length - 1);\n        position.column = this.getLine(length - 1).length;\n      } else {\n        position.row = Math.max(0, position.row);\n        position.column = Math.min(Math.max(position.column, 0), this.getLine(position.row).length);\n      }\n      return position;\n    };\n    this.insertFullLines = function (row, lines) {\n      row = Math.min(Math.max(row, 0), this.getLength());\n      var column = 0;\n      if (row < this.getLength()) {\n        lines = lines.concat([\"\"]);\n        column = 0;\n      } else {\n        lines = [\"\"].concat(lines);\n        row--;\n        column = this.$lines[row].length;\n      }\n      this.insertMergedLines({\n        row: row,\n        column: column\n      }, lines);\n    };\n    this.insertMergedLines = function (position, lines) {\n      var start = this.clippedPos(position.row, position.column);\n      var end = {\n        row: start.row + lines.length - 1,\n        column: (lines.length == 1 ? start.column : 0) + lines[lines.length - 1].length\n      };\n      this.applyDelta({\n        start: start,\n        end: end,\n        action: \"insert\",\n        lines: lines\n      });\n      return this.clonePos(end);\n    };\n    this.remove = function (range) {\n      var start = this.clippedPos(range.start.row, range.start.column);\n      var end = this.clippedPos(range.end.row, range.end.column);\n      this.applyDelta({\n        start: start,\n        end: end,\n        action: \"remove\",\n        lines: this.getLinesForRange({\n          start: start,\n          end: end\n        })\n      });\n      return this.clonePos(start);\n    };\n    this.removeInLine = function (row, startColumn, endColumn) {\n      var start = this.clippedPos(row, startColumn);\n      var end = this.clippedPos(row, endColumn);\n      this.applyDelta({\n        start: start,\n        end: end,\n        action: \"remove\",\n        lines: this.getLinesForRange({\n          start: start,\n          end: end\n        })\n      }, true);\n      return this.clonePos(start);\n    };\n    this.removeFullLines = function (firstRow, lastRow) {\n      firstRow = Math.min(Math.max(0, firstRow), this.getLength() - 1);\n      lastRow = Math.min(Math.max(0, lastRow), this.getLength() - 1);\n      var deleteFirstNewLine = lastRow == this.getLength() - 1 && firstRow > 0;\n      var deleteLastNewLine = lastRow < this.getLength() - 1;\n      var startRow = deleteFirstNewLine ? firstRow - 1 : firstRow;\n      var startCol = deleteFirstNewLine ? this.getLine(startRow).length : 0;\n      var endRow = deleteLastNewLine ? lastRow + 1 : lastRow;\n      var endCol = deleteLastNewLine ? 0 : this.getLine(endRow).length;\n      var range = new Range(startRow, startCol, endRow, endCol);\n      var deletedLines = this.$lines.slice(firstRow, lastRow + 1);\n      this.applyDelta({\n        start: range.start,\n        end: range.end,\n        action: \"remove\",\n        lines: this.getLinesForRange(range)\n      });\n      return deletedLines;\n    };\n    this.removeNewLine = function (row) {\n      if (row < this.getLength() - 1 && row >= 0) {\n        this.applyDelta({\n          start: this.pos(row, this.getLine(row).length),\n          end: this.pos(row + 1, 0),\n          action: \"remove\",\n          lines: [\"\", \"\"]\n        });\n      }\n    };\n    this.replace = function (range, text) {\n      if (!(range instanceof Range)) range = Range.fromPoints(range.start, range.end);\n      if (text.length === 0 && range.isEmpty()) return range.start;\n      if (text == this.getTextRange(range)) return range.end;\n      this.remove(range);\n      var end;\n      if (text) {\n        end = this.insert(range.start, text);\n      } else {\n        end = range.start;\n      }\n      return end;\n    };\n    this.applyDeltas = function (deltas) {\n      for (var i = 0; i < deltas.length; i++) {\n        this.applyDelta(deltas[i]);\n      }\n    };\n    this.revertDeltas = function (deltas) {\n      for (var i = deltas.length - 1; i >= 0; i--) {\n        this.revertDelta(deltas[i]);\n      }\n    };\n    this.applyDelta = function (delta, doNotValidate) {\n      var isInsert = delta.action == \"insert\";\n      if (isInsert ? delta.lines.length <= 1 && !delta.lines[0] : !Range.comparePoints(delta.start, delta.end)) {\n        return;\n      }\n      if (isInsert && delta.lines.length > 20000) {\n        this.$splitAndapplyLargeDelta(delta, 20000);\n      } else {\n        applyDelta(this.$lines, delta, doNotValidate);\n        this._signal(\"change\", delta);\n      }\n    };\n    this.$safeApplyDelta = function (delta) {\n      var docLength = this.$lines.length;\n      if (delta.action == \"remove\" && delta.start.row < docLength && delta.end.row < docLength || delta.action == \"insert\" && delta.start.row <= docLength) {\n        this.applyDelta(delta);\n      }\n    };\n    this.$splitAndapplyLargeDelta = function (delta, MAX) {\n      var lines = delta.lines;\n      var l = lines.length - MAX + 1;\n      var row = delta.start.row;\n      var column = delta.start.column;\n      for (var from = 0, to = 0; from < l; from = to) {\n        to += MAX - 1;\n        var chunk = lines.slice(from, to);\n        chunk.push(\"\");\n        this.applyDelta({\n          start: this.pos(row + from, column),\n          end: this.pos(row + to, column = 0),\n          action: delta.action,\n          lines: chunk\n        }, true);\n      }\n      delta.lines = lines.slice(from);\n      delta.start.row = row + from;\n      delta.start.column = column;\n      this.applyDelta(delta, true);\n    };\n    this.revertDelta = function (delta) {\n      this.$safeApplyDelta({\n        start: this.clonePos(delta.start),\n        end: this.clonePos(delta.end),\n        action: delta.action == \"insert\" ? \"remove\" : \"insert\",\n        lines: delta.lines.slice()\n      });\n    };\n    this.indexToPosition = function (index, startRow) {\n      var lines = this.$lines || this.getAllLines();\n      var newlineLength = this.getNewLineCharacter().length;\n      for (var i = startRow || 0, l = lines.length; i < l; i++) {\n        index -= lines[i].length + newlineLength;\n        if (index < 0) return {\n          row: i,\n          column: index + lines[i].length + newlineLength\n        };\n      }\n      return {\n        row: l - 1,\n        column: index + lines[l - 1].length + newlineLength\n      };\n    };\n    this.positionToIndex = function (pos, startRow) {\n      var lines = this.$lines || this.getAllLines();\n      var newlineLength = this.getNewLineCharacter().length;\n      var index = 0;\n      var row = Math.min(pos.row, lines.length);\n      for (var i = startRow || 0; i < row; ++i) index += lines[i].length + newlineLength;\n      return index + pos.column;\n    };\n  }).call(Document.prototype);\n  exports.Document = Document;\n});\nace.define(\"ace/worker/mirror\", [], function (require, exports, module) {\n  \"use strict\";\n\n  var Document = require(\"../document\").Document;\n  var lang = require(\"../lib/lang\");\n  var Mirror = exports.Mirror = function (sender) {\n    this.sender = sender;\n    var doc = this.doc = new Document(\"\");\n    var deferredUpdate = this.deferredUpdate = lang.delayedCall(this.onUpdate.bind(this));\n    var _self = this;\n    sender.on(\"change\", function (e) {\n      var data = e.data;\n      if (data[0].start) {\n        doc.applyDeltas(data);\n      } else {\n        for (var i = 0; i < data.length; i += 2) {\n          var d, err;\n          if (Array.isArray(data[i + 1])) {\n            d = {\n              action: \"insert\",\n              start: data[i],\n              lines: data[i + 1]\n            };\n          } else {\n            d = {\n              action: \"remove\",\n              start: data[i],\n              end: data[i + 1]\n            };\n          }\n          if ((d.action == \"insert\" ? d.start : d.end).row >= doc.$lines.length) {\n            err = new Error(\"Invalid delta\");\n            err.data = {\n              path: _self.$path,\n              linesLength: doc.$lines.length,\n              start: d.start,\n              end: d.end\n            };\n            throw err;\n          }\n          doc.applyDelta(d, true);\n        }\n      }\n      if (_self.$timeout) return deferredUpdate.schedule(_self.$timeout);\n      _self.onUpdate();\n    });\n  };\n  (function () {\n    this.$timeout = 500;\n    this.setTimeout = function (timeout) {\n      this.$timeout = timeout;\n    };\n    this.setValue = function (value) {\n      this.doc.setValue(value);\n      this.deferredUpdate.schedule(this.$timeout);\n    };\n    this.getValue = function (callbackId) {\n      this.sender.callback(this.doc.getValue(), callbackId);\n    };\n    this.onUpdate = function () {};\n    this.isPending = function () {\n      return this.deferredUpdate.isPending();\n    };\n  }).call(Mirror.prototype);\n});\nace.define(\"ace/mode/xml/sax\", [], function (require, exports, module) {\n  var nameStartChar = /[A-Z_a-z\\xC0-\\xD6\\xD8-\\xF6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD]/; //\\u10000-\\uEFFFF\n  var nameChar = new RegExp(\"[\\\\-\\\\.0-9\" + nameStartChar.source.slice(1, -1) + \"\\xB7\\u0300-\\u036F\\\\ux203F-\\u2040]\");\n  var tagNamePattern = new RegExp('^' + nameStartChar.source + nameChar.source + '*(?:\\:' + nameStartChar.source + nameChar.source + '*)?$');\n  var S_TAG = 0; //tag name offerring\n  var S_ATTR = 1; //attr name offerring \n  var S_ATTR_S = 2; //attr name end and space offer\n  var S_EQ = 3; //=space?\n  var S_V = 4; //attr value(no quot value only)\n  var S_E = 5; //attr value end and no space(quot end)\n  var S_S = 6; //(attr value end || tag end ) && (space offer)\n  var S_C = 7; //closed el<el />\n\n  function XMLReader() {}\n  XMLReader.prototype = {\n    parse: function parse(source, defaultNSMap, entityMap) {\n      var domBuilder = this.domBuilder;\n      domBuilder.startDocument();\n      _copy(defaultNSMap, defaultNSMap = {});\n      _parse(source, defaultNSMap, entityMap, domBuilder, this.errorHandler);\n      domBuilder.endDocument();\n    }\n  };\n  function _parse(source, defaultNSMapCopy, entityMap, domBuilder, errorHandler) {\n    function fixedFromCharCode(code) {\n      if (code > 0xffff) {\n        code -= 0x10000;\n        var surrogate1 = 0xd800 + (code >> 10),\n          surrogate2 = 0xdc00 + (code & 0x3ff);\n        return String.fromCharCode(surrogate1, surrogate2);\n      } else {\n        return String.fromCharCode(code);\n      }\n    }\n    function entityReplacer(a) {\n      var k = a.slice(1, -1);\n      if (k in entityMap) {\n        return entityMap[k];\n      } else if (k.charAt(0) === '#') {\n        return fixedFromCharCode(parseInt(k.substr(1).replace('x', '0x')));\n      } else {\n        errorHandler.error('entity not found:' + a);\n        return a;\n      }\n    }\n    function appendText(end) {\n      //has some bugs\n      var xt = source.substring(start, end).replace(/&#?\\w+;/g, entityReplacer);\n      locator && position(start);\n      domBuilder.characters(xt, 0, end - start);\n      start = end;\n    }\n    function position(start, m) {\n      while (start >= endPos && (m = linePattern.exec(source))) {\n        startPos = m.index;\n        endPos = startPos + m[0].length;\n        locator.lineNumber++;\n      }\n      locator.columnNumber = start - startPos + 1;\n    }\n    var startPos = 0;\n    var endPos = 0;\n    var linePattern = /.+(?:\\r\\n?|\\n)|.*$/g;\n    var locator = domBuilder.locator;\n    var parseStack = [{\n      currentNSMap: defaultNSMapCopy\n    }];\n    var closeMap = {};\n    var start = 0;\n    while (true) {\n      var i = source.indexOf('<', start);\n      if (i < 0) {\n        if (!source.substr(start).match(/^\\s*$/)) {\n          var doc = domBuilder.document;\n          var text = doc.createTextNode(source.substr(start));\n          doc.appendChild(text);\n          domBuilder.currentElement = text;\n        }\n        return;\n      }\n      if (i > start) {\n        appendText(i);\n      }\n      switch (source.charAt(i + 1)) {\n        case '/':\n          var end = source.indexOf('>', i + 3);\n          var tagName = source.substring(i + 2, end);\n          var config;\n          if (parseStack.length > 1) {\n            config = parseStack.pop();\n          } else {\n            errorHandler.fatalError(\"end tag name not found for: \" + tagName);\n            break;\n          }\n          var localNSMap = config.localNSMap;\n          if (config.tagName != tagName) {\n            errorHandler.fatalError(\"end tag name: \" + tagName + \" does not match the current start tagName: \" + config.tagName);\n          }\n          domBuilder.endElement(config.uri, config.localName, tagName);\n          if (localNSMap) {\n            for (var prefix in localNSMap) {\n              domBuilder.endPrefixMapping(prefix);\n            }\n          }\n          end++;\n          break;\n        case '?':\n          // <?...?>\n          locator && position(i);\n          end = parseInstruction(source, i, domBuilder);\n          break;\n        case '!':\n          // <!doctype,<![CDATA,<!--\n          locator && position(i);\n          end = parseDCC(source, i, domBuilder, errorHandler);\n          break;\n        default:\n          try {\n            locator && position(i);\n            var el = new ElementAttributes();\n            var end = parseElementStartPart(source, i, el, entityReplacer, errorHandler);\n            var len = el.length;\n            if (len && locator) {\n              var backup = copyLocator(locator, {});\n              for (var i = 0; i < len; i++) {\n                var a = el[i];\n                position(a.offset);\n                a.offset = copyLocator(locator, {});\n              }\n              copyLocator(backup, locator);\n            }\n            if (!el.closed && fixSelfClosed(source, end, el.tagName, closeMap)) {\n              el.closed = true;\n              if (!entityMap.nbsp) {\n                errorHandler.warning('unclosed xml attribute');\n              }\n            }\n            appendElement(el, domBuilder, parseStack);\n            if (el.uri === 'http://www.w3.org/1999/xhtml' && !el.closed) {\n              end = parseHtmlSpecialContent(source, end, el.tagName, entityReplacer, domBuilder);\n            } else {\n              end++;\n            }\n          } catch (e) {\n            errorHandler.error('element parse error: ' + e);\n            end = -1;\n          }\n      }\n      if (end < 0) {\n        appendText(i + 1);\n      } else {\n        start = end;\n      }\n    }\n  }\n  function copyLocator(f, t) {\n    t.lineNumber = f.lineNumber;\n    t.columnNumber = f.columnNumber;\n    return t;\n  }\n  function parseElementStartPart(source, start, el, entityReplacer, errorHandler) {\n    var attrName;\n    var value;\n    var p = ++start;\n    var s = S_TAG; //status\n    while (true) {\n      var c = source.charAt(p);\n      switch (c) {\n        case '=':\n          if (s === S_ATTR) {\n            //attrName\n            attrName = source.slice(start, p);\n            s = S_EQ;\n          } else if (s === S_ATTR_S) {\n            s = S_EQ;\n          } else {\n            throw new Error('attribute equal must after attrName');\n          }\n          break;\n        case '\\'':\n        case '\"':\n          if (s === S_EQ) {\n            //equal\n            start = p + 1;\n            p = source.indexOf(c, start);\n            if (p > 0) {\n              value = source.slice(start, p).replace(/&#?\\w+;/g, entityReplacer);\n              el.add(attrName, value, start - 1);\n              s = S_E;\n            } else {\n              throw new Error('attribute value no end \\'' + c + '\\' match');\n            }\n          } else if (s == S_V) {\n            value = source.slice(start, p).replace(/&#?\\w+;/g, entityReplacer);\n            el.add(attrName, value, start);\n            errorHandler.warning('attribute \"' + attrName + '\" missed start quot(' + c + ')!!');\n            start = p + 1;\n            s = S_E;\n          } else {\n            throw new Error('attribute value must after \"=\"');\n          }\n          break;\n        case '/':\n          switch (s) {\n            case S_TAG:\n              el.setTagName(source.slice(start, p));\n            case S_E:\n            case S_S:\n            case S_C:\n              s = S_C;\n              el.closed = true;\n            case S_V:\n            case S_ATTR:\n            case S_ATTR_S:\n              break;\n            default:\n              throw new Error(\"attribute invalid close char('/')\");\n          }\n          break;\n        case '':\n          //end document\n          errorHandler.error('unexpected end of input');\n        case '>':\n          switch (s) {\n            case S_TAG:\n              el.setTagName(source.slice(start, p));\n            case S_E:\n            case S_S:\n            case S_C:\n              break;\n            //normal\n            case S_V: //Compatible state\n            case S_ATTR:\n              value = source.slice(start, p);\n              if (value.slice(-1) === '/') {\n                el.closed = true;\n                value = value.slice(0, -1);\n              }\n            case S_ATTR_S:\n              if (s === S_ATTR_S) {\n                value = attrName;\n              }\n              if (s == S_V) {\n                errorHandler.warning('attribute \"' + value + '\" missed quot(\")!!');\n                el.add(attrName, value.replace(/&#?\\w+;/g, entityReplacer), start);\n              } else {\n                errorHandler.warning('attribute \"' + value + '\" missed value!! \"' + value + '\" instead!!');\n                el.add(value, value, start);\n              }\n              break;\n            case S_EQ:\n              throw new Error('attribute value missed!!');\n          }\n          return p;\n        case \"\\x80\":\n          c = ' ';\n        default:\n          if (c <= ' ') {\n            //space\n            switch (s) {\n              case S_TAG:\n                el.setTagName(source.slice(start, p)); //tagName\n                s = S_S;\n                break;\n              case S_ATTR:\n                attrName = source.slice(start, p);\n                s = S_ATTR_S;\n                break;\n              case S_V:\n                var value = source.slice(start, p).replace(/&#?\\w+;/g, entityReplacer);\n                errorHandler.warning('attribute \"' + value + '\" missed quot(\")!!');\n                el.add(attrName, value, start);\n              case S_E:\n                s = S_S;\n                break;\n            }\n          } else {\n            //not space\n            switch (s) {\n              case S_ATTR_S:\n                errorHandler.warning('attribute \"' + attrName + '\" missed value!! \"' + attrName + '\" instead!!');\n                el.add(attrName, attrName, start);\n                start = p;\n                s = S_ATTR;\n                break;\n              case S_E:\n                errorHandler.warning('attribute space is required\"' + attrName + '\"!!');\n              case S_S:\n                s = S_ATTR;\n                start = p;\n                break;\n              case S_EQ:\n                s = S_V;\n                start = p;\n                break;\n              case S_C:\n                throw new Error(\"elements closed character '/' and '>' must be connected to\");\n            }\n          }\n      }\n      p++;\n    }\n  }\n  function appendElement(el, domBuilder, parseStack) {\n    var tagName = el.tagName;\n    var localNSMap = null;\n    var currentNSMap = parseStack[parseStack.length - 1].currentNSMap;\n    var i = el.length;\n    while (i--) {\n      var a = el[i];\n      var qName = a.qName;\n      var value = a.value;\n      var nsp = qName.indexOf(':');\n      if (nsp > 0) {\n        var prefix = a.prefix = qName.slice(0, nsp);\n        var localName = qName.slice(nsp + 1);\n        var nsPrefix = prefix === 'xmlns' && localName;\n      } else {\n        localName = qName;\n        prefix = null;\n        nsPrefix = qName === 'xmlns' && '';\n      }\n      a.localName = localName;\n      if (nsPrefix !== false) {\n        //hack!!\n        if (localNSMap == null) {\n          localNSMap = {};\n          _copy(currentNSMap, currentNSMap = {});\n        }\n        currentNSMap[nsPrefix] = localNSMap[nsPrefix] = value;\n        a.uri = 'http://www.w3.org/2000/xmlns/';\n        domBuilder.startPrefixMapping(nsPrefix, value);\n      }\n    }\n    var i = el.length;\n    while (i--) {\n      a = el[i];\n      var prefix = a.prefix;\n      if (prefix) {\n        //no prefix attribute has no namespace\n        if (prefix === 'xml') {\n          a.uri = 'http://www.w3.org/XML/1998/namespace';\n        }\n        if (prefix !== 'xmlns') {\n          a.uri = currentNSMap[prefix];\n        }\n      }\n    }\n    var nsp = tagName.indexOf(':');\n    if (nsp > 0) {\n      prefix = el.prefix = tagName.slice(0, nsp);\n      localName = el.localName = tagName.slice(nsp + 1);\n    } else {\n      prefix = null; //important!!\n      localName = el.localName = tagName;\n    }\n    var ns = el.uri = currentNSMap[prefix || ''];\n    domBuilder.startElement(ns, localName, tagName, el);\n    if (el.closed) {\n      domBuilder.endElement(ns, localName, tagName);\n      if (localNSMap) {\n        for (prefix in localNSMap) {\n          domBuilder.endPrefixMapping(prefix);\n        }\n      }\n    } else {\n      el.currentNSMap = currentNSMap;\n      el.localNSMap = localNSMap;\n      parseStack.push(el);\n    }\n  }\n  function parseHtmlSpecialContent(source, elStartEnd, tagName, entityReplacer, domBuilder) {\n    if (/^(?:script|textarea)$/i.test(tagName)) {\n      var elEndStart = source.indexOf('</' + tagName + '>', elStartEnd);\n      var text = source.substring(elStartEnd + 1, elEndStart);\n      if (/[&<]/.test(text)) {\n        if (/^script$/i.test(tagName)) {\n          domBuilder.characters(text, 0, text.length);\n          return elEndStart;\n        } //}else{//text area\n        text = text.replace(/&#?\\w+;/g, entityReplacer);\n        domBuilder.characters(text, 0, text.length);\n        return elEndStart;\n      }\n    }\n    return elStartEnd + 1;\n  }\n  function fixSelfClosed(source, elStartEnd, tagName, closeMap) {\n    var pos = closeMap[tagName];\n    if (pos == null) {\n      pos = closeMap[tagName] = source.lastIndexOf('</' + tagName + '>');\n    }\n    return pos < elStartEnd;\n  }\n  function _copy(source, target) {\n    for (var n in source) {\n      target[n] = source[n];\n    }\n  }\n  function parseDCC(source, start, domBuilder, errorHandler) {\n    //sure start with '<!'\n    var next = source.charAt(start + 2);\n    switch (next) {\n      case '-':\n        if (source.charAt(start + 3) === '-') {\n          var end = source.indexOf('-->', start + 4);\n          if (end > start) {\n            domBuilder.comment(source, start + 4, end - start - 4);\n            return end + 3;\n          } else {\n            errorHandler.error(\"Unclosed comment\");\n            return -1;\n          }\n        } else {\n          return -1;\n        }\n      default:\n        if (source.substr(start + 3, 6) == 'CDATA[') {\n          var end = source.indexOf(']]>', start + 9);\n          if (end > start) {\n            domBuilder.startCDATA();\n            domBuilder.characters(source, start + 9, end - start - 9);\n            domBuilder.endCDATA();\n            return end + 3;\n          } else {\n            errorHandler.error(\"Unclosed CDATA\");\n            return -1;\n          }\n        }\n        var matchs = split(source, start);\n        var len = matchs.length;\n        if (len > 1 && /!doctype/i.test(matchs[0][0])) {\n          var name = matchs[1][0];\n          var pubid = len > 3 && /^public$/i.test(matchs[2][0]) && matchs[3][0];\n          var sysid = len > 4 && matchs[4][0];\n          var lastMatch = matchs[len - 1];\n          domBuilder.startDTD(name, pubid && pubid.replace(/^(['\"])(.*?)\\1$/, '$2'), sysid && sysid.replace(/^(['\"])(.*?)\\1$/, '$2'));\n          domBuilder.endDTD();\n          return lastMatch.index + lastMatch[0].length;\n        }\n    }\n    return -1;\n  }\n  function parseInstruction(source, start, domBuilder) {\n    var end = source.indexOf('?>', start);\n    if (end) {\n      var match = source.substring(start, end).match(/^<\\?(\\S*)\\s*([\\s\\S]*?)\\s*$/);\n      if (match) {\n        var len = match[0].length;\n        domBuilder.processingInstruction(match[1], match[2]);\n        return end + 2;\n      } else {\n        //error\n        return -1;\n      }\n    }\n    return -1;\n  }\n  function ElementAttributes(source) {}\n  ElementAttributes.prototype = {\n    setTagName: function setTagName(tagName) {\n      if (!tagNamePattern.test(tagName)) {\n        throw new Error('invalid tagName:' + tagName);\n      }\n      this.tagName = tagName;\n    },\n    add: function add(qName, value, offset) {\n      if (!tagNamePattern.test(qName)) {\n        throw new Error('invalid attribute:' + qName);\n      }\n      this[this.length++] = {\n        qName: qName,\n        value: value,\n        offset: offset\n      };\n    },\n    length: 0,\n    getLocalName: function getLocalName(i) {\n      return this[i].localName;\n    },\n    getOffset: function getOffset(i) {\n      return this[i].offset;\n    },\n    getQName: function getQName(i) {\n      return this[i].qName;\n    },\n    getURI: function getURI(i) {\n      return this[i].uri;\n    },\n    getValue: function getValue(i) {\n      return this[i].value;\n    }\n  };\n  function _set_proto_(thiz, parent) {\n    thiz.__proto__ = parent;\n    return thiz;\n  }\n  if (!(_set_proto_({}, _set_proto_.prototype) instanceof _set_proto_)) {\n    _set_proto_ = function _set_proto_(thiz, parent) {\n      function p() {}\n      ;\n      p.prototype = parent;\n      p = new p();\n      for (parent in thiz) {\n        p[parent] = thiz[parent];\n      }\n      return p;\n    };\n  }\n  function split(source, start) {\n    var match;\n    var buf = [];\n    var reg = /'[^']+'|\"[^\"]+\"|[^\\s<>\\/=]+=?|(\\/?\\s*>|<)/g;\n    reg.lastIndex = start;\n    reg.exec(source); //skip <\n    while (match = reg.exec(source)) {\n      buf.push(match);\n      if (match[1]) return buf;\n    }\n  }\n  return XMLReader;\n});\nace.define(\"ace/mode/xml/dom\", [], function (require, exports, module) {\n  function copy(src, dest) {\n    for (var p in src) {\n      dest[p] = src[p];\n    }\n  }\n  function _extends(Class, Super) {\n    var t = function t() {};\n    var pt = Class.prototype;\n    if (Object.create) {\n      var ppt = Object.create(Super.prototype);\n      pt.__proto__ = ppt;\n    }\n    if (!(pt instanceof Super)) {\n      t.prototype = Super.prototype;\n      t = new t();\n      copy(pt, t);\n      Class.prototype = pt = t;\n    }\n    if (pt.constructor != Class) {\n      if (typeof Class != 'function') {\n        console.error(\"unknown Class:\" + Class);\n      }\n      pt.constructor = Class;\n    }\n  }\n  var htmlns = 'http://www.w3.org/1999/xhtml';\n  var NodeType = {};\n  var ELEMENT_NODE = NodeType.ELEMENT_NODE = 1;\n  var ATTRIBUTE_NODE = NodeType.ATTRIBUTE_NODE = 2;\n  var TEXT_NODE = NodeType.TEXT_NODE = 3;\n  var CDATA_SECTION_NODE = NodeType.CDATA_SECTION_NODE = 4;\n  var ENTITY_REFERENCE_NODE = NodeType.ENTITY_REFERENCE_NODE = 5;\n  var ENTITY_NODE = NodeType.ENTITY_NODE = 6;\n  var PROCESSING_INSTRUCTION_NODE = NodeType.PROCESSING_INSTRUCTION_NODE = 7;\n  var COMMENT_NODE = NodeType.COMMENT_NODE = 8;\n  var DOCUMENT_NODE = NodeType.DOCUMENT_NODE = 9;\n  var DOCUMENT_TYPE_NODE = NodeType.DOCUMENT_TYPE_NODE = 10;\n  var DOCUMENT_FRAGMENT_NODE = NodeType.DOCUMENT_FRAGMENT_NODE = 11;\n  var NOTATION_NODE = NodeType.NOTATION_NODE = 12;\n  var ExceptionCode = {};\n  var ExceptionMessage = {};\n  var INDEX_SIZE_ERR = ExceptionCode.INDEX_SIZE_ERR = (ExceptionMessage[1] = \"Index size error\", 1);\n  var DOMSTRING_SIZE_ERR = ExceptionCode.DOMSTRING_SIZE_ERR = (ExceptionMessage[2] = \"DOMString size error\", 2);\n  var HIERARCHY_REQUEST_ERR = ExceptionCode.HIERARCHY_REQUEST_ERR = (ExceptionMessage[3] = \"Hierarchy request error\", 3);\n  var WRONG_DOCUMENT_ERR = ExceptionCode.WRONG_DOCUMENT_ERR = (ExceptionMessage[4] = \"Wrong document\", 4);\n  var INVALID_CHARACTER_ERR = ExceptionCode.INVALID_CHARACTER_ERR = (ExceptionMessage[5] = \"Invalid character\", 5);\n  var NO_DATA_ALLOWED_ERR = ExceptionCode.NO_DATA_ALLOWED_ERR = (ExceptionMessage[6] = \"No data allowed\", 6);\n  var NO_MODIFICATION_ALLOWED_ERR = ExceptionCode.NO_MODIFICATION_ALLOWED_ERR = (ExceptionMessage[7] = \"No modification allowed\", 7);\n  var NOT_FOUND_ERR = ExceptionCode.NOT_FOUND_ERR = (ExceptionMessage[8] = \"Not found\", 8);\n  var NOT_SUPPORTED_ERR = ExceptionCode.NOT_SUPPORTED_ERR = (ExceptionMessage[9] = \"Not supported\", 9);\n  var INUSE_ATTRIBUTE_ERR = ExceptionCode.INUSE_ATTRIBUTE_ERR = (ExceptionMessage[10] = \"Attribute in use\", 10);\n  var INVALID_STATE_ERR = ExceptionCode.INVALID_STATE_ERR = (ExceptionMessage[11] = \"Invalid state\", 11);\n  var SYNTAX_ERR = ExceptionCode.SYNTAX_ERR = (ExceptionMessage[12] = \"Syntax error\", 12);\n  var INVALID_MODIFICATION_ERR = ExceptionCode.INVALID_MODIFICATION_ERR = (ExceptionMessage[13] = \"Invalid modification\", 13);\n  var NAMESPACE_ERR = ExceptionCode.NAMESPACE_ERR = (ExceptionMessage[14] = \"Invalid namespace\", 14);\n  var INVALID_ACCESS_ERR = ExceptionCode.INVALID_ACCESS_ERR = (ExceptionMessage[15] = \"Invalid access\", 15);\n  function DOMException(code, message) {\n    if (message instanceof Error) {\n      var error = message;\n    } else {\n      error = this;\n      Error.call(this, ExceptionMessage[code]);\n      this.message = ExceptionMessage[code];\n      if (Error.captureStackTrace) Error.captureStackTrace(this, DOMException);\n    }\n    error.code = code;\n    if (message) this.message = this.message + \": \" + message;\n    return error;\n  }\n  ;\n  DOMException.prototype = Error.prototype;\n  copy(ExceptionCode, DOMException);\n  function NodeList() {}\n  ;\n  NodeList.prototype = {\n    length: 0,\n    item: function item(index) {\n      return this[index] || null;\n    }\n  };\n  function LiveNodeList(node, refresh) {\n    this._node = node;\n    this._refresh = refresh;\n    _updateLiveList(this);\n  }\n  function _updateLiveList(list) {\n    var inc = list._node._inc || list._node.ownerDocument._inc;\n    if (list._inc != inc) {\n      var ls = list._refresh(list._node);\n      __set__(list, 'length', ls.length);\n      copy(ls, list);\n      list._inc = inc;\n    }\n  }\n  LiveNodeList.prototype.item = function (i) {\n    _updateLiveList(this);\n    return this[i];\n  };\n  _extends(LiveNodeList, NodeList);\n  function NamedNodeMap() {}\n  ;\n  function _findNodeIndex(list, node) {\n    var i = list.length;\n    while (i--) {\n      if (list[i] === node) {\n        return i;\n      }\n    }\n  }\n  function _addNamedNode(el, list, newAttr, oldAttr) {\n    if (oldAttr) {\n      list[_findNodeIndex(list, oldAttr)] = newAttr;\n    } else {\n      list[list.length++] = newAttr;\n    }\n    if (el) {\n      newAttr.ownerElement = el;\n      var doc = el.ownerDocument;\n      if (doc) {\n        oldAttr && _onRemoveAttribute(doc, el, oldAttr);\n        _onAddAttribute(doc, el, newAttr);\n      }\n    }\n  }\n  function _removeNamedNode(el, list, attr) {\n    var i = _findNodeIndex(list, attr);\n    if (i >= 0) {\n      var lastIndex = list.length - 1;\n      while (i < lastIndex) {\n        list[i] = list[++i];\n      }\n      list.length = lastIndex;\n      if (el) {\n        var doc = el.ownerDocument;\n        if (doc) {\n          _onRemoveAttribute(doc, el, attr);\n          attr.ownerElement = null;\n        }\n      }\n    } else {\n      throw new DOMException(NOT_FOUND_ERR, new Error());\n    }\n  }\n  NamedNodeMap.prototype = {\n    length: 0,\n    item: NodeList.prototype.item,\n    getNamedItem: function getNamedItem(key) {\n      var i = this.length;\n      while (i--) {\n        var attr = this[i];\n        if (attr.nodeName == key) {\n          return attr;\n        }\n      }\n    },\n    setNamedItem: function setNamedItem(attr) {\n      var el = attr.ownerElement;\n      if (el && el != this._ownerElement) {\n        throw new DOMException(INUSE_ATTRIBUTE_ERR);\n      }\n      var oldAttr = this.getNamedItem(attr.nodeName);\n      _addNamedNode(this._ownerElement, this, attr, oldAttr);\n      return oldAttr;\n    },\n    setNamedItemNS: function setNamedItemNS(attr) {\n      // raises: WRONG_DOCUMENT_ERR,NO_MODIFICATION_ALLOWED_ERR,INUSE_ATTRIBUTE_ERR\n      var el = attr.ownerElement,\n        oldAttr;\n      if (el && el != this._ownerElement) {\n        throw new DOMException(INUSE_ATTRIBUTE_ERR);\n      }\n      oldAttr = this.getNamedItemNS(attr.namespaceURI, attr.localName);\n      _addNamedNode(this._ownerElement, this, attr, oldAttr);\n      return oldAttr;\n    },\n    removeNamedItem: function removeNamedItem(key) {\n      var attr = this.getNamedItem(key);\n      _removeNamedNode(this._ownerElement, this, attr);\n      return attr;\n    },\n    // raises: NOT_FOUND_ERR,NO_MODIFICATION_ALLOWED_ERR\n    removeNamedItemNS: function removeNamedItemNS(namespaceURI, localName) {\n      var attr = this.getNamedItemNS(namespaceURI, localName);\n      _removeNamedNode(this._ownerElement, this, attr);\n      return attr;\n    },\n    getNamedItemNS: function getNamedItemNS(namespaceURI, localName) {\n      var i = this.length;\n      while (i--) {\n        var node = this[i];\n        if (node.localName == localName && node.namespaceURI == namespaceURI) {\n          return node;\n        }\n      }\n      return null;\n    }\n  };\n  function DOMImplementation( /* Object */features) {\n    this._features = {};\n    if (features) {\n      for (var feature in features) {\n        this._features = features[feature];\n      }\n    }\n  }\n  ;\n  DOMImplementation.prototype = {\n    hasFeature: function hasFeature( /* string */feature, /* string */version) {\n      var versions = this._features[feature.toLowerCase()];\n      if (versions && (!version || version in versions)) {\n        return true;\n      } else {\n        return false;\n      }\n    },\n    createDocument: function createDocument(namespaceURI, qualifiedName, doctype) {\n      // raises:INVALID_CHARACTER_ERR,NAMESPACE_ERR,WRONG_DOCUMENT_ERR\n      var doc = new Document();\n      doc.implementation = this;\n      doc.childNodes = new NodeList();\n      doc.doctype = doctype;\n      if (doctype) {\n        doc.appendChild(doctype);\n      }\n      if (qualifiedName) {\n        var root = doc.createElementNS(namespaceURI, qualifiedName);\n        doc.appendChild(root);\n      }\n      return doc;\n    },\n    createDocumentType: function createDocumentType(qualifiedName, publicId, systemId) {\n      // raises:INVALID_CHARACTER_ERR,NAMESPACE_ERR\n      var node = new DocumentType();\n      node.name = qualifiedName;\n      node.nodeName = qualifiedName;\n      node.publicId = publicId;\n      node.systemId = systemId;\n      return node;\n    }\n  };\n  function Node() {}\n  ;\n  Node.prototype = {\n    firstChild: null,\n    lastChild: null,\n    previousSibling: null,\n    nextSibling: null,\n    attributes: null,\n    parentNode: null,\n    childNodes: null,\n    ownerDocument: null,\n    nodeValue: null,\n    namespaceURI: null,\n    prefix: null,\n    localName: null,\n    insertBefore: function insertBefore(newChild, refChild) {\n      //raises\n      return _insertBefore(this, newChild, refChild);\n    },\n    replaceChild: function replaceChild(newChild, oldChild) {\n      //raises\n      this.insertBefore(newChild, oldChild);\n      if (oldChild) {\n        this.removeChild(oldChild);\n      }\n    },\n    removeChild: function removeChild(oldChild) {\n      return _removeChild(this, oldChild);\n    },\n    appendChild: function appendChild(newChild) {\n      return this.insertBefore(newChild, null);\n    },\n    hasChildNodes: function hasChildNodes() {\n      return this.firstChild != null;\n    },\n    cloneNode: function cloneNode(deep) {\n      return _cloneNode(this.ownerDocument || this, this, deep);\n    },\n    normalize: function normalize() {\n      var child = this.firstChild;\n      while (child) {\n        var next = child.nextSibling;\n        if (next && next.nodeType == TEXT_NODE && child.nodeType == TEXT_NODE) {\n          this.removeChild(next);\n          child.appendData(next.data);\n        } else {\n          child.normalize();\n          child = next;\n        }\n      }\n    },\n    isSupported: function isSupported(feature, version) {\n      return this.ownerDocument.implementation.hasFeature(feature, version);\n    },\n    hasAttributes: function hasAttributes() {\n      return this.attributes.length > 0;\n    },\n    lookupPrefix: function lookupPrefix(namespaceURI) {\n      var el = this;\n      while (el) {\n        var map = el._nsMap;\n        if (map) {\n          for (var n in map) {\n            if (map[n] == namespaceURI) {\n              return n;\n            }\n          }\n        }\n        el = el.nodeType == 2 ? el.ownerDocument : el.parentNode;\n      }\n      return null;\n    },\n    lookupNamespaceURI: function lookupNamespaceURI(prefix) {\n      var el = this;\n      while (el) {\n        var map = el._nsMap;\n        if (map) {\n          if (prefix in map) {\n            return map[prefix];\n          }\n        }\n        el = el.nodeType == 2 ? el.ownerDocument : el.parentNode;\n      }\n      return null;\n    },\n    isDefaultNamespace: function isDefaultNamespace(namespaceURI) {\n      var prefix = this.lookupPrefix(namespaceURI);\n      return prefix == null;\n    }\n  };\n  function _xmlEncoder(c) {\n    return c == '<' && '&lt;' || c == '>' && '&gt;' || c == '&' && '&amp;' || c == '\"' && '&quot;' || '&#' + c.charCodeAt() + ';';\n  }\n  copy(NodeType, Node);\n  copy(NodeType, Node.prototype);\n  function _visitNode(node, callback) {\n    if (callback(node)) {\n      return true;\n    }\n    if (node = node.firstChild) {\n      do {\n        if (_visitNode(node, callback)) {\n          return true;\n        }\n      } while (node = node.nextSibling);\n    }\n  }\n  function Document() {}\n  function _onAddAttribute(doc, el, newAttr) {\n    doc && doc._inc++;\n    var ns = newAttr.namespaceURI;\n    if (ns == 'http://www.w3.org/2000/xmlns/') {\n      el._nsMap[newAttr.prefix ? newAttr.localName : ''] = newAttr.value;\n    }\n  }\n  function _onRemoveAttribute(doc, el, newAttr, remove) {\n    doc && doc._inc++;\n    var ns = newAttr.namespaceURI;\n    if (ns == 'http://www.w3.org/2000/xmlns/') {\n      delete el._nsMap[newAttr.prefix ? newAttr.localName : ''];\n    }\n  }\n  function _onUpdateChild(doc, el, newChild) {\n    if (doc && doc._inc) {\n      doc._inc++;\n      var cs = el.childNodes;\n      if (newChild) {\n        cs[cs.length++] = newChild;\n      } else {\n        var child = el.firstChild;\n        var i = 0;\n        while (child) {\n          cs[i++] = child;\n          child = child.nextSibling;\n        }\n        cs.length = i;\n      }\n    }\n  }\n  function _removeChild(parentNode, child) {\n    var previous = child.previousSibling;\n    var next = child.nextSibling;\n    if (previous) {\n      previous.nextSibling = next;\n    } else {\n      parentNode.firstChild = next;\n    }\n    if (next) {\n      next.previousSibling = previous;\n    } else {\n      parentNode.lastChild = previous;\n    }\n    _onUpdateChild(parentNode.ownerDocument, parentNode);\n    return child;\n  }\n  function _insertBefore(parentNode, newChild, nextChild) {\n    var cp = newChild.parentNode;\n    if (cp) {\n      cp.removeChild(newChild); //remove and update\n    }\n\n    if (newChild.nodeType === DOCUMENT_FRAGMENT_NODE) {\n      var newFirst = newChild.firstChild;\n      if (newFirst == null) {\n        return newChild;\n      }\n      var newLast = newChild.lastChild;\n    } else {\n      newFirst = newLast = newChild;\n    }\n    var pre = nextChild ? nextChild.previousSibling : parentNode.lastChild;\n    newFirst.previousSibling = pre;\n    newLast.nextSibling = nextChild;\n    if (pre) {\n      pre.nextSibling = newFirst;\n    } else {\n      parentNode.firstChild = newFirst;\n    }\n    if (nextChild == null) {\n      parentNode.lastChild = newLast;\n    } else {\n      nextChild.previousSibling = newLast;\n    }\n    do {\n      newFirst.parentNode = parentNode;\n    } while (newFirst !== newLast && (newFirst = newFirst.nextSibling));\n    _onUpdateChild(parentNode.ownerDocument || parentNode, parentNode);\n    if (newChild.nodeType == DOCUMENT_FRAGMENT_NODE) {\n      newChild.firstChild = newChild.lastChild = null;\n    }\n    return newChild;\n  }\n  function _appendSingleChild(parentNode, newChild) {\n    var cp = newChild.parentNode;\n    if (cp) {\n      var pre = parentNode.lastChild;\n      cp.removeChild(newChild); //remove and update\n      var pre = parentNode.lastChild;\n    }\n    var pre = parentNode.lastChild;\n    newChild.parentNode = parentNode;\n    newChild.previousSibling = pre;\n    newChild.nextSibling = null;\n    if (pre) {\n      pre.nextSibling = newChild;\n    } else {\n      parentNode.firstChild = newChild;\n    }\n    parentNode.lastChild = newChild;\n    _onUpdateChild(parentNode.ownerDocument, parentNode, newChild);\n    return newChild;\n  }\n  Document.prototype = {\n    nodeName: '#document',\n    nodeType: DOCUMENT_NODE,\n    doctype: null,\n    documentElement: null,\n    _inc: 1,\n    insertBefore: function insertBefore(newChild, refChild) {\n      //raises\n      if (newChild.nodeType == DOCUMENT_FRAGMENT_NODE) {\n        var child = newChild.firstChild;\n        while (child) {\n          var next = child.nextSibling;\n          this.insertBefore(child, refChild);\n          child = next;\n        }\n        return newChild;\n      }\n      if (this.documentElement == null && newChild.nodeType == 1) {\n        this.documentElement = newChild;\n      }\n      return _insertBefore(this, newChild, refChild), newChild.ownerDocument = this, newChild;\n    },\n    removeChild: function removeChild(oldChild) {\n      if (this.documentElement == oldChild) {\n        this.documentElement = null;\n      }\n      return _removeChild(this, oldChild);\n    },\n    importNode: function importNode(importedNode, deep) {\n      return _importNode(this, importedNode, deep);\n    },\n    getElementById: function getElementById(id) {\n      var rtv = null;\n      _visitNode(this.documentElement, function (node) {\n        if (node.nodeType == 1) {\n          if (node.getAttribute('id') == id) {\n            rtv = node;\n            return true;\n          }\n        }\n      });\n      return rtv;\n    },\n    createElement: function createElement(tagName) {\n      var node = new Element();\n      node.ownerDocument = this;\n      node.nodeName = tagName;\n      node.tagName = tagName;\n      node.childNodes = new NodeList();\n      var attrs = node.attributes = new NamedNodeMap();\n      attrs._ownerElement = node;\n      return node;\n    },\n    createDocumentFragment: function createDocumentFragment() {\n      var node = new DocumentFragment();\n      node.ownerDocument = this;\n      node.childNodes = new NodeList();\n      return node;\n    },\n    createTextNode: function createTextNode(data) {\n      var node = new Text();\n      node.ownerDocument = this;\n      node.appendData(data);\n      return node;\n    },\n    createComment: function createComment(data) {\n      var node = new Comment();\n      node.ownerDocument = this;\n      node.appendData(data);\n      return node;\n    },\n    createCDATASection: function createCDATASection(data) {\n      var node = new CDATASection();\n      node.ownerDocument = this;\n      node.appendData(data);\n      return node;\n    },\n    createProcessingInstruction: function createProcessingInstruction(target, data) {\n      var node = new ProcessingInstruction();\n      node.ownerDocument = this;\n      node.tagName = node.target = target;\n      node.nodeValue = node.data = data;\n      return node;\n    },\n    createAttribute: function createAttribute(name) {\n      var node = new Attr();\n      node.ownerDocument = this;\n      node.name = name;\n      node.nodeName = name;\n      node.localName = name;\n      node.specified = true;\n      return node;\n    },\n    createEntityReference: function createEntityReference(name) {\n      var node = new EntityReference();\n      node.ownerDocument = this;\n      node.nodeName = name;\n      return node;\n    },\n    createElementNS: function createElementNS(namespaceURI, qualifiedName) {\n      var node = new Element();\n      var pl = qualifiedName.split(':');\n      var attrs = node.attributes = new NamedNodeMap();\n      node.childNodes = new NodeList();\n      node.ownerDocument = this;\n      node.nodeName = qualifiedName;\n      node.tagName = qualifiedName;\n      node.namespaceURI = namespaceURI;\n      if (pl.length == 2) {\n        node.prefix = pl[0];\n        node.localName = pl[1];\n      } else {\n        node.localName = qualifiedName;\n      }\n      attrs._ownerElement = node;\n      return node;\n    },\n    createAttributeNS: function createAttributeNS(namespaceURI, qualifiedName) {\n      var node = new Attr();\n      var pl = qualifiedName.split(':');\n      node.ownerDocument = this;\n      node.nodeName = qualifiedName;\n      node.name = qualifiedName;\n      node.namespaceURI = namespaceURI;\n      node.specified = true;\n      if (pl.length == 2) {\n        node.prefix = pl[0];\n        node.localName = pl[1];\n      } else {\n        node.localName = qualifiedName;\n      }\n      return node;\n    }\n  };\n  _extends(Document, Node);\n  function Element() {\n    this._nsMap = {};\n  }\n  ;\n  Element.prototype = {\n    nodeType: ELEMENT_NODE,\n    hasAttribute: function hasAttribute(name) {\n      return this.getAttributeNode(name) != null;\n    },\n    getAttribute: function getAttribute(name) {\n      var attr = this.getAttributeNode(name);\n      return attr && attr.value || '';\n    },\n    getAttributeNode: function getAttributeNode(name) {\n      return this.attributes.getNamedItem(name);\n    },\n    setAttribute: function setAttribute(name, value) {\n      var attr = this.ownerDocument.createAttribute(name);\n      attr.value = attr.nodeValue = \"\" + value;\n      this.setAttributeNode(attr);\n    },\n    removeAttribute: function removeAttribute(name) {\n      var attr = this.getAttributeNode(name);\n      attr && this.removeAttributeNode(attr);\n    },\n    appendChild: function appendChild(newChild) {\n      if (newChild.nodeType === DOCUMENT_FRAGMENT_NODE) {\n        return this.insertBefore(newChild, null);\n      } else {\n        return _appendSingleChild(this, newChild);\n      }\n    },\n    setAttributeNode: function setAttributeNode(newAttr) {\n      return this.attributes.setNamedItem(newAttr);\n    },\n    setAttributeNodeNS: function setAttributeNodeNS(newAttr) {\n      return this.attributes.setNamedItemNS(newAttr);\n    },\n    removeAttributeNode: function removeAttributeNode(oldAttr) {\n      return this.attributes.removeNamedItem(oldAttr.nodeName);\n    },\n    removeAttributeNS: function removeAttributeNS(namespaceURI, localName) {\n      var old = this.getAttributeNodeNS(namespaceURI, localName);\n      old && this.removeAttributeNode(old);\n    },\n    hasAttributeNS: function hasAttributeNS(namespaceURI, localName) {\n      return this.getAttributeNodeNS(namespaceURI, localName) != null;\n    },\n    getAttributeNS: function getAttributeNS(namespaceURI, localName) {\n      var attr = this.getAttributeNodeNS(namespaceURI, localName);\n      return attr && attr.value || '';\n    },\n    setAttributeNS: function setAttributeNS(namespaceURI, qualifiedName, value) {\n      var attr = this.ownerDocument.createAttributeNS(namespaceURI, qualifiedName);\n      attr.value = attr.nodeValue = \"\" + value;\n      this.setAttributeNode(attr);\n    },\n    getAttributeNodeNS: function getAttributeNodeNS(namespaceURI, localName) {\n      return this.attributes.getNamedItemNS(namespaceURI, localName);\n    },\n    getElementsByTagName: function getElementsByTagName(tagName) {\n      return new LiveNodeList(this, function (base) {\n        var ls = [];\n        _visitNode(base, function (node) {\n          if (node !== base && node.nodeType == ELEMENT_NODE && (tagName === '*' || node.tagName == tagName)) {\n            ls.push(node);\n          }\n        });\n        return ls;\n      });\n    },\n    getElementsByTagNameNS: function getElementsByTagNameNS(namespaceURI, localName) {\n      return new LiveNodeList(this, function (base) {\n        var ls = [];\n        _visitNode(base, function (node) {\n          if (node !== base && node.nodeType === ELEMENT_NODE && (namespaceURI === '*' || node.namespaceURI === namespaceURI) && (localName === '*' || node.localName == localName)) {\n            ls.push(node);\n          }\n        });\n        return ls;\n      });\n    }\n  };\n  Document.prototype.getElementsByTagName = Element.prototype.getElementsByTagName;\n  Document.prototype.getElementsByTagNameNS = Element.prototype.getElementsByTagNameNS;\n  _extends(Element, Node);\n  function Attr() {}\n  ;\n  Attr.prototype.nodeType = ATTRIBUTE_NODE;\n  _extends(Attr, Node);\n  function CharacterData() {}\n  ;\n  CharacterData.prototype = {\n    data: '',\n    substringData: function substringData(offset, count) {\n      return this.data.substring(offset, offset + count);\n    },\n    appendData: function appendData(text) {\n      text = this.data + text;\n      this.nodeValue = this.data = text;\n      this.length = text.length;\n    },\n    insertData: function insertData(offset, text) {\n      this.replaceData(offset, 0, text);\n    },\n    appendChild: function appendChild(newChild) {\n      throw new Error(ExceptionMessage[3]);\n      return Node.prototype.appendChild.apply(this, arguments);\n    },\n    deleteData: function deleteData(offset, count) {\n      this.replaceData(offset, count, \"\");\n    },\n    replaceData: function replaceData(offset, count, text) {\n      var start = this.data.substring(0, offset);\n      var end = this.data.substring(offset + count);\n      text = start + text + end;\n      this.nodeValue = this.data = text;\n      this.length = text.length;\n    }\n  };\n  _extends(CharacterData, Node);\n  function Text() {}\n  ;\n  Text.prototype = {\n    nodeName: \"#text\",\n    nodeType: TEXT_NODE,\n    splitText: function splitText(offset) {\n      var text = this.data;\n      var newText = text.substring(offset);\n      text = text.substring(0, offset);\n      this.data = this.nodeValue = text;\n      this.length = text.length;\n      var newNode = this.ownerDocument.createTextNode(newText);\n      if (this.parentNode) {\n        this.parentNode.insertBefore(newNode, this.nextSibling);\n      }\n      return newNode;\n    }\n  };\n  _extends(Text, CharacterData);\n  function Comment() {}\n  ;\n  Comment.prototype = {\n    nodeName: \"#comment\",\n    nodeType: COMMENT_NODE\n  };\n  _extends(Comment, CharacterData);\n  function CDATASection() {}\n  ;\n  CDATASection.prototype = {\n    nodeName: \"#cdata-section\",\n    nodeType: CDATA_SECTION_NODE\n  };\n  _extends(CDATASection, CharacterData);\n  function DocumentType() {}\n  DocumentType.prototype.nodeType = DOCUMENT_TYPE_NODE;\n  _extends(DocumentType, Node);\n  function Notation() {}\n  Notation.prototype.nodeType = NOTATION_NODE;\n  _extends(Notation, Node);\n  function Entity() {}\n  Entity.prototype.nodeType = ENTITY_NODE;\n  _extends(Entity, Node);\n  function EntityReference() {}\n  EntityReference.prototype.nodeType = ENTITY_REFERENCE_NODE;\n  _extends(EntityReference, Node);\n  function DocumentFragment() {}\n  DocumentFragment.prototype.nodeName = \"#document-fragment\";\n  DocumentFragment.prototype.nodeType = DOCUMENT_FRAGMENT_NODE;\n  _extends(DocumentFragment, Node);\n  function ProcessingInstruction() {}\n  ProcessingInstruction.prototype.nodeType = PROCESSING_INSTRUCTION_NODE;\n  _extends(ProcessingInstruction, Node);\n  function XMLSerializer() {}\n  XMLSerializer.prototype.serializeToString = function (node) {\n    var buf = [];\n    serializeToString(node, buf);\n    return buf.join('');\n  };\n  Node.prototype.toString = function () {\n    return XMLSerializer.prototype.serializeToString(this);\n  };\n  function serializeToString(node, buf) {\n    switch (node.nodeType) {\n      case ELEMENT_NODE:\n        var attrs = node.attributes;\n        var len = attrs.length;\n        var child = node.firstChild;\n        var nodeName = node.tagName;\n        var isHTML = htmlns === node.namespaceURI;\n        buf.push('<', nodeName);\n        for (var i = 0; i < len; i++) {\n          serializeToString(attrs.item(i), buf);\n        }\n        if (child || isHTML && !/^(?:meta|link|img|br|hr|input|button)$/i.test(nodeName)) {\n          buf.push('>');\n          if (isHTML && /^script$/i.test(nodeName)) {\n            if (child) {\n              buf.push(child.data);\n            }\n          } else {\n            while (child) {\n              serializeToString(child, buf);\n              child = child.nextSibling;\n            }\n          }\n          buf.push('</', nodeName, '>');\n        } else {\n          buf.push('/>');\n        }\n        return;\n      case DOCUMENT_NODE:\n      case DOCUMENT_FRAGMENT_NODE:\n        var child = node.firstChild;\n        while (child) {\n          serializeToString(child, buf);\n          child = child.nextSibling;\n        }\n        return;\n      case ATTRIBUTE_NODE:\n        return buf.push(' ', node.name, '=\"', node.value.replace(/[<&\"]/g, _xmlEncoder), '\"');\n      case TEXT_NODE:\n        return buf.push(node.data.replace(/[<&]/g, _xmlEncoder));\n      case CDATA_SECTION_NODE:\n        return buf.push('<![CDATA[', node.data, ']]>');\n      case COMMENT_NODE:\n        return buf.push(\"<!--\", node.data, \"-->\");\n      case DOCUMENT_TYPE_NODE:\n        var pubid = node.publicId;\n        var sysid = node.systemId;\n        buf.push('<!DOCTYPE ', node.name);\n        if (pubid) {\n          buf.push(' PUBLIC \"', pubid);\n          if (sysid && sysid != '.') {\n            buf.push('\" \"', sysid);\n          }\n          buf.push('\">');\n        } else if (sysid && sysid != '.') {\n          buf.push(' SYSTEM \"', sysid, '\">');\n        } else {\n          var sub = node.internalSubset;\n          if (sub) {\n            buf.push(\" [\", sub, \"]\");\n          }\n          buf.push(\">\");\n        }\n        return;\n      case PROCESSING_INSTRUCTION_NODE:\n        return buf.push(\"<?\", node.target, \" \", node.data, \"?>\");\n      case ENTITY_REFERENCE_NODE:\n        return buf.push('&', node.nodeName, ';');\n      default:\n        buf.push('??', node.nodeName);\n    }\n  }\n  function _importNode(doc, node, deep) {\n    var node2;\n    switch (node.nodeType) {\n      case ELEMENT_NODE:\n        node2 = node.cloneNode(false);\n        node2.ownerDocument = doc;\n      case DOCUMENT_FRAGMENT_NODE:\n        break;\n      case ATTRIBUTE_NODE:\n        deep = true;\n        break;\n    }\n    if (!node2) {\n      node2 = node.cloneNode(false); //false\n    }\n\n    node2.ownerDocument = doc;\n    node2.parentNode = null;\n    if (deep) {\n      var child = node.firstChild;\n      while (child) {\n        node2.appendChild(_importNode(doc, child, deep));\n        child = child.nextSibling;\n      }\n    }\n    return node2;\n  }\n  function _cloneNode(doc, node, deep) {\n    var node2 = new node.constructor();\n    for (var n in node) {\n      var v = node[n];\n      if (typeof v != 'object') {\n        if (v != node2[n]) {\n          node2[n] = v;\n        }\n      }\n    }\n    if (node.childNodes) {\n      node2.childNodes = new NodeList();\n    }\n    node2.ownerDocument = doc;\n    switch (node2.nodeType) {\n      case ELEMENT_NODE:\n        var attrs = node.attributes;\n        var attrs2 = node2.attributes = new NamedNodeMap();\n        var len = attrs.length;\n        attrs2._ownerElement = node2;\n        for (var i = 0; i < len; i++) {\n          node2.setAttributeNode(_cloneNode(doc, attrs.item(i), true));\n        }\n        break;\n      case ATTRIBUTE_NODE:\n        deep = true;\n    }\n    if (deep) {\n      var child = node.firstChild;\n      while (child) {\n        node2.appendChild(_cloneNode(doc, child, deep));\n        child = child.nextSibling;\n      }\n    }\n    return node2;\n  }\n  function __set__(object, key, value) {\n    object[key] = value;\n  }\n  function getTextContent(node) {\n    switch (node.nodeType) {\n      case 1:\n      case 11:\n        var buf = [];\n        node = node.firstChild;\n        while (node) {\n          if (node.nodeType !== 7 && node.nodeType !== 8) {\n            buf.push(getTextContent(node));\n          }\n          node = node.nextSibling;\n        }\n        return buf.join('');\n      default:\n        return node.nodeValue;\n    }\n  }\n  try {\n    if (Object.defineProperty) {\n      Object.defineProperty(LiveNodeList.prototype, 'length', {\n        get: function get() {\n          _updateLiveList(this);\n          return this.$$length;\n        }\n      });\n      Object.defineProperty(Node.prototype, 'textContent', {\n        get: function get() {\n          return getTextContent(this);\n        },\n        set: function set(data) {\n          switch (this.nodeType) {\n            case 1:\n            case 11:\n              while (this.firstChild) {\n                this.removeChild(this.firstChild);\n              }\n              if (data || String(data)) {\n                this.appendChild(this.ownerDocument.createTextNode(data));\n              }\n              break;\n            default:\n              this.data = data;\n              this.value = value;\n              this.nodeValue = data;\n          }\n        }\n      });\n      __set__ = function __set__(object, key, value) {\n        object['$$' + key] = value;\n      };\n    }\n  } catch (e) {//ie8\n  }\n  return DOMImplementation;\n});\nace.define(\"ace/mode/xml/dom-parser\", [], function (require, exports, module) {\n  'use strict';\n\n  var XMLReader = require('./sax'),\n    DOMImplementation = require('./dom');\n  function DOMParser(options) {\n    this.options = options || {\n      locator: {}\n    };\n  }\n  DOMParser.prototype.parseFromString = function (source, mimeType) {\n    var options = this.options;\n    var sax = new XMLReader();\n    var domBuilder = options.domBuilder || new DOMHandler(); //contentHandler and LexicalHandler\n    var errorHandler = options.errorHandler;\n    var locator = options.locator;\n    var defaultNSMap = options.xmlns || {};\n    var entityMap = {\n      'lt': '<',\n      'gt': '>',\n      'amp': '&',\n      'quot': '\"',\n      'apos': \"'\"\n    };\n    if (locator) {\n      domBuilder.setDocumentLocator(locator);\n    }\n    sax.errorHandler = buildErrorHandler(errorHandler, domBuilder, locator);\n    sax.domBuilder = options.domBuilder || domBuilder;\n    if (/\\/x?html?$/.test(mimeType)) {\n      entityMap.nbsp = '\\xa0';\n      entityMap.copy = '\\xa9';\n      defaultNSMap[''] = 'http://www.w3.org/1999/xhtml';\n    }\n    if (source) {\n      sax.parse(source, defaultNSMap, entityMap);\n    } else {\n      sax.errorHandler.error(\"invalid document source\");\n    }\n    return domBuilder.document;\n  };\n  function buildErrorHandler(errorImpl, domBuilder, locator) {\n    if (!errorImpl) {\n      if (domBuilder instanceof DOMHandler) {\n        return domBuilder;\n      }\n      errorImpl = domBuilder;\n    }\n    var errorHandler = {};\n    var isCallback = errorImpl instanceof Function;\n    locator = locator || {};\n    function build(key) {\n      var fn = errorImpl[key];\n      if (!fn) {\n        if (isCallback) {\n          fn = errorImpl.length == 2 ? function (msg) {\n            errorImpl(key, msg);\n          } : errorImpl;\n        } else {\n          var i = arguments.length;\n          while (--i) {\n            if (fn = errorImpl[arguments[i]]) {\n              break;\n            }\n          }\n        }\n      }\n      errorHandler[key] = fn && function (msg) {\n        fn(msg + _locator(locator), msg, locator);\n      } || function () {};\n    }\n    build('warning', 'warn');\n    build('error', 'warn', 'warning');\n    build('fatalError', 'warn', 'warning', 'error');\n    return errorHandler;\n  }\n  function DOMHandler() {\n    this.cdata = false;\n  }\n  function position(locator, node) {\n    node.lineNumber = locator.lineNumber;\n    node.columnNumber = locator.columnNumber;\n  }\n  DOMHandler.prototype = {\n    startDocument: function startDocument() {\n      this.document = new DOMImplementation().createDocument(null, null, null);\n      if (this.locator) {\n        this.document.documentURI = this.locator.systemId;\n      }\n    },\n    startElement: function startElement(namespaceURI, localName, qName, attrs) {\n      var doc = this.document;\n      var el = doc.createElementNS(namespaceURI, qName || localName);\n      var len = attrs.length;\n      appendElement(this, el);\n      this.currentElement = el;\n      this.locator && position(this.locator, el);\n      for (var i = 0; i < len; i++) {\n        var namespaceURI = attrs.getURI(i);\n        var value = attrs.getValue(i);\n        var qName = attrs.getQName(i);\n        var attr = doc.createAttributeNS(namespaceURI, qName);\n        if (attr.getOffset) {\n          position(attr.getOffset(1), attr);\n        }\n        attr.value = attr.nodeValue = value;\n        el.setAttributeNode(attr);\n      }\n    },\n    endElement: function endElement(namespaceURI, localName, qName) {\n      var current = this.currentElement;\n      var tagName = current.tagName;\n      this.currentElement = current.parentNode;\n    },\n    startPrefixMapping: function startPrefixMapping(prefix, uri) {},\n    endPrefixMapping: function endPrefixMapping(prefix) {},\n    processingInstruction: function processingInstruction(target, data) {\n      var ins = this.document.createProcessingInstruction(target, data);\n      this.locator && position(this.locator, ins);\n      appendElement(this, ins);\n    },\n    ignorableWhitespace: function ignorableWhitespace(ch, start, length) {},\n    characters: function characters(chars, start, length) {\n      chars = _toString.apply(this, arguments);\n      if (this.currentElement && chars) {\n        if (this.cdata) {\n          var charNode = this.document.createCDATASection(chars);\n          this.currentElement.appendChild(charNode);\n        } else {\n          var charNode = this.document.createTextNode(chars);\n          this.currentElement.appendChild(charNode);\n        }\n        this.locator && position(this.locator, charNode);\n      }\n    },\n    skippedEntity: function skippedEntity(name) {},\n    endDocument: function endDocument() {\n      this.document.normalize();\n    },\n    setDocumentLocator: function setDocumentLocator(locator) {\n      if (this.locator = locator) {\n        // && !('lineNumber' in locator)){\n        locator.lineNumber = 0;\n      }\n    },\n    comment: function comment(chars, start, length) {\n      chars = _toString.apply(this, arguments);\n      var comm = this.document.createComment(chars);\n      this.locator && position(this.locator, comm);\n      appendElement(this, comm);\n    },\n    startCDATA: function startCDATA() {\n      this.cdata = true;\n    },\n    endCDATA: function endCDATA() {\n      this.cdata = false;\n    },\n    startDTD: function startDTD(name, publicId, systemId) {\n      var impl = this.document.implementation;\n      if (impl && impl.createDocumentType) {\n        var dt = impl.createDocumentType(name, publicId, systemId);\n        this.locator && position(this.locator, dt);\n        appendElement(this, dt);\n      }\n    },\n    warning: function warning(error) {\n      console.warn(error, _locator(this.locator));\n    },\n    error: function error(_error) {\n      console.error(_error, _locator(this.locator));\n    },\n    fatalError: function fatalError(error) {\n      console.error(error, _locator(this.locator));\n      throw error;\n    }\n  };\n  function _locator(l) {\n    if (l) {\n      return '\\n@' + (l.systemId || '') + '#[line:' + l.lineNumber + ',col:' + l.columnNumber + ']';\n    }\n  }\n  function _toString(chars, start, length) {\n    if (typeof chars == 'string') {\n      return chars.substr(start, length);\n    } else {\n      //java sax connect width xmldom on rhino(what about: \"? && !(chars instanceof String)\")\n      if (chars.length >= start + length || start) {\n        return new java.lang.String(chars, start, length) + '';\n      }\n      return chars;\n    }\n  }\n  \"endDTD,startEntity,endEntity,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,resolveEntity,getExternalSubset,notationDecl,unparsedEntityDecl\".replace(/\\w+/g, function (key) {\n    DOMHandler.prototype[key] = function () {\n      return null;\n    };\n  });\n  function appendElement(hander, node) {\n    if (!hander.currentElement) {\n      hander.document.appendChild(node);\n    } else {\n      hander.currentElement.appendChild(node);\n    }\n  } //appendChild and setAttributeNS are preformance key\n\n  return {\n    DOMParser: DOMParser\n  };\n});\nace.define(\"ace/mode/xml_worker\", [], function (require, exports, module) {\n  \"use strict\";\n\n  var oop = require(\"../lib/oop\");\n  var lang = require(\"../lib/lang\");\n  var Mirror = require(\"../worker/mirror\").Mirror;\n  var DOMParser = require(\"./xml/dom-parser\").DOMParser;\n  var Worker = exports.Worker = function (sender) {\n    Mirror.call(this, sender);\n    this.setTimeout(400);\n    this.context = null;\n  };\n  oop.inherits(Worker, Mirror);\n  (function () {\n    this.setOptions = function (options) {\n      this.context = options.context;\n    };\n    this.onUpdate = function () {\n      var value = this.doc.getValue();\n      if (!value) return;\n      var parser = new DOMParser();\n      var errors = [];\n      parser.options.errorHandler = {\n        fatalError: function fatalError(fullMsg, errorMsg, locator) {\n          errors.push({\n            row: locator.lineNumber,\n            column: locator.columnNumber,\n            text: errorMsg,\n            type: \"error\"\n          });\n        },\n        error: function error(fullMsg, errorMsg, locator) {\n          errors.push({\n            row: locator.lineNumber,\n            column: locator.columnNumber,\n            text: errorMsg,\n            type: \"error\"\n          });\n        },\n        warning: function warning(fullMsg, errorMsg, locator) {\n          errors.push({\n            row: locator.lineNumber,\n            column: locator.columnNumber,\n            text: errorMsg,\n            type: \"warning\"\n          });\n        }\n      };\n      parser.parseFromString(value);\n      this.sender.emit(\"error\", errors);\n    };\n  }).call(Worker.prototype);\n});","map":null,"metadata":{},"sourceType":"script"}