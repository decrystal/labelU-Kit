{"ast":null,"code":"ace.define(\"ace/occur\", [\"require\", \"exports\", \"module\", \"ace/lib/oop\", \"ace/range\", \"ace/search\", \"ace/edit_session\", \"ace/search_highlight\", \"ace/lib/dom\"], function (require, exports, module) {\n  \"use strict\";\n\n  var oop = require(\"./lib/oop\");\n  var Range = require(\"./range\").Range;\n  var Search = require(\"./search\").Search;\n  var EditSession = require(\"./edit_session\").EditSession;\n  var SearchHighlight = require(\"./search_highlight\").SearchHighlight;\n  function Occur() {}\n  oop.inherits(Occur, Search);\n  (function () {\n    this.enter = function (editor, options) {\n      if (!options.needle) return false;\n      var pos = editor.getCursorPosition();\n      this.displayOccurContent(editor, options);\n      var translatedPos = this.originalToOccurPosition(editor.session, pos);\n      editor.moveCursorToPosition(translatedPos);\n      return true;\n    };\n    this.exit = function (editor, options) {\n      var pos = options.translatePosition && editor.getCursorPosition();\n      var translatedPos = pos && this.occurToOriginalPosition(editor.session, pos);\n      this.displayOriginalContent(editor);\n      if (translatedPos) editor.moveCursorToPosition(translatedPos);\n      return true;\n    };\n    this.highlight = function (sess, regexp) {\n      var hl = sess.$occurHighlight = sess.$occurHighlight || sess.addDynamicMarker(new SearchHighlight(null, \"ace_occur-highlight\", \"text\"));\n      hl.setRegexp(regexp);\n      sess._emit(\"changeBackMarker\"); // force highlight layer redraw\n    };\n\n    this.displayOccurContent = function (editor, options) {\n      this.$originalSession = editor.session;\n      var found = this.matchingLines(editor.session, options);\n      var lines = found.map(function (foundLine) {\n        return foundLine.content;\n      });\n      var occurSession = new EditSession(lines.join('\\n'));\n      occurSession.$occur = this;\n      occurSession.$occurMatchingLines = found;\n      editor.setSession(occurSession);\n      this.$useEmacsStyleLineStart = this.$originalSession.$useEmacsStyleLineStart;\n      occurSession.$useEmacsStyleLineStart = this.$useEmacsStyleLineStart;\n      this.highlight(occurSession, options.re);\n      occurSession._emit('changeBackMarker');\n    };\n    this.displayOriginalContent = function (editor) {\n      editor.setSession(this.$originalSession);\n      this.$originalSession.$useEmacsStyleLineStart = this.$useEmacsStyleLineStart;\n    };\n    this.originalToOccurPosition = function (session, pos) {\n      var lines = session.$occurMatchingLines;\n      var nullPos = {\n        row: 0,\n        column: 0\n      };\n      if (!lines) return nullPos;\n      for (var i = 0; i < lines.length; i++) {\n        if (lines[i].row === pos.row) return {\n          row: i,\n          column: pos.column\n        };\n      }\n      return nullPos;\n    };\n    this.occurToOriginalPosition = function (session, pos) {\n      var lines = session.$occurMatchingLines;\n      if (!lines || !lines[pos.row]) return pos;\n      return {\n        row: lines[pos.row].row,\n        column: pos.column\n      };\n    };\n    this.matchingLines = function (session, options) {\n      options = oop.mixin({}, options);\n      if (!session || !options.needle) return [];\n      var search = new Search();\n      search.set(options);\n      return search.findAll(session).reduce(function (lines, range) {\n        var row = range.start.row;\n        var last = lines[lines.length - 1];\n        return last && last.row === row ? lines : lines.concat({\n          row: row,\n          content: session.getLine(row)\n        });\n      }, []);\n    };\n  }).call(Occur.prototype);\n  var dom = require('./lib/dom');\n  dom.importCssString(\".ace_occur-highlight {\\n\\\n    border-radius: 4px;\\n\\\n    background-color: rgba(87, 255, 8, 0.25);\\n\\\n    position: absolute;\\n\\\n    z-index: 4;\\n\\\n    box-sizing: border-box;\\n\\\n    box-shadow: 0 0 4px rgb(91, 255, 50);\\n\\\n}\\n\\\n.ace_dark .ace_occur-highlight {\\n\\\n    background-color: rgb(80, 140, 85);\\n\\\n    box-shadow: 0 0 4px rgb(60, 120, 70);\\n\\\n}\\n\", \"incremental-occur-highlighting\", false);\n  exports.Occur = Occur;\n});\nace.define(\"ace/commands/occur_commands\", [\"require\", \"exports\", \"module\", \"ace/config\", \"ace/occur\", \"ace/keyboard/hash_handler\", \"ace/lib/oop\"], function (require, exports, module) {\n  var config = require(\"../config\"),\n    Occur = require(\"../occur\").Occur;\n  var occurStartCommand = {\n    name: \"occur\",\n    exec: function exec(editor, options) {\n      var alreadyInOccur = !!editor.session.$occur;\n      var occurSessionActive = new Occur().enter(editor, options);\n      if (occurSessionActive && !alreadyInOccur) OccurKeyboardHandler.installIn(editor);\n    },\n    readOnly: true\n  };\n  var occurCommands = [{\n    name: \"occurexit\",\n    bindKey: 'esc|Ctrl-G',\n    exec: function exec(editor) {\n      var occur = editor.session.$occur;\n      if (!occur) return;\n      occur.exit(editor, {});\n      if (!editor.session.$occur) OccurKeyboardHandler.uninstallFrom(editor);\n    },\n    readOnly: true\n  }, {\n    name: \"occuraccept\",\n    bindKey: 'enter',\n    exec: function exec(editor) {\n      var occur = editor.session.$occur;\n      if (!occur) return;\n      occur.exit(editor, {\n        translatePosition: true\n      });\n      if (!editor.session.$occur) OccurKeyboardHandler.uninstallFrom(editor);\n    },\n    readOnly: true\n  }];\n  var HashHandler = require(\"../keyboard/hash_handler\").HashHandler;\n  var oop = require(\"../lib/oop\");\n  function OccurKeyboardHandler() {}\n  oop.inherits(OccurKeyboardHandler, HashHandler);\n  (function () {\n    this.isOccurHandler = true;\n    this.attach = function (editor) {\n      HashHandler.call(this, occurCommands, editor.commands.platform);\n      this.$editor = editor;\n    };\n    var handleKeyboard$super = this.handleKeyboard;\n    this.handleKeyboard = function (data, hashId, key, keyCode) {\n      var cmd = handleKeyboard$super.call(this, data, hashId, key, keyCode);\n      return cmd && cmd.command ? cmd : undefined;\n    };\n  }).call(OccurKeyboardHandler.prototype);\n  OccurKeyboardHandler.installIn = function (editor) {\n    var handler = new this();\n    editor.keyBinding.addKeyboardHandler(handler);\n    editor.commands.addCommands(occurCommands);\n  };\n  OccurKeyboardHandler.uninstallFrom = function (editor) {\n    editor.commands.removeCommands(occurCommands);\n    var handler = editor.getKeyboardHandler();\n    if (handler.isOccurHandler) editor.keyBinding.removeKeyboardHandler(handler);\n  };\n  exports.occurStartCommand = occurStartCommand;\n});\nace.define(\"ace/commands/incremental_search_commands\", [\"require\", \"exports\", \"module\", \"ace/config\", \"ace/lib/oop\", \"ace/keyboard/hash_handler\", \"ace/commands/occur_commands\"], function (require, exports, module) {\n  var config = require(\"../config\");\n  var oop = require(\"../lib/oop\");\n  var HashHandler = require(\"../keyboard/hash_handler\").HashHandler;\n  var occurStartCommand = require(\"./occur_commands\").occurStartCommand;\n  exports.iSearchStartCommands = [{\n    name: \"iSearch\",\n    bindKey: {\n      win: \"Ctrl-F\",\n      mac: \"Command-F\"\n    },\n    exec: function exec(editor, options) {\n      config.loadModule([\"core\", \"ace/incremental_search\"], function (e) {\n        var iSearch = e.iSearch = e.iSearch || new e.IncrementalSearch();\n        iSearch.activate(editor, options.backwards);\n        if (options.jumpToFirstMatch) iSearch.next(options);\n      });\n    },\n    readOnly: true\n  }, {\n    name: \"iSearchBackwards\",\n    exec: function exec(editor, jumpToNext) {\n      editor.execCommand('iSearch', {\n        backwards: true\n      });\n    },\n    readOnly: true\n  }, {\n    name: \"iSearchAndGo\",\n    bindKey: {\n      win: \"Ctrl-K\",\n      mac: \"Command-G\"\n    },\n    exec: function exec(editor, jumpToNext) {\n      editor.execCommand('iSearch', {\n        jumpToFirstMatch: true,\n        useCurrentOrPrevSearch: true\n      });\n    },\n    readOnly: true\n  }, {\n    name: \"iSearchBackwardsAndGo\",\n    bindKey: {\n      win: \"Ctrl-Shift-K\",\n      mac: \"Command-Shift-G\"\n    },\n    exec: function exec(editor) {\n      editor.execCommand('iSearch', {\n        jumpToFirstMatch: true,\n        backwards: true,\n        useCurrentOrPrevSearch: true\n      });\n    },\n    readOnly: true\n  }];\n  exports.iSearchCommands = [{\n    name: \"restartSearch\",\n    bindKey: {\n      win: \"Ctrl-F\",\n      mac: \"Command-F\"\n    },\n    exec: function exec(iSearch) {\n      iSearch.cancelSearch(true);\n    }\n  }, {\n    name: \"searchForward\",\n    bindKey: {\n      win: \"Ctrl-S|Ctrl-K\",\n      mac: \"Ctrl-S|Command-G\"\n    },\n    exec: function exec(iSearch, options) {\n      options.useCurrentOrPrevSearch = true;\n      iSearch.next(options);\n    }\n  }, {\n    name: \"searchBackward\",\n    bindKey: {\n      win: \"Ctrl-R|Ctrl-Shift-K\",\n      mac: \"Ctrl-R|Command-Shift-G\"\n    },\n    exec: function exec(iSearch, options) {\n      options.useCurrentOrPrevSearch = true;\n      options.backwards = true;\n      iSearch.next(options);\n    }\n  }, {\n    name: \"extendSearchTerm\",\n    exec: function exec(iSearch, string) {\n      iSearch.addString(string);\n    }\n  }, {\n    name: \"extendSearchTermSpace\",\n    bindKey: \"space\",\n    exec: function exec(iSearch) {\n      iSearch.addString(' ');\n    }\n  }, {\n    name: \"shrinkSearchTerm\",\n    bindKey: \"backspace\",\n    exec: function exec(iSearch) {\n      iSearch.removeChar();\n    }\n  }, {\n    name: 'confirmSearch',\n    bindKey: 'return',\n    exec: function exec(iSearch) {\n      iSearch.deactivate();\n    }\n  }, {\n    name: 'cancelSearch',\n    bindKey: 'esc|Ctrl-G',\n    exec: function exec(iSearch) {\n      iSearch.deactivate(true);\n    }\n  }, {\n    name: 'occurisearch',\n    bindKey: 'Ctrl-O',\n    exec: function exec(iSearch) {\n      var options = oop.mixin({}, iSearch.$options);\n      iSearch.deactivate();\n      occurStartCommand.exec(iSearch.$editor, options);\n    }\n  }, {\n    name: \"yankNextWord\",\n    bindKey: \"Ctrl-w\",\n    exec: function exec(iSearch) {\n      var ed = iSearch.$editor,\n        range = ed.selection.getRangeOfMovements(function (sel) {\n          sel.moveCursorWordRight();\n        }),\n        string = ed.session.getTextRange(range);\n      iSearch.addString(string);\n    }\n  }, {\n    name: \"yankNextChar\",\n    bindKey: \"Ctrl-Alt-y\",\n    exec: function exec(iSearch) {\n      var ed = iSearch.$editor,\n        range = ed.selection.getRangeOfMovements(function (sel) {\n          sel.moveCursorRight();\n        }),\n        string = ed.session.getTextRange(range);\n      iSearch.addString(string);\n    }\n  }, {\n    name: 'recenterTopBottom',\n    bindKey: 'Ctrl-l',\n    exec: function exec(iSearch) {\n      iSearch.$editor.execCommand('recenterTopBottom');\n    }\n  }, {\n    name: 'selectAllMatches',\n    bindKey: 'Ctrl-space',\n    exec: function exec(iSearch) {\n      var ed = iSearch.$editor,\n        hl = ed.session.$isearchHighlight,\n        ranges = hl && hl.cache ? hl.cache.reduce(function (ranges, ea) {\n          return ranges.concat(ea ? ea : []);\n        }, []) : [];\n      iSearch.deactivate(false);\n      ranges.forEach(ed.selection.addRange.bind(ed.selection));\n    }\n  }, {\n    name: 'searchAsRegExp',\n    bindKey: 'Alt-r',\n    exec: function exec(iSearch) {\n      iSearch.convertNeedleToRegExp();\n    }\n  }].map(function (cmd) {\n    cmd.readOnly = true;\n    cmd.isIncrementalSearchCommand = true;\n    cmd.scrollIntoView = \"animate-cursor\";\n    return cmd;\n  });\n  function IncrementalSearchKeyboardHandler(iSearch) {\n    this.$iSearch = iSearch;\n  }\n  oop.inherits(IncrementalSearchKeyboardHandler, HashHandler);\n  (function () {\n    this.attach = function (editor) {\n      var iSearch = this.$iSearch;\n      HashHandler.call(this, exports.iSearchCommands, editor.commands.platform);\n      this.$commandExecHandler = editor.commands.on('exec', function (e) {\n        if (!e.command.isIncrementalSearchCommand) return iSearch.deactivate();\n        e.stopPropagation();\n        e.preventDefault();\n        var scrollTop = editor.session.getScrollTop();\n        var result = e.command.exec(iSearch, e.args || {});\n        editor.renderer.scrollCursorIntoView(null, 0.5);\n        editor.renderer.animateScrolling(scrollTop);\n        return result;\n      });\n    };\n    this.detach = function (editor) {\n      if (!this.$commandExecHandler) return;\n      editor.commands.off('exec', this.$commandExecHandler);\n      delete this.$commandExecHandler;\n    };\n    var handleKeyboard$super = this.handleKeyboard;\n    this.handleKeyboard = function (data, hashId, key, keyCode) {\n      if ((hashId === 1 /*ctrl*/ || hashId === 8 /*command*/) && key === 'v' || hashId === 1 /*ctrl*/ && key === 'y') return null;\n      var cmd = handleKeyboard$super.call(this, data, hashId, key, keyCode);\n      if (cmd && cmd.command) {\n        return cmd;\n      }\n      if (hashId == -1) {\n        var extendCmd = this.commands.extendSearchTerm;\n        if (extendCmd) {\n          return {\n            command: extendCmd,\n            args: key\n          };\n        }\n      }\n      return false;\n    };\n  }).call(IncrementalSearchKeyboardHandler.prototype);\n  exports.IncrementalSearchKeyboardHandler = IncrementalSearchKeyboardHandler;\n});\nace.define(\"ace/incremental_search\", [\"require\", \"exports\", \"module\", \"ace/lib/oop\", \"ace/range\", \"ace/search\", \"ace/search_highlight\", \"ace/commands/incremental_search_commands\", \"ace/lib/dom\", \"ace/commands/command_manager\", \"ace/editor\", \"ace/config\"], function (require, exports, module) {\n  \"use strict\";\n\n  var oop = require(\"./lib/oop\");\n  var Range = require(\"./range\").Range;\n  var Search = require(\"./search\").Search;\n  var SearchHighlight = require(\"./search_highlight\").SearchHighlight;\n  var iSearchCommandModule = require(\"./commands/incremental_search_commands\");\n  var ISearchKbd = iSearchCommandModule.IncrementalSearchKeyboardHandler;\n  function IncrementalSearch() {\n    this.$options = {\n      wrap: false,\n      skipCurrent: false\n    };\n    this.$keyboardHandler = new ISearchKbd(this);\n  }\n  oop.inherits(IncrementalSearch, Search);\n  function isRegExp(obj) {\n    return obj instanceof RegExp;\n  }\n  function regExpToObject(re) {\n    var string = String(re),\n      start = string.indexOf('/'),\n      flagStart = string.lastIndexOf('/');\n    return {\n      expression: string.slice(start + 1, flagStart),\n      flags: string.slice(flagStart + 1)\n    };\n  }\n  function stringToRegExp(string, flags) {\n    try {\n      return new RegExp(string, flags);\n    } catch (e) {\n      return string;\n    }\n  }\n  function objectToRegExp(obj) {\n    return stringToRegExp(obj.expression, obj.flags);\n  }\n  (function () {\n    this.activate = function (editor, backwards) {\n      this.$editor = editor;\n      this.$startPos = this.$currentPos = editor.getCursorPosition();\n      this.$options.needle = '';\n      this.$options.backwards = backwards;\n      editor.keyBinding.addKeyboardHandler(this.$keyboardHandler);\n      this.$originalEditorOnPaste = editor.onPaste;\n      editor.onPaste = this.onPaste.bind(this);\n      this.$mousedownHandler = editor.on('mousedown', this.onMouseDown.bind(this));\n      this.selectionFix(editor);\n      this.statusMessage(true);\n    };\n    this.deactivate = function (reset) {\n      this.cancelSearch(reset);\n      var editor = this.$editor;\n      editor.keyBinding.removeKeyboardHandler(this.$keyboardHandler);\n      if (this.$mousedownHandler) {\n        editor.off('mousedown', this.$mousedownHandler);\n        delete this.$mousedownHandler;\n      }\n      editor.onPaste = this.$originalEditorOnPaste;\n      this.message('');\n    };\n    this.selectionFix = function (editor) {\n      if (editor.selection.isEmpty() && !editor.session.$emacsMark) {\n        editor.clearSelection();\n      }\n    };\n    this.highlight = function (regexp) {\n      var sess = this.$editor.session,\n        hl = sess.$isearchHighlight = sess.$isearchHighlight || sess.addDynamicMarker(new SearchHighlight(null, \"ace_isearch-result\", \"text\"));\n      hl.setRegexp(regexp);\n      sess._emit(\"changeBackMarker\"); // force highlight layer redraw\n    };\n\n    this.cancelSearch = function (reset) {\n      var e = this.$editor;\n      this.$prevNeedle = this.$options.needle;\n      this.$options.needle = '';\n      if (reset) {\n        e.moveCursorToPosition(this.$startPos);\n        this.$currentPos = this.$startPos;\n      } else {\n        e.pushEmacsMark && e.pushEmacsMark(this.$startPos, false);\n      }\n      this.highlight(null);\n      return Range.fromPoints(this.$currentPos, this.$currentPos);\n    };\n    this.highlightAndFindWithNeedle = function (moveToNext, needleUpdateFunc) {\n      if (!this.$editor) return null;\n      var options = this.$options;\n      if (needleUpdateFunc) {\n        options.needle = needleUpdateFunc.call(this, options.needle || '') || '';\n      }\n      if (options.needle.length === 0) {\n        this.statusMessage(true);\n        return this.cancelSearch(true);\n      }\n      options.start = this.$currentPos;\n      var session = this.$editor.session,\n        found = this.find(session),\n        shouldSelect = this.$editor.emacsMark ? !!this.$editor.emacsMark() : !this.$editor.selection.isEmpty();\n      if (found) {\n        if (options.backwards) found = Range.fromPoints(found.end, found.start);\n        this.$editor.selection.setRange(Range.fromPoints(shouldSelect ? this.$startPos : found.end, found.end));\n        if (moveToNext) this.$currentPos = found.end;\n        this.highlight(options.re);\n      }\n      this.statusMessage(found);\n      return found;\n    };\n    this.addString = function (s) {\n      return this.highlightAndFindWithNeedle(false, function (needle) {\n        if (!isRegExp(needle)) return needle + s;\n        var reObj = regExpToObject(needle);\n        reObj.expression += s;\n        return objectToRegExp(reObj);\n      });\n    };\n    this.removeChar = function (c) {\n      return this.highlightAndFindWithNeedle(false, function (needle) {\n        if (!isRegExp(needle)) return needle.substring(0, needle.length - 1);\n        var reObj = regExpToObject(needle);\n        reObj.expression = reObj.expression.substring(0, reObj.expression.length - 1);\n        return objectToRegExp(reObj);\n      });\n    };\n    this.next = function (options) {\n      options = options || {};\n      this.$options.backwards = !!options.backwards;\n      this.$currentPos = this.$editor.getCursorPosition();\n      return this.highlightAndFindWithNeedle(true, function (needle) {\n        return options.useCurrentOrPrevSearch && needle.length === 0 ? this.$prevNeedle || '' : needle;\n      });\n    };\n    this.onMouseDown = function (evt) {\n      this.deactivate();\n      return true;\n    };\n    this.onPaste = function (text) {\n      this.addString(text);\n    };\n    this.convertNeedleToRegExp = function () {\n      return this.highlightAndFindWithNeedle(false, function (needle) {\n        return isRegExp(needle) ? needle : stringToRegExp(needle, 'ig');\n      });\n    };\n    this.convertNeedleToString = function () {\n      return this.highlightAndFindWithNeedle(false, function (needle) {\n        return isRegExp(needle) ? regExpToObject(needle).expression : needle;\n      });\n    };\n    this.statusMessage = function (found) {\n      var options = this.$options,\n        msg = '';\n      msg += options.backwards ? 'reverse-' : '';\n      msg += 'isearch: ' + options.needle;\n      msg += found ? '' : ' (not found)';\n      this.message(msg);\n    };\n    this.message = function (msg) {\n      if (this.$editor.showCommandLine) {\n        this.$editor.showCommandLine(msg);\n        this.$editor.focus();\n      }\n    };\n  }).call(IncrementalSearch.prototype);\n  exports.IncrementalSearch = IncrementalSearch;\n  var dom = require('./lib/dom');\n  dom.importCssString(\"\\n.ace_marker-layer .ace_isearch-result {\\n  position: absolute;\\n  z-index: 6;\\n  box-sizing: border-box;\\n}\\ndiv.ace_isearch-result {\\n  border-radius: 4px;\\n  background-color: rgba(255, 200, 0, 0.5);\\n  box-shadow: 0 0 4px rgb(255, 200, 0);\\n}\\n.ace_dark div.ace_isearch-result {\\n  background-color: rgb(100, 110, 160);\\n  box-shadow: 0 0 4px rgb(80, 90, 140);\\n}\", \"incremental-search-highlighting\", false);\n  var commands = require(\"./commands/command_manager\");\n  (function () {\n    this.setupIncrementalSearch = function (editor, val) {\n      if (this.usesIncrementalSearch == val) return;\n      this.usesIncrementalSearch = val;\n      var iSearchCommands = iSearchCommandModule.iSearchStartCommands;\n      var method = val ? 'addCommands' : 'removeCommands';\n      this[method](iSearchCommands);\n    };\n  }).call(commands.CommandManager.prototype);\n  var Editor = require(\"./editor\").Editor;\n  require(\"./config\").defineOptions(Editor.prototype, \"editor\", {\n    useIncrementalSearch: {\n      set: function set(val) {\n        this.keyBinding.$handlers.forEach(function (handler) {\n          if (handler.setupIncrementalSearch) {\n            handler.setupIncrementalSearch(this, val);\n          }\n        });\n        this._emit('incrementalSearchSettingChanged', {\n          isEnabled: val\n        });\n      }\n    }\n  });\n});\nace.define(\"ace/keyboard/emacs\", [\"require\", \"exports\", \"module\", \"ace/lib/dom\", \"ace/incremental_search\", \"ace/commands/incremental_search_commands\", \"ace/keyboard/hash_handler\", \"ace/lib/keys\"], function (require, exports, module) {\n  \"use strict\";\n\n  var dom = require(\"../lib/dom\");\n  require(\"../incremental_search\");\n  var iSearchCommandModule = require(\"../commands/incremental_search_commands\");\n  var HashHandler = require(\"./hash_handler\").HashHandler;\n  exports.handler = new HashHandler();\n  exports.handler.isEmacs = true;\n  exports.handler.$id = \"ace/keyboard/emacs\";\n  dom.importCssString(\"\\n.emacs-mode .ace_cursor{\\n    border: 1px rgba(50,250,50,0.8) solid!important;\\n    box-sizing: border-box!important;\\n    background-color: rgba(0,250,0,0.9);\\n    opacity: 0.5;\\n}\\n.emacs-mode .ace_hidden-cursors .ace_cursor{\\n    opacity: 1;\\n    background-color: transparent;\\n}\\n.emacs-mode .ace_overwrite-cursors .ace_cursor {\\n    opacity: 1;\\n    background-color: transparent;\\n    border-width: 0 0 2px 2px !important;\\n}\\n.emacs-mode .ace_text-layer {\\n    z-index: 4\\n}\\n.emacs-mode .ace_cursor-layer {\\n    z-index: 2\\n}\", 'emacsMode');\n  var $formerLongWords;\n  var $formerLineStart;\n  exports.handler.attach = function (editor) {\n    $formerLongWords = editor.session.$selectLongWords;\n    editor.session.$selectLongWords = true;\n    $formerLineStart = editor.session.$useEmacsStyleLineStart;\n    editor.session.$useEmacsStyleLineStart = true;\n    editor.session.$emacsMark = null; // the active mark\n    editor.session.$emacsMarkRing = editor.session.$emacsMarkRing || [];\n    editor.emacsMark = function () {\n      return this.session.$emacsMark;\n    };\n    editor.setEmacsMark = function (p) {\n      this.session.$emacsMark = p;\n    };\n    editor.pushEmacsMark = function (p, activate) {\n      var prevMark = this.session.$emacsMark;\n      if (prevMark) this.session.$emacsMarkRing.push(prevMark);\n      if (!p || activate) this.setEmacsMark(p);else this.session.$emacsMarkRing.push(p);\n    };\n    editor.popEmacsMark = function () {\n      var mark = this.emacsMark();\n      if (mark) {\n        this.setEmacsMark(null);\n        return mark;\n      }\n      return this.session.$emacsMarkRing.pop();\n    };\n    editor.getLastEmacsMark = function (p) {\n      return this.session.$emacsMark || this.session.$emacsMarkRing.slice(-1)[0];\n    };\n    editor.emacsMarkForSelection = function (replacement) {\n      var sel = this.selection,\n        multiRangeLength = this.multiSelect ? this.multiSelect.getAllRanges().length : 1,\n        selIndex = sel.index || 0,\n        markRing = this.session.$emacsMarkRing,\n        markIndex = markRing.length - (multiRangeLength - selIndex),\n        lastMark = markRing[markIndex] || sel.anchor;\n      if (replacement) {\n        markRing.splice(markIndex, 1, \"row\" in replacement && \"column\" in replacement ? replacement : undefined);\n      }\n      return lastMark;\n    };\n    editor.on(\"click\", $resetMarkMode);\n    editor.on(\"changeSession\", $kbSessionChange);\n    editor.renderer.$blockCursor = true;\n    editor.setStyle(\"emacs-mode\");\n    editor.commands.addCommands(commands);\n    exports.handler.platform = editor.commands.platform;\n    editor.$emacsModeHandler = this;\n    editor.on('copy', this.onCopy);\n    editor.on('paste', this.onPaste);\n  };\n  exports.handler.detach = function (editor) {\n    editor.renderer.$blockCursor = false;\n    editor.session.$selectLongWords = $formerLongWords;\n    editor.session.$useEmacsStyleLineStart = $formerLineStart;\n    editor.off(\"click\", $resetMarkMode);\n    editor.off(\"changeSession\", $kbSessionChange);\n    editor.unsetStyle(\"emacs-mode\");\n    editor.commands.removeCommands(commands);\n    editor.off('copy', this.onCopy);\n    editor.off('paste', this.onPaste);\n    editor.$emacsModeHandler = null;\n  };\n  var $kbSessionChange = function $kbSessionChange(e) {\n    if (e.oldSession) {\n      e.oldSession.$selectLongWords = $formerLongWords;\n      e.oldSession.$useEmacsStyleLineStart = $formerLineStart;\n    }\n    $formerLongWords = e.session.$selectLongWords;\n    e.session.$selectLongWords = true;\n    $formerLineStart = e.session.$useEmacsStyleLineStart;\n    e.session.$useEmacsStyleLineStart = true;\n    if (!e.session.hasOwnProperty('$emacsMark')) e.session.$emacsMark = null;\n    if (!e.session.hasOwnProperty('$emacsMarkRing')) e.session.$emacsMarkRing = [];\n  };\n  var $resetMarkMode = function $resetMarkMode(e) {\n    e.editor.session.$emacsMark = null;\n  };\n  var keys = require(\"../lib/keys\").KEY_MODS;\n  var eMods = {\n    C: \"ctrl\",\n    S: \"shift\",\n    M: \"alt\",\n    CMD: \"command\"\n  };\n  var combinations = [\"C-S-M-CMD\", \"S-M-CMD\", \"C-M-CMD\", \"C-S-CMD\", \"C-S-M\", \"M-CMD\", \"S-CMD\", \"S-M\", \"C-CMD\", \"C-M\", \"C-S\", \"CMD\", \"M\", \"S\", \"C\"];\n  combinations.forEach(function (c) {\n    var hashId = 0;\n    c.split(\"-\").forEach(function (c) {\n      hashId = hashId | keys[eMods[c]];\n    });\n    eMods[hashId] = c.toLowerCase() + \"-\";\n  });\n  exports.handler.onCopy = function (e, editor) {\n    if (editor.$handlesEmacsOnCopy) return;\n    editor.$handlesEmacsOnCopy = true;\n    exports.handler.commands.killRingSave.exec(editor);\n    editor.$handlesEmacsOnCopy = false;\n  };\n  exports.handler.onPaste = function (e, editor) {\n    editor.pushEmacsMark(editor.getCursorPosition());\n  };\n  exports.handler.bindKey = function (key, command) {\n    if (typeof key == \"object\") key = key[this.platform];\n    if (!key) return;\n    var ckb = this.commandKeyBinding;\n    key.split(\"|\").forEach(function (keyPart) {\n      keyPart = keyPart.toLowerCase();\n      ckb[keyPart] = command;\n      var keyParts = keyPart.split(\" \").slice(0, -1);\n      keyParts.reduce(function (keyMapKeys, keyPart, i) {\n        var prefix = keyMapKeys[i - 1] ? keyMapKeys[i - 1] + ' ' : '';\n        return keyMapKeys.concat([prefix + keyPart]);\n      }, []).forEach(function (keyPart) {\n        if (!ckb[keyPart]) ckb[keyPart] = \"null\";\n      });\n    }, this);\n  };\n  exports.handler.getStatusText = function (editor, data) {\n    var str = \"\";\n    if (data.count) str += data.count;\n    if (data.keyChain) str += \" \" + data.keyChain;\n    return str;\n  };\n  exports.handler.handleKeyboard = function (data, hashId, key, keyCode) {\n    if (keyCode === -1) return undefined;\n    var editor = data.editor;\n    editor._signal(\"changeStatus\");\n    if (hashId == -1) {\n      editor.pushEmacsMark();\n      if (data.count) {\n        var str = new Array(data.count + 1).join(key);\n        data.count = null;\n        return {\n          command: \"insertstring\",\n          args: str\n        };\n      }\n    }\n    var modifier = eMods[hashId];\n    if (modifier == \"c-\" || data.count) {\n      var count = parseInt(key[key.length - 1]);\n      if (typeof count === 'number' && !isNaN(count)) {\n        data.count = Math.max(data.count, 0) || 0;\n        data.count = 10 * data.count + count;\n        return {\n          command: \"null\"\n        };\n      }\n    }\n    if (modifier) key = modifier + key;\n    if (data.keyChain) key = data.keyChain += \" \" + key;\n    var command = this.commandKeyBinding[key];\n    data.keyChain = command == \"null\" ? key : \"\";\n    if (!command) return undefined;\n    if (command === \"null\") return {\n      command: \"null\"\n    };\n    if (command === \"universalArgument\") {\n      data.count = -4;\n      return {\n        command: \"null\"\n      };\n    }\n    var args;\n    if (typeof command !== \"string\") {\n      args = command.args;\n      if (command.command) command = command.command;\n      if (command === \"goorselect\") {\n        command = editor.emacsMark() ? args[1] : args[0];\n        args = null;\n      }\n    }\n    if (typeof command === \"string\") {\n      if (command === \"insertstring\" || command === \"splitline\" || command === \"togglecomment\") {\n        editor.pushEmacsMark();\n      }\n      command = this.commands[command] || editor.commands.commands[command];\n      if (!command) return undefined;\n    }\n    if (!command.readOnly && !command.isYank) data.lastCommand = null;\n    if (!command.readOnly && editor.emacsMark()) editor.setEmacsMark(null);\n    if (data.count) {\n      var count = data.count;\n      data.count = 0;\n      if (!command || !command.handlesCount) {\n        return {\n          args: args,\n          command: {\n            exec: function exec(editor, args) {\n              for (var i = 0; i < count; i++) command.exec(editor, args);\n            },\n            multiSelectAction: command.multiSelectAction\n          }\n        };\n      } else {\n        if (!args) args = {};\n        if (typeof args === 'object') args.count = count;\n      }\n    }\n    return {\n      command: command,\n      args: args\n    };\n  };\n  exports.emacsKeys = {\n    \"Up|C-p\": {\n      command: \"goorselect\",\n      args: [\"golineup\", \"selectup\"]\n    },\n    \"Down|C-n\": {\n      command: \"goorselect\",\n      args: [\"golinedown\", \"selectdown\"]\n    },\n    \"Left|C-b\": {\n      command: \"goorselect\",\n      args: [\"gotoleft\", \"selectleft\"]\n    },\n    \"Right|C-f\": {\n      command: \"goorselect\",\n      args: [\"gotoright\", \"selectright\"]\n    },\n    \"C-Left|M-b\": {\n      command: \"goorselect\",\n      args: [\"gotowordleft\", \"selectwordleft\"]\n    },\n    \"C-Right|M-f\": {\n      command: \"goorselect\",\n      args: [\"gotowordright\", \"selectwordright\"]\n    },\n    \"Home|C-a\": {\n      command: \"goorselect\",\n      args: [\"gotolinestart\", \"selecttolinestart\"]\n    },\n    \"End|C-e\": {\n      command: \"goorselect\",\n      args: [\"gotolineend\", \"selecttolineend\"]\n    },\n    \"C-Home|S-M-,\": {\n      command: \"goorselect\",\n      args: [\"gotostart\", \"selecttostart\"]\n    },\n    \"C-End|S-M-.\": {\n      command: \"goorselect\",\n      args: [\"gotoend\", \"selecttoend\"]\n    },\n    \"S-Up|S-C-p\": \"selectup\",\n    \"S-Down|S-C-n\": \"selectdown\",\n    \"S-Left|S-C-b\": \"selectleft\",\n    \"S-Right|S-C-f\": \"selectright\",\n    \"S-C-Left|S-M-b\": \"selectwordleft\",\n    \"S-C-Right|S-M-f\": \"selectwordright\",\n    \"S-Home|S-C-a\": \"selecttolinestart\",\n    \"S-End|S-C-e\": \"selecttolineend\",\n    \"S-C-Home\": \"selecttostart\",\n    \"S-C-End\": \"selecttoend\",\n    \"C-l\": \"recenterTopBottom\",\n    \"M-s\": \"centerselection\",\n    \"M-g\": \"gotoline\",\n    \"C-x C-p\": \"selectall\",\n    \"C-Down\": {\n      command: \"goorselect\",\n      args: [\"gotopagedown\", \"selectpagedown\"]\n    },\n    \"C-Up\": {\n      command: \"goorselect\",\n      args: [\"gotopageup\", \"selectpageup\"]\n    },\n    \"PageDown|C-v\": {\n      command: \"goorselect\",\n      args: [\"gotopagedown\", \"selectpagedown\"]\n    },\n    \"PageUp|M-v\": {\n      command: \"goorselect\",\n      args: [\"gotopageup\", \"selectpageup\"]\n    },\n    \"S-C-Down\": \"selectpagedown\",\n    \"S-C-Up\": \"selectpageup\",\n    \"C-s\": \"iSearch\",\n    \"C-r\": \"iSearchBackwards\",\n    \"M-C-s\": \"findnext\",\n    \"M-C-r\": \"findprevious\",\n    \"S-M-5\": \"replace\",\n    \"Backspace\": \"backspace\",\n    \"Delete|C-d\": \"del\",\n    \"Return|C-m\": {\n      command: \"insertstring\",\n      args: \"\\n\"\n    },\n    \"C-o\": \"splitline\",\n    \"M-d|C-Delete\": {\n      command: \"killWord\",\n      args: \"right\"\n    },\n    \"C-Backspace|M-Backspace|M-Delete\": {\n      command: \"killWord\",\n      args: \"left\"\n    },\n    \"C-k\": \"killLine\",\n    \"C-y|S-Delete\": \"yank\",\n    \"M-y\": \"yankRotate\",\n    \"C-g\": \"keyboardQuit\",\n    \"C-w|C-S-W\": \"killRegion\",\n    \"M-w\": \"killRingSave\",\n    \"C-Space\": \"setMark\",\n    \"C-x C-x\": \"exchangePointAndMark\",\n    \"C-t\": \"transposeletters\",\n    \"M-u\": \"touppercase\",\n    \"M-l\": \"tolowercase\",\n    \"M-/\": \"autocomplete\",\n    \"C-u\": \"universalArgument\",\n    \"M-;\": \"togglecomment\",\n    \"C-/|C-x u|S-C--|C-z\": \"undo\",\n    \"S-C-/|S-C-x u|C--|S-C-z\": \"redo\",\n    \"C-x r\": \"selectRectangularRegion\",\n    \"M-x\": {\n      command: \"focusCommandLine\",\n      args: \"M-x \"\n    }\n  };\n  exports.handler.bindKeys(exports.emacsKeys);\n  exports.handler.addCommands({\n    recenterTopBottom: function recenterTopBottom(editor) {\n      var renderer = editor.renderer;\n      var pos = renderer.$cursorLayer.getPixelPosition();\n      var h = renderer.$size.scrollerHeight - renderer.lineHeight;\n      var scrollTop = renderer.scrollTop;\n      if (Math.abs(pos.top - scrollTop) < 2) {\n        scrollTop = pos.top - h;\n      } else if (Math.abs(pos.top - scrollTop - h * 0.5) < 2) {\n        scrollTop = pos.top;\n      } else {\n        scrollTop = pos.top - h * 0.5;\n      }\n      editor.session.setScrollTop(scrollTop);\n    },\n    selectRectangularRegion: function selectRectangularRegion(editor) {\n      editor.multiSelect.toggleBlockSelection();\n    },\n    setMark: {\n      exec: function exec(editor, args) {\n        if (args && args.count) {\n          if (editor.inMultiSelectMode) editor.forEachSelection(moveToMark);else moveToMark();\n          moveToMark();\n          return;\n        }\n        var mark = editor.emacsMark(),\n          ranges = editor.selection.getAllRanges(),\n          rangePositions = ranges.map(function (r) {\n            return {\n              row: r.start.row,\n              column: r.start.column\n            };\n          }),\n          transientMarkModeActive = true,\n          hasNoSelection = ranges.every(function (range) {\n            return range.isEmpty();\n          });\n        if (transientMarkModeActive && (mark || !hasNoSelection)) {\n          if (editor.inMultiSelectMode) editor.forEachSelection({\n            exec: editor.clearSelection.bind(editor)\n          });else editor.clearSelection();\n          if (mark) editor.pushEmacsMark(null);\n          return;\n        }\n        if (!mark) {\n          rangePositions.forEach(function (pos) {\n            editor.pushEmacsMark(pos);\n          });\n          editor.setEmacsMark(rangePositions[rangePositions.length - 1]);\n          return;\n        }\n        function moveToMark() {\n          var mark = editor.popEmacsMark();\n          mark && editor.moveCursorToPosition(mark);\n        }\n      },\n      readOnly: true,\n      handlesCount: true\n    },\n    exchangePointAndMark: {\n      exec: function exchangePointAndMark$exec(editor, args) {\n        var sel = editor.selection;\n        if (!args.count && !sel.isEmpty()) {\n          // just invert selection\n          sel.setSelectionRange(sel.getRange(), !sel.isBackwards());\n          return;\n        }\n        if (args.count) {\n          // replace mark and point\n          var pos = {\n            row: sel.lead.row,\n            column: sel.lead.column\n          };\n          sel.clearSelection();\n          sel.moveCursorToPosition(editor.emacsMarkForSelection(pos));\n        } else {\n          // create selection to last mark\n          sel.selectToPosition(editor.emacsMarkForSelection());\n        }\n      },\n      readOnly: true,\n      handlesCount: true,\n      multiSelectAction: \"forEach\"\n    },\n    killWord: {\n      exec: function exec(editor, dir) {\n        editor.clearSelection();\n        if (dir == \"left\") editor.selection.selectWordLeft();else editor.selection.selectWordRight();\n        var range = editor.getSelectionRange();\n        var text = editor.session.getTextRange(range);\n        exports.killRing.add(text);\n        editor.session.remove(range);\n        editor.clearSelection();\n      },\n      multiSelectAction: \"forEach\"\n    },\n    killLine: function killLine(editor) {\n      editor.pushEmacsMark(null);\n      editor.clearSelection();\n      var range = editor.getSelectionRange();\n      var line = editor.session.getLine(range.start.row);\n      range.end.column = line.length;\n      line = line.substr(range.start.column);\n      var foldLine = editor.session.getFoldLine(range.start.row);\n      if (foldLine && range.end.row != foldLine.end.row) {\n        range.end.row = foldLine.end.row;\n        line = \"x\";\n      }\n      if (/^\\s*$/.test(line)) {\n        range.end.row++;\n        line = editor.session.getLine(range.end.row);\n        range.end.column = /^\\s*$/.test(line) ? line.length : 0;\n      }\n      var text = editor.session.getTextRange(range);\n      if (editor.prevOp.command == this) exports.killRing.append(text);else exports.killRing.add(text);\n      editor.session.remove(range);\n      editor.clearSelection();\n    },\n    yank: function yank(editor) {\n      editor.onPaste(exports.killRing.get() || '');\n      editor.keyBinding.$data.lastCommand = \"yank\";\n    },\n    yankRotate: function yankRotate(editor) {\n      if (editor.keyBinding.$data.lastCommand != \"yank\") return;\n      editor.undo();\n      editor.session.$emacsMarkRing.pop(); // also undo recording mark\n      editor.onPaste(exports.killRing.rotate());\n      editor.keyBinding.$data.lastCommand = \"yank\";\n    },\n    killRegion: {\n      exec: function exec(editor) {\n        exports.killRing.add(editor.getCopyText());\n        editor.commands.byName.cut.exec(editor);\n        editor.setEmacsMark(null);\n      },\n      readOnly: true,\n      multiSelectAction: \"forEach\"\n    },\n    killRingSave: {\n      exec: function exec(editor) {\n        editor.$handlesEmacsOnCopy = true;\n        var marks = editor.session.$emacsMarkRing.slice(),\n          deselectedMarks = [];\n        exports.killRing.add(editor.getCopyText());\n        setTimeout(function () {\n          function deselect() {\n            var sel = editor.selection,\n              range = sel.getRange(),\n              pos = sel.isBackwards() ? range.end : range.start;\n            deselectedMarks.push({\n              row: pos.row,\n              column: pos.column\n            });\n            sel.clearSelection();\n          }\n          editor.$handlesEmacsOnCopy = false;\n          if (editor.inMultiSelectMode) editor.forEachSelection({\n            exec: deselect\n          });else deselect();\n          editor.setEmacsMark(null);\n          editor.session.$emacsMarkRing = marks.concat(deselectedMarks.reverse());\n        }, 0);\n      },\n      readOnly: true\n    },\n    keyboardQuit: function keyboardQuit(editor) {\n      editor.selection.clearSelection();\n      editor.setEmacsMark(null);\n      editor.keyBinding.$data.count = null;\n    },\n    focusCommandLine: function focusCommandLine(editor, arg) {\n      if (editor.showCommandLine) editor.showCommandLine(arg);\n    }\n  });\n  exports.handler.addCommands(iSearchCommandModule.iSearchStartCommands);\n  var commands = exports.handler.commands;\n  commands.yank.isYank = true;\n  commands.yankRotate.isYank = true;\n  exports.killRing = {\n    $data: [],\n    add: function add(str) {\n      str && this.$data.push(str);\n      if (this.$data.length > 30) this.$data.shift();\n    },\n    append: function append(str) {\n      var idx = this.$data.length - 1;\n      var text = this.$data[idx] || \"\";\n      if (str) text += str;\n      if (text) this.$data[idx] = text;\n    },\n    get: function get(n) {\n      n = n || 1;\n      return this.$data.slice(this.$data.length - n, this.$data.length).reverse().join('\\n');\n    },\n    pop: function pop() {\n      if (this.$data.length > 1) this.$data.pop();\n      return this.get();\n    },\n    rotate: function rotate() {\n      this.$data.unshift(this.$data.pop());\n      return this.get();\n    }\n  };\n});\n(function () {\n  ace.require([\"ace/keyboard/emacs\"], function (m) {\n    if (typeof module == \"object\" && typeof exports == \"object\" && module) {\n      module.exports = m;\n    }\n  });\n})();","map":null,"metadata":{},"sourceType":"script"}