{"ast":null,"code":"\"no use strict\";\n\n!function (window) {\n  if (typeof window.window != \"undefined\" && window.document) return;\n  if (window.require && window.define) return;\n  if (!window.console) {\n    window.console = function () {\n      var msgs = Array.prototype.slice.call(arguments, 0);\n      postMessage({\n        type: \"log\",\n        data: msgs\n      });\n    };\n    window.console.error = window.console.warn = window.console.log = window.console.trace = window.console;\n  }\n  window.window = window;\n  window.ace = window;\n  window.onerror = function (message, file, line, col, err) {\n    postMessage({\n      type: \"error\",\n      data: {\n        message: message,\n        data: err && err.data,\n        file: file,\n        line: line,\n        col: col,\n        stack: err && err.stack\n      }\n    });\n  };\n  window.normalizeModule = function (parentId, moduleName) {\n    // normalize plugin requires\n    if (moduleName.indexOf(\"!\") !== -1) {\n      var chunks = moduleName.split(\"!\");\n      return window.normalizeModule(parentId, chunks[0]) + \"!\" + window.normalizeModule(parentId, chunks[1]);\n    }\n    // normalize relative requires\n    if (moduleName.charAt(0) == \".\") {\n      var base = parentId.split(\"/\").slice(0, -1).join(\"/\");\n      moduleName = (base ? base + \"/\" : \"\") + moduleName;\n      while (moduleName.indexOf(\".\") !== -1 && previous != moduleName) {\n        var previous = moduleName;\n        moduleName = moduleName.replace(/^\\.\\//, \"\").replace(/\\/\\.\\//, \"/\").replace(/[^\\/]+\\/\\.\\.\\//, \"\");\n      }\n    }\n    return moduleName;\n  };\n  window.require = function require(parentId, id) {\n    if (!id) {\n      id = parentId;\n      parentId = null;\n    }\n    if (!id.charAt) throw new Error(\"worker.js require() accepts only (parentId, id) as arguments\");\n    id = window.normalizeModule(parentId, id);\n    var module = window.require.modules[id];\n    if (module) {\n      if (!module.initialized) {\n        module.initialized = true;\n        module.exports = module.factory().exports;\n      }\n      return module.exports;\n    }\n    if (!window.require.tlns) return console.log(\"unable to load \" + id);\n    var path = resolveModuleId(id, window.require.tlns);\n    if (path.slice(-3) != \".js\") path += \".js\";\n    window.require.id = id;\n    window.require.modules[id] = {}; // prevent infinite loop on broken modules\n    importScripts(path);\n    return window.require(parentId, id);\n  };\n  function resolveModuleId(id, paths) {\n    var testPath = id,\n      tail = \"\";\n    while (testPath) {\n      var alias = paths[testPath];\n      if (typeof alias == \"string\") {\n        return alias + tail;\n      } else if (alias) {\n        return alias.location.replace(/\\/*$/, \"/\") + (tail || alias.main || alias.name);\n      } else if (alias === false) {\n        return \"\";\n      }\n      var i = testPath.lastIndexOf(\"/\");\n      if (i === -1) break;\n      tail = testPath.substr(i) + tail;\n      testPath = testPath.slice(0, i);\n    }\n    return id;\n  }\n  window.require.modules = {};\n  window.require.tlns = {};\n  window.define = function (id, deps, _factory) {\n    if (arguments.length == 2) {\n      _factory = deps;\n      if (typeof id != \"string\") {\n        deps = id;\n        id = window.require.id;\n      }\n    } else if (arguments.length == 1) {\n      _factory = id;\n      deps = [];\n      id = window.require.id;\n    }\n    if (typeof _factory != \"function\") {\n      window.require.modules[id] = {\n        exports: _factory,\n        initialized: true\n      };\n      return;\n    }\n    if (!deps.length)\n      // If there is no dependencies, we inject \"require\", \"exports\" and\n      // \"module\" as dependencies, to provide CommonJS compatibility.\n      deps = [\"require\", \"exports\", \"module\"];\n    var req = function req(childId) {\n      return window.require(id, childId);\n    };\n    window.require.modules[id] = {\n      exports: {},\n      factory: function factory() {\n        var module = this;\n        var returnExports = _factory.apply(this, deps.slice(0, _factory.length).map(function (dep) {\n          switch (dep) {\n            // Because \"require\", \"exports\" and \"module\" aren't actual\n            // dependencies, we must handle them seperately.\n            case \"require\":\n              return req;\n            case \"exports\":\n              return module.exports;\n            case \"module\":\n              return module;\n            // But for all other dependencies, we can just go ahead and\n            // require them.\n            default:\n              return req(dep);\n          }\n        }));\n        if (returnExports) module.exports = returnExports;\n        return module;\n      }\n    };\n  };\n  window.define.amd = {};\n  window.require.tlns = {};\n  window.initBaseUrls = function initBaseUrls(topLevelNamespaces) {\n    for (var i in topLevelNamespaces) this.require.tlns[i] = topLevelNamespaces[i];\n  };\n  window.initSender = function initSender() {\n    var EventEmitter = window.require(\"ace/lib/event_emitter\").EventEmitter;\n    var oop = window.require(\"ace/lib/oop\");\n    var Sender = function Sender() {};\n    (function () {\n      oop.implement(this, EventEmitter);\n      this.callback = function (data, callbackId) {\n        postMessage({\n          type: \"call\",\n          id: callbackId,\n          data: data\n        });\n      };\n      this.emit = function (name, data) {\n        postMessage({\n          type: \"event\",\n          name: name,\n          data: data\n        });\n      };\n    }).call(Sender.prototype);\n    return new Sender();\n  };\n  var main = window.main = null;\n  var sender = window.sender = null;\n  window.onmessage = function (e) {\n    var msg = e.data;\n    if (msg.event && sender) {\n      sender._signal(msg.event, msg.data);\n    } else if (msg.command) {\n      if (main[msg.command]) main[msg.command].apply(main, msg.args);else if (window[msg.command]) window[msg.command].apply(window, msg.args);else throw new Error(\"Unknown command:\" + msg.command);\n    } else if (msg.init) {\n      window.initBaseUrls(msg.tlns);\n      sender = window.sender = window.initSender();\n      var clazz = this.require(msg.module)[msg.classname];\n      main = window.main = new clazz(sender);\n    }\n  };\n}(this);\nace.define(\"ace/lib/oop\", [], function (require, exports, module) {\n  \"use strict\";\n\n  exports.inherits = function (ctor, superCtor) {\n    ctor.super_ = superCtor;\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n  exports.mixin = function (obj, mixin) {\n    for (var key in mixin) {\n      obj[key] = mixin[key];\n    }\n    return obj;\n  };\n  exports.implement = function (proto, mixin) {\n    exports.mixin(proto, mixin);\n  };\n});\nace.define(\"ace/apply_delta\", [], function (require, exports, module) {\n  \"use strict\";\n\n  function throwDeltaError(delta, errorText) {\n    console.log(\"Invalid Delta:\", delta);\n    throw \"Invalid Delta: \" + errorText;\n  }\n  function positionInDocument(docLines, position) {\n    return position.row >= 0 && position.row < docLines.length && position.column >= 0 && position.column <= docLines[position.row].length;\n  }\n  function validateDelta(docLines, delta) {\n    if (delta.action != \"insert\" && delta.action != \"remove\") throwDeltaError(delta, \"delta.action must be 'insert' or 'remove'\");\n    if (!(delta.lines instanceof Array)) throwDeltaError(delta, \"delta.lines must be an Array\");\n    if (!delta.start || !delta.end) throwDeltaError(delta, \"delta.start/end must be an present\");\n    var start = delta.start;\n    if (!positionInDocument(docLines, delta.start)) throwDeltaError(delta, \"delta.start must be contained in document\");\n    var end = delta.end;\n    if (delta.action == \"remove\" && !positionInDocument(docLines, end)) throwDeltaError(delta, \"delta.end must contained in document for 'remove' actions\");\n    var numRangeRows = end.row - start.row;\n    var numRangeLastLineChars = end.column - (numRangeRows == 0 ? start.column : 0);\n    if (numRangeRows != delta.lines.length - 1 || delta.lines[numRangeRows].length != numRangeLastLineChars) throwDeltaError(delta, \"delta.range must match delta lines\");\n  }\n  exports.applyDelta = function (docLines, delta, doNotValidate) {\n    var row = delta.start.row;\n    var startColumn = delta.start.column;\n    var line = docLines[row] || \"\";\n    switch (delta.action) {\n      case \"insert\":\n        var lines = delta.lines;\n        if (lines.length === 1) {\n          docLines[row] = line.substring(0, startColumn) + delta.lines[0] + line.substring(startColumn);\n        } else {\n          var args = [row, 1].concat(delta.lines);\n          docLines.splice.apply(docLines, args);\n          docLines[row] = line.substring(0, startColumn) + docLines[row];\n          docLines[row + delta.lines.length - 1] += line.substring(startColumn);\n        }\n        break;\n      case \"remove\":\n        var endColumn = delta.end.column;\n        var endRow = delta.end.row;\n        if (row === endRow) {\n          docLines[row] = line.substring(0, startColumn) + line.substring(endColumn);\n        } else {\n          docLines.splice(row, endRow - row + 1, line.substring(0, startColumn) + docLines[endRow].substring(endColumn));\n        }\n        break;\n    }\n  };\n});\nace.define(\"ace/lib/event_emitter\", [], function (require, exports, module) {\n  \"use strict\";\n\n  var EventEmitter = {};\n  var stopPropagation = function stopPropagation() {\n    this.propagationStopped = true;\n  };\n  var preventDefault = function preventDefault() {\n    this.defaultPrevented = true;\n  };\n  EventEmitter._emit = EventEmitter._dispatchEvent = function (eventName, e) {\n    this._eventRegistry || (this._eventRegistry = {});\n    this._defaultHandlers || (this._defaultHandlers = {});\n    var listeners = this._eventRegistry[eventName] || [];\n    var defaultHandler = this._defaultHandlers[eventName];\n    if (!listeners.length && !defaultHandler) return;\n    if (typeof e != \"object\" || !e) e = {};\n    if (!e.type) e.type = eventName;\n    if (!e.stopPropagation) e.stopPropagation = stopPropagation;\n    if (!e.preventDefault) e.preventDefault = preventDefault;\n    listeners = listeners.slice();\n    for (var i = 0; i < listeners.length; i++) {\n      listeners[i](e, this);\n      if (e.propagationStopped) break;\n    }\n    if (defaultHandler && !e.defaultPrevented) return defaultHandler(e, this);\n  };\n  EventEmitter._signal = function (eventName, e) {\n    var listeners = (this._eventRegistry || {})[eventName];\n    if (!listeners) return;\n    listeners = listeners.slice();\n    for (var i = 0; i < listeners.length; i++) listeners[i](e, this);\n  };\n  EventEmitter.once = function (eventName, callback) {\n    var _self = this;\n    this.on(eventName, function newCallback() {\n      _self.off(eventName, newCallback);\n      callback.apply(null, arguments);\n    });\n    if (!callback) {\n      return new Promise(function (resolve) {\n        callback = resolve;\n      });\n    }\n  };\n  EventEmitter.setDefaultHandler = function (eventName, callback) {\n    var handlers = this._defaultHandlers;\n    if (!handlers) handlers = this._defaultHandlers = {\n      _disabled_: {}\n    };\n    if (handlers[eventName]) {\n      var old = handlers[eventName];\n      var disabled = handlers._disabled_[eventName];\n      if (!disabled) handlers._disabled_[eventName] = disabled = [];\n      disabled.push(old);\n      var i = disabled.indexOf(callback);\n      if (i != -1) disabled.splice(i, 1);\n    }\n    handlers[eventName] = callback;\n  };\n  EventEmitter.removeDefaultHandler = function (eventName, callback) {\n    var handlers = this._defaultHandlers;\n    if (!handlers) return;\n    var disabled = handlers._disabled_[eventName];\n    if (handlers[eventName] == callback) {\n      if (disabled) this.setDefaultHandler(eventName, disabled.pop());\n    } else if (disabled) {\n      var i = disabled.indexOf(callback);\n      if (i != -1) disabled.splice(i, 1);\n    }\n  };\n  EventEmitter.on = EventEmitter.addEventListener = function (eventName, callback, capturing) {\n    this._eventRegistry = this._eventRegistry || {};\n    var listeners = this._eventRegistry[eventName];\n    if (!listeners) listeners = this._eventRegistry[eventName] = [];\n    if (listeners.indexOf(callback) == -1) listeners[capturing ? \"unshift\" : \"push\"](callback);\n    return callback;\n  };\n  EventEmitter.off = EventEmitter.removeListener = EventEmitter.removeEventListener = function (eventName, callback) {\n    this._eventRegistry = this._eventRegistry || {};\n    var listeners = this._eventRegistry[eventName];\n    if (!listeners) return;\n    var index = listeners.indexOf(callback);\n    if (index !== -1) listeners.splice(index, 1);\n  };\n  EventEmitter.removeAllListeners = function (eventName) {\n    if (!eventName) this._eventRegistry = this._defaultHandlers = undefined;\n    if (this._eventRegistry) this._eventRegistry[eventName] = undefined;\n    if (this._defaultHandlers) this._defaultHandlers[eventName] = undefined;\n  };\n  exports.EventEmitter = EventEmitter;\n});\nace.define(\"ace/range\", [], function (require, exports, module) {\n  \"use strict\";\n\n  var comparePoints = function comparePoints(p1, p2) {\n    return p1.row - p2.row || p1.column - p2.column;\n  };\n  var Range = function Range(startRow, startColumn, endRow, endColumn) {\n    this.start = {\n      row: startRow,\n      column: startColumn\n    };\n    this.end = {\n      row: endRow,\n      column: endColumn\n    };\n  };\n  (function () {\n    this.isEqual = function (range) {\n      return this.start.row === range.start.row && this.end.row === range.end.row && this.start.column === range.start.column && this.end.column === range.end.column;\n    };\n    this.toString = function () {\n      return \"Range: [\" + this.start.row + \"/\" + this.start.column + \"] -> [\" + this.end.row + \"/\" + this.end.column + \"]\";\n    };\n    this.contains = function (row, column) {\n      return this.compare(row, column) == 0;\n    };\n    this.compareRange = function (range) {\n      var cmp,\n        end = range.end,\n        start = range.start;\n      cmp = this.compare(end.row, end.column);\n      if (cmp == 1) {\n        cmp = this.compare(start.row, start.column);\n        if (cmp == 1) {\n          return 2;\n        } else if (cmp == 0) {\n          return 1;\n        } else {\n          return 0;\n        }\n      } else if (cmp == -1) {\n        return -2;\n      } else {\n        cmp = this.compare(start.row, start.column);\n        if (cmp == -1) {\n          return -1;\n        } else if (cmp == 1) {\n          return 42;\n        } else {\n          return 0;\n        }\n      }\n    };\n    this.comparePoint = function (p) {\n      return this.compare(p.row, p.column);\n    };\n    this.containsRange = function (range) {\n      return this.comparePoint(range.start) == 0 && this.comparePoint(range.end) == 0;\n    };\n    this.intersects = function (range) {\n      var cmp = this.compareRange(range);\n      return cmp == -1 || cmp == 0 || cmp == 1;\n    };\n    this.isEnd = function (row, column) {\n      return this.end.row == row && this.end.column == column;\n    };\n    this.isStart = function (row, column) {\n      return this.start.row == row && this.start.column == column;\n    };\n    this.setStart = function (row, column) {\n      if (typeof row == \"object\") {\n        this.start.column = row.column;\n        this.start.row = row.row;\n      } else {\n        this.start.row = row;\n        this.start.column = column;\n      }\n    };\n    this.setEnd = function (row, column) {\n      if (typeof row == \"object\") {\n        this.end.column = row.column;\n        this.end.row = row.row;\n      } else {\n        this.end.row = row;\n        this.end.column = column;\n      }\n    };\n    this.inside = function (row, column) {\n      if (this.compare(row, column) == 0) {\n        if (this.isEnd(row, column) || this.isStart(row, column)) {\n          return false;\n        } else {\n          return true;\n        }\n      }\n      return false;\n    };\n    this.insideStart = function (row, column) {\n      if (this.compare(row, column) == 0) {\n        if (this.isEnd(row, column)) {\n          return false;\n        } else {\n          return true;\n        }\n      }\n      return false;\n    };\n    this.insideEnd = function (row, column) {\n      if (this.compare(row, column) == 0) {\n        if (this.isStart(row, column)) {\n          return false;\n        } else {\n          return true;\n        }\n      }\n      return false;\n    };\n    this.compare = function (row, column) {\n      if (!this.isMultiLine()) {\n        if (row === this.start.row) {\n          return column < this.start.column ? -1 : column > this.end.column ? 1 : 0;\n        }\n      }\n      if (row < this.start.row) return -1;\n      if (row > this.end.row) return 1;\n      if (this.start.row === row) return column >= this.start.column ? 0 : -1;\n      if (this.end.row === row) return column <= this.end.column ? 0 : 1;\n      return 0;\n    };\n    this.compareStart = function (row, column) {\n      if (this.start.row == row && this.start.column == column) {\n        return -1;\n      } else {\n        return this.compare(row, column);\n      }\n    };\n    this.compareEnd = function (row, column) {\n      if (this.end.row == row && this.end.column == column) {\n        return 1;\n      } else {\n        return this.compare(row, column);\n      }\n    };\n    this.compareInside = function (row, column) {\n      if (this.end.row == row && this.end.column == column) {\n        return 1;\n      } else if (this.start.row == row && this.start.column == column) {\n        return -1;\n      } else {\n        return this.compare(row, column);\n      }\n    };\n    this.clipRows = function (firstRow, lastRow) {\n      if (this.end.row > lastRow) var end = {\n        row: lastRow + 1,\n        column: 0\n      };else if (this.end.row < firstRow) var end = {\n        row: firstRow,\n        column: 0\n      };\n      if (this.start.row > lastRow) var start = {\n        row: lastRow + 1,\n        column: 0\n      };else if (this.start.row < firstRow) var start = {\n        row: firstRow,\n        column: 0\n      };\n      return Range.fromPoints(start || this.start, end || this.end);\n    };\n    this.extend = function (row, column) {\n      var cmp = this.compare(row, column);\n      if (cmp == 0) return this;else if (cmp == -1) var start = {\n        row: row,\n        column: column\n      };else var end = {\n        row: row,\n        column: column\n      };\n      return Range.fromPoints(start || this.start, end || this.end);\n    };\n    this.isEmpty = function () {\n      return this.start.row === this.end.row && this.start.column === this.end.column;\n    };\n    this.isMultiLine = function () {\n      return this.start.row !== this.end.row;\n    };\n    this.clone = function () {\n      return Range.fromPoints(this.start, this.end);\n    };\n    this.collapseRows = function () {\n      if (this.end.column == 0) return new Range(this.start.row, 0, Math.max(this.start.row, this.end.row - 1), 0);else return new Range(this.start.row, 0, this.end.row, 0);\n    };\n    this.toScreenRange = function (session) {\n      var screenPosStart = session.documentToScreenPosition(this.start);\n      var screenPosEnd = session.documentToScreenPosition(this.end);\n      return new Range(screenPosStart.row, screenPosStart.column, screenPosEnd.row, screenPosEnd.column);\n    };\n    this.moveBy = function (row, column) {\n      this.start.row += row;\n      this.start.column += column;\n      this.end.row += row;\n      this.end.column += column;\n    };\n  }).call(Range.prototype);\n  Range.fromPoints = function (start, end) {\n    return new Range(start.row, start.column, end.row, end.column);\n  };\n  Range.comparePoints = comparePoints;\n  Range.comparePoints = function (p1, p2) {\n    return p1.row - p2.row || p1.column - p2.column;\n  };\n  exports.Range = Range;\n});\nace.define(\"ace/anchor\", [], function (require, exports, module) {\n  \"use strict\";\n\n  var oop = require(\"./lib/oop\");\n  var EventEmitter = require(\"./lib/event_emitter\").EventEmitter;\n  var Anchor = exports.Anchor = function (doc, row, column) {\n    this.$onChange = this.onChange.bind(this);\n    this.attach(doc);\n    if (typeof column == \"undefined\") this.setPosition(row.row, row.column);else this.setPosition(row, column);\n  };\n  (function () {\n    oop.implement(this, EventEmitter);\n    this.getPosition = function () {\n      return this.$clipPositionToDocument(this.row, this.column);\n    };\n    this.getDocument = function () {\n      return this.document;\n    };\n    this.$insertRight = false;\n    this.onChange = function (delta) {\n      if (delta.start.row == delta.end.row && delta.start.row != this.row) return;\n      if (delta.start.row > this.row) return;\n      var point = $getTransformedPoint(delta, {\n        row: this.row,\n        column: this.column\n      }, this.$insertRight);\n      this.setPosition(point.row, point.column, true);\n    };\n    function $pointsInOrder(point1, point2, equalPointsInOrder) {\n      var bColIsAfter = equalPointsInOrder ? point1.column <= point2.column : point1.column < point2.column;\n      return point1.row < point2.row || point1.row == point2.row && bColIsAfter;\n    }\n    function $getTransformedPoint(delta, point, moveIfEqual) {\n      var deltaIsInsert = delta.action == \"insert\";\n      var deltaRowShift = (deltaIsInsert ? 1 : -1) * (delta.end.row - delta.start.row);\n      var deltaColShift = (deltaIsInsert ? 1 : -1) * (delta.end.column - delta.start.column);\n      var deltaStart = delta.start;\n      var deltaEnd = deltaIsInsert ? deltaStart : delta.end; // Collapse insert range.\n      if ($pointsInOrder(point, deltaStart, moveIfEqual)) {\n        return {\n          row: point.row,\n          column: point.column\n        };\n      }\n      if ($pointsInOrder(deltaEnd, point, !moveIfEqual)) {\n        return {\n          row: point.row + deltaRowShift,\n          column: point.column + (point.row == deltaEnd.row ? deltaColShift : 0)\n        };\n      }\n      return {\n        row: deltaStart.row,\n        column: deltaStart.column\n      };\n    }\n    this.setPosition = function (row, column, noClip) {\n      var pos;\n      if (noClip) {\n        pos = {\n          row: row,\n          column: column\n        };\n      } else {\n        pos = this.$clipPositionToDocument(row, column);\n      }\n      if (this.row == pos.row && this.column == pos.column) return;\n      var old = {\n        row: this.row,\n        column: this.column\n      };\n      this.row = pos.row;\n      this.column = pos.column;\n      this._signal(\"change\", {\n        old: old,\n        value: pos\n      });\n    };\n    this.detach = function () {\n      this.document.off(\"change\", this.$onChange);\n    };\n    this.attach = function (doc) {\n      this.document = doc || this.document;\n      this.document.on(\"change\", this.$onChange);\n    };\n    this.$clipPositionToDocument = function (row, column) {\n      var pos = {};\n      if (row >= this.document.getLength()) {\n        pos.row = Math.max(0, this.document.getLength() - 1);\n        pos.column = this.document.getLine(pos.row).length;\n      } else if (row < 0) {\n        pos.row = 0;\n        pos.column = 0;\n      } else {\n        pos.row = row;\n        pos.column = Math.min(this.document.getLine(pos.row).length, Math.max(0, column));\n      }\n      if (column < 0) pos.column = 0;\n      return pos;\n    };\n  }).call(Anchor.prototype);\n});\nace.define(\"ace/document\", [], function (require, exports, module) {\n  \"use strict\";\n\n  var oop = require(\"./lib/oop\");\n  var applyDelta = require(\"./apply_delta\").applyDelta;\n  var EventEmitter = require(\"./lib/event_emitter\").EventEmitter;\n  var Range = require(\"./range\").Range;\n  var Anchor = require(\"./anchor\").Anchor;\n  var Document = function Document(textOrLines) {\n    this.$lines = [\"\"];\n    if (textOrLines.length === 0) {\n      this.$lines = [\"\"];\n    } else if (Array.isArray(textOrLines)) {\n      this.insertMergedLines({\n        row: 0,\n        column: 0\n      }, textOrLines);\n    } else {\n      this.insert({\n        row: 0,\n        column: 0\n      }, textOrLines);\n    }\n  };\n  (function () {\n    oop.implement(this, EventEmitter);\n    this.setValue = function (text) {\n      var len = this.getLength() - 1;\n      this.remove(new Range(0, 0, len, this.getLine(len).length));\n      this.insert({\n        row: 0,\n        column: 0\n      }, text || \"\");\n    };\n    this.getValue = function () {\n      return this.getAllLines().join(this.getNewLineCharacter());\n    };\n    this.createAnchor = function (row, column) {\n      return new Anchor(this, row, column);\n    };\n    if (\"aaa\".split(/a/).length === 0) {\n      this.$split = function (text) {\n        return text.replace(/\\r\\n|\\r/g, \"\\n\").split(\"\\n\");\n      };\n    } else {\n      this.$split = function (text) {\n        return text.split(/\\r\\n|\\r|\\n/);\n      };\n    }\n    this.$detectNewLine = function (text) {\n      var match = text.match(/^.*?(\\r\\n|\\r|\\n)/m);\n      this.$autoNewLine = match ? match[1] : \"\\n\";\n      this._signal(\"changeNewLineMode\");\n    };\n    this.getNewLineCharacter = function () {\n      switch (this.$newLineMode) {\n        case \"windows\":\n          return \"\\r\\n\";\n        case \"unix\":\n          return \"\\n\";\n        default:\n          return this.$autoNewLine || \"\\n\";\n      }\n    };\n    this.$autoNewLine = \"\";\n    this.$newLineMode = \"auto\";\n    this.setNewLineMode = function (newLineMode) {\n      if (this.$newLineMode === newLineMode) return;\n      this.$newLineMode = newLineMode;\n      this._signal(\"changeNewLineMode\");\n    };\n    this.getNewLineMode = function () {\n      return this.$newLineMode;\n    };\n    this.isNewLine = function (text) {\n      return text == \"\\r\\n\" || text == \"\\r\" || text == \"\\n\";\n    };\n    this.getLine = function (row) {\n      return this.$lines[row] || \"\";\n    };\n    this.getLines = function (firstRow, lastRow) {\n      return this.$lines.slice(firstRow, lastRow + 1);\n    };\n    this.getAllLines = function () {\n      return this.getLines(0, this.getLength());\n    };\n    this.getLength = function () {\n      return this.$lines.length;\n    };\n    this.getTextRange = function (range) {\n      return this.getLinesForRange(range).join(this.getNewLineCharacter());\n    };\n    this.getLinesForRange = function (range) {\n      var lines;\n      if (range.start.row === range.end.row) {\n        lines = [this.getLine(range.start.row).substring(range.start.column, range.end.column)];\n      } else {\n        lines = this.getLines(range.start.row, range.end.row);\n        lines[0] = (lines[0] || \"\").substring(range.start.column);\n        var l = lines.length - 1;\n        if (range.end.row - range.start.row == l) lines[l] = lines[l].substring(0, range.end.column);\n      }\n      return lines;\n    };\n    this.insertLines = function (row, lines) {\n      console.warn(\"Use of document.insertLines is deprecated. Use the insertFullLines method instead.\");\n      return this.insertFullLines(row, lines);\n    };\n    this.removeLines = function (firstRow, lastRow) {\n      console.warn(\"Use of document.removeLines is deprecated. Use the removeFullLines method instead.\");\n      return this.removeFullLines(firstRow, lastRow);\n    };\n    this.insertNewLine = function (position) {\n      console.warn(\"Use of document.insertNewLine is deprecated. Use insertMergedLines(position, ['', '']) instead.\");\n      return this.insertMergedLines(position, [\"\", \"\"]);\n    };\n    this.insert = function (position, text) {\n      if (this.getLength() <= 1) this.$detectNewLine(text);\n      return this.insertMergedLines(position, this.$split(text));\n    };\n    this.insertInLine = function (position, text) {\n      var start = this.clippedPos(position.row, position.column);\n      var end = this.pos(position.row, position.column + text.length);\n      this.applyDelta({\n        start: start,\n        end: end,\n        action: \"insert\",\n        lines: [text]\n      }, true);\n      return this.clonePos(end);\n    };\n    this.clippedPos = function (row, column) {\n      var length = this.getLength();\n      if (row === undefined) {\n        row = length;\n      } else if (row < 0) {\n        row = 0;\n      } else if (row >= length) {\n        row = length - 1;\n        column = undefined;\n      }\n      var line = this.getLine(row);\n      if (column == undefined) column = line.length;\n      column = Math.min(Math.max(column, 0), line.length);\n      return {\n        row: row,\n        column: column\n      };\n    };\n    this.clonePos = function (pos) {\n      return {\n        row: pos.row,\n        column: pos.column\n      };\n    };\n    this.pos = function (row, column) {\n      return {\n        row: row,\n        column: column\n      };\n    };\n    this.$clipPosition = function (position) {\n      var length = this.getLength();\n      if (position.row >= length) {\n        position.row = Math.max(0, length - 1);\n        position.column = this.getLine(length - 1).length;\n      } else {\n        position.row = Math.max(0, position.row);\n        position.column = Math.min(Math.max(position.column, 0), this.getLine(position.row).length);\n      }\n      return position;\n    };\n    this.insertFullLines = function (row, lines) {\n      row = Math.min(Math.max(row, 0), this.getLength());\n      var column = 0;\n      if (row < this.getLength()) {\n        lines = lines.concat([\"\"]);\n        column = 0;\n      } else {\n        lines = [\"\"].concat(lines);\n        row--;\n        column = this.$lines[row].length;\n      }\n      this.insertMergedLines({\n        row: row,\n        column: column\n      }, lines);\n    };\n    this.insertMergedLines = function (position, lines) {\n      var start = this.clippedPos(position.row, position.column);\n      var end = {\n        row: start.row + lines.length - 1,\n        column: (lines.length == 1 ? start.column : 0) + lines[lines.length - 1].length\n      };\n      this.applyDelta({\n        start: start,\n        end: end,\n        action: \"insert\",\n        lines: lines\n      });\n      return this.clonePos(end);\n    };\n    this.remove = function (range) {\n      var start = this.clippedPos(range.start.row, range.start.column);\n      var end = this.clippedPos(range.end.row, range.end.column);\n      this.applyDelta({\n        start: start,\n        end: end,\n        action: \"remove\",\n        lines: this.getLinesForRange({\n          start: start,\n          end: end\n        })\n      });\n      return this.clonePos(start);\n    };\n    this.removeInLine = function (row, startColumn, endColumn) {\n      var start = this.clippedPos(row, startColumn);\n      var end = this.clippedPos(row, endColumn);\n      this.applyDelta({\n        start: start,\n        end: end,\n        action: \"remove\",\n        lines: this.getLinesForRange({\n          start: start,\n          end: end\n        })\n      }, true);\n      return this.clonePos(start);\n    };\n    this.removeFullLines = function (firstRow, lastRow) {\n      firstRow = Math.min(Math.max(0, firstRow), this.getLength() - 1);\n      lastRow = Math.min(Math.max(0, lastRow), this.getLength() - 1);\n      var deleteFirstNewLine = lastRow == this.getLength() - 1 && firstRow > 0;\n      var deleteLastNewLine = lastRow < this.getLength() - 1;\n      var startRow = deleteFirstNewLine ? firstRow - 1 : firstRow;\n      var startCol = deleteFirstNewLine ? this.getLine(startRow).length : 0;\n      var endRow = deleteLastNewLine ? lastRow + 1 : lastRow;\n      var endCol = deleteLastNewLine ? 0 : this.getLine(endRow).length;\n      var range = new Range(startRow, startCol, endRow, endCol);\n      var deletedLines = this.$lines.slice(firstRow, lastRow + 1);\n      this.applyDelta({\n        start: range.start,\n        end: range.end,\n        action: \"remove\",\n        lines: this.getLinesForRange(range)\n      });\n      return deletedLines;\n    };\n    this.removeNewLine = function (row) {\n      if (row < this.getLength() - 1 && row >= 0) {\n        this.applyDelta({\n          start: this.pos(row, this.getLine(row).length),\n          end: this.pos(row + 1, 0),\n          action: \"remove\",\n          lines: [\"\", \"\"]\n        });\n      }\n    };\n    this.replace = function (range, text) {\n      if (!(range instanceof Range)) range = Range.fromPoints(range.start, range.end);\n      if (text.length === 0 && range.isEmpty()) return range.start;\n      if (text == this.getTextRange(range)) return range.end;\n      this.remove(range);\n      var end;\n      if (text) {\n        end = this.insert(range.start, text);\n      } else {\n        end = range.start;\n      }\n      return end;\n    };\n    this.applyDeltas = function (deltas) {\n      for (var i = 0; i < deltas.length; i++) {\n        this.applyDelta(deltas[i]);\n      }\n    };\n    this.revertDeltas = function (deltas) {\n      for (var i = deltas.length - 1; i >= 0; i--) {\n        this.revertDelta(deltas[i]);\n      }\n    };\n    this.applyDelta = function (delta, doNotValidate) {\n      var isInsert = delta.action == \"insert\";\n      if (isInsert ? delta.lines.length <= 1 && !delta.lines[0] : !Range.comparePoints(delta.start, delta.end)) {\n        return;\n      }\n      if (isInsert && delta.lines.length > 20000) {\n        this.$splitAndapplyLargeDelta(delta, 20000);\n      } else {\n        applyDelta(this.$lines, delta, doNotValidate);\n        this._signal(\"change\", delta);\n      }\n    };\n    this.$safeApplyDelta = function (delta) {\n      var docLength = this.$lines.length;\n      if (delta.action == \"remove\" && delta.start.row < docLength && delta.end.row < docLength || delta.action == \"insert\" && delta.start.row <= docLength) {\n        this.applyDelta(delta);\n      }\n    };\n    this.$splitAndapplyLargeDelta = function (delta, MAX) {\n      var lines = delta.lines;\n      var l = lines.length - MAX + 1;\n      var row = delta.start.row;\n      var column = delta.start.column;\n      for (var from = 0, to = 0; from < l; from = to) {\n        to += MAX - 1;\n        var chunk = lines.slice(from, to);\n        chunk.push(\"\");\n        this.applyDelta({\n          start: this.pos(row + from, column),\n          end: this.pos(row + to, column = 0),\n          action: delta.action,\n          lines: chunk\n        }, true);\n      }\n      delta.lines = lines.slice(from);\n      delta.start.row = row + from;\n      delta.start.column = column;\n      this.applyDelta(delta, true);\n    };\n    this.revertDelta = function (delta) {\n      this.$safeApplyDelta({\n        start: this.clonePos(delta.start),\n        end: this.clonePos(delta.end),\n        action: delta.action == \"insert\" ? \"remove\" : \"insert\",\n        lines: delta.lines.slice()\n      });\n    };\n    this.indexToPosition = function (index, startRow) {\n      var lines = this.$lines || this.getAllLines();\n      var newlineLength = this.getNewLineCharacter().length;\n      for (var i = startRow || 0, l = lines.length; i < l; i++) {\n        index -= lines[i].length + newlineLength;\n        if (index < 0) return {\n          row: i,\n          column: index + lines[i].length + newlineLength\n        };\n      }\n      return {\n        row: l - 1,\n        column: index + lines[l - 1].length + newlineLength\n      };\n    };\n    this.positionToIndex = function (pos, startRow) {\n      var lines = this.$lines || this.getAllLines();\n      var newlineLength = this.getNewLineCharacter().length;\n      var index = 0;\n      var row = Math.min(pos.row, lines.length);\n      for (var i = startRow || 0; i < row; ++i) index += lines[i].length + newlineLength;\n      return index + pos.column;\n    };\n  }).call(Document.prototype);\n  exports.Document = Document;\n});\nace.define(\"ace/lib/lang\", [], function (require, exports, module) {\n  \"use strict\";\n\n  exports.last = function (a) {\n    return a[a.length - 1];\n  };\n  exports.stringReverse = function (string) {\n    return string.split(\"\").reverse().join(\"\");\n  };\n  exports.stringRepeat = function (string, count) {\n    var result = '';\n    while (count > 0) {\n      if (count & 1) result += string;\n      if (count >>= 1) string += string;\n    }\n    return result;\n  };\n  var trimBeginRegexp = /^\\s\\s*/;\n  var trimEndRegexp = /\\s\\s*$/;\n  exports.stringTrimLeft = function (string) {\n    return string.replace(trimBeginRegexp, '');\n  };\n  exports.stringTrimRight = function (string) {\n    return string.replace(trimEndRegexp, '');\n  };\n  exports.copyObject = function (obj) {\n    var copy = {};\n    for (var key in obj) {\n      copy[key] = obj[key];\n    }\n    return copy;\n  };\n  exports.copyArray = function (array) {\n    var copy = [];\n    for (var i = 0, l = array.length; i < l; i++) {\n      if (array[i] && typeof array[i] == \"object\") copy[i] = this.copyObject(array[i]);else copy[i] = array[i];\n    }\n    return copy;\n  };\n  exports.deepCopy = function deepCopy(obj) {\n    if (typeof obj !== \"object\" || !obj) return obj;\n    var copy;\n    if (Array.isArray(obj)) {\n      copy = [];\n      for (var key = 0; key < obj.length; key++) {\n        copy[key] = deepCopy(obj[key]);\n      }\n      return copy;\n    }\n    if (Object.prototype.toString.call(obj) !== \"[object Object]\") return obj;\n    copy = {};\n    for (var key in obj) copy[key] = deepCopy(obj[key]);\n    return copy;\n  };\n  exports.arrayToMap = function (arr) {\n    var map = {};\n    for (var i = 0; i < arr.length; i++) {\n      map[arr[i]] = 1;\n    }\n    return map;\n  };\n  exports.createMap = function (props) {\n    var map = Object.create(null);\n    for (var i in props) {\n      map[i] = props[i];\n    }\n    return map;\n  };\n  exports.arrayRemove = function (array, value) {\n    for (var i = 0; i <= array.length; i++) {\n      if (value === array[i]) {\n        array.splice(i, 1);\n      }\n    }\n  };\n  exports.escapeRegExp = function (str) {\n    return str.replace(/([.*+?^${}()|[\\]\\/\\\\])/g, '\\\\$1');\n  };\n  exports.escapeHTML = function (str) {\n    return (\"\" + str).replace(/&/g, \"&#38;\").replace(/\"/g, \"&#34;\").replace(/'/g, \"&#39;\").replace(/</g, \"&#60;\");\n  };\n  exports.getMatchOffsets = function (string, regExp) {\n    var matches = [];\n    string.replace(regExp, function (str) {\n      matches.push({\n        offset: arguments[arguments.length - 2],\n        length: str.length\n      });\n    });\n    return matches;\n  };\n  exports.deferredCall = function (fcn) {\n    var timer = null;\n    var callback = function callback() {\n      timer = null;\n      fcn();\n    };\n    var deferred = function deferred(timeout) {\n      deferred.cancel();\n      timer = setTimeout(callback, timeout || 0);\n      return deferred;\n    };\n    deferred.schedule = deferred;\n    deferred.call = function () {\n      this.cancel();\n      fcn();\n      return deferred;\n    };\n    deferred.cancel = function () {\n      clearTimeout(timer);\n      timer = null;\n      return deferred;\n    };\n    deferred.isPending = function () {\n      return timer;\n    };\n    return deferred;\n  };\n  exports.delayedCall = function (fcn, defaultTimeout) {\n    var timer = null;\n    var callback = function callback() {\n      timer = null;\n      fcn();\n    };\n    var _self = function _self(timeout) {\n      if (timer == null) timer = setTimeout(callback, timeout || defaultTimeout);\n    };\n    _self.delay = function (timeout) {\n      timer && clearTimeout(timer);\n      timer = setTimeout(callback, timeout || defaultTimeout);\n    };\n    _self.schedule = _self;\n    _self.call = function () {\n      this.cancel();\n      fcn();\n    };\n    _self.cancel = function () {\n      timer && clearTimeout(timer);\n      timer = null;\n    };\n    _self.isPending = function () {\n      return timer;\n    };\n    return _self;\n  };\n});\nace.define(\"ace/worker/mirror\", [], function (require, exports, module) {\n  \"use strict\";\n\n  var Document = require(\"../document\").Document;\n  var lang = require(\"../lib/lang\");\n  var Mirror = exports.Mirror = function (sender) {\n    this.sender = sender;\n    var doc = this.doc = new Document(\"\");\n    var deferredUpdate = this.deferredUpdate = lang.delayedCall(this.onUpdate.bind(this));\n    var _self = this;\n    sender.on(\"change\", function (e) {\n      var data = e.data;\n      if (data[0].start) {\n        doc.applyDeltas(data);\n      } else {\n        for (var i = 0; i < data.length; i += 2) {\n          var d, err;\n          if (Array.isArray(data[i + 1])) {\n            d = {\n              action: \"insert\",\n              start: data[i],\n              lines: data[i + 1]\n            };\n          } else {\n            d = {\n              action: \"remove\",\n              start: data[i],\n              end: data[i + 1]\n            };\n          }\n          if ((d.action == \"insert\" ? d.start : d.end).row >= doc.$lines.length) {\n            err = new Error(\"Invalid delta\");\n            err.data = {\n              path: _self.$path,\n              linesLength: doc.$lines.length,\n              start: d.start,\n              end: d.end\n            };\n            throw err;\n          }\n          doc.applyDelta(d, true);\n        }\n      }\n      if (_self.$timeout) return deferredUpdate.schedule(_self.$timeout);\n      _self.onUpdate();\n    });\n  };\n  (function () {\n    this.$timeout = 500;\n    this.setTimeout = function (timeout) {\n      this.$timeout = timeout;\n    };\n    this.setValue = function (value) {\n      this.doc.setValue(value);\n      this.deferredUpdate.schedule(this.$timeout);\n    };\n    this.getValue = function (callbackId) {\n      this.sender.callback(this.doc.getValue(), callbackId);\n    };\n    this.onUpdate = function () {};\n    this.isPending = function () {\n      return this.deferredUpdate.isPending();\n    };\n  }).call(Mirror.prototype);\n});\nace.define(\"ace/mode/yaml/yaml-lint\", [], function (require, exports, module) {\n  var $build_deps$ = {\n    require: require,\n    exports: exports,\n    module: module\n  };\n  exports = undefined;\n  module = undefined;\n  function define(name, deps, m) {\n    if (typeof name == \"function\") {\n      m = name;\n      deps = [\"require\", \"exports\", \"module\"];\n      name = $build_deps$.module.id;\n    }\n    if (typeof name !== \"string\") {\n      m = deps;\n      deps = name;\n      name = $build_deps$.module.id;\n    }\n    if (!m) {\n      m = deps;\n      deps = [];\n    }\n    var ret = typeof m == \"function\" ? m.apply($build_deps$.module, deps.map(function (n) {\n      return $build_deps$[n] || require(n);\n    })) : m;\n    if (ret != undefined) $build_deps$.module.exports = ret;\n  }\n  define.amd = true;\n  (function (f) {\n    if (typeof exports === \"object\" && typeof module !== \"undefined\") {\n      module.exports = f();\n    } else if (typeof define === \"function\" && define.amd) {\n      define([], f);\n    } else {\n      var g;\n      if (typeof window !== \"undefined\") {\n        g = window;\n      } else if (typeof global !== \"undefined\") {\n        g = global;\n      } else if (typeof self !== \"undefined\") {\n        g = self;\n      } else {\n        g = this;\n      }\n      g.lint = f();\n    }\n  })(function () {\n    var define, module, exports;\n    return function () {\n      function r(e, n, t) {\n        function o(i, f) {\n          if (!n[i]) {\n            if (!e[i]) {\n              var c = typeof require == \"function\" && require;\n              if (!f && c) return c(i, !0);\n              if (u) return u(i, !0);\n              var a = new Error(\"Cannot find module '\" + i + \"'\");\n              throw a.code = \"MODULE_NOT_FOUND\", a;\n            }\n            var p = n[i] = {\n              exports: {}\n            };\n            e[i][0].call(p.exports, function (r) {\n              var n = e[i][1][r];\n              return o(n || r);\n            }, p, p.exports, r, e, n, t);\n          }\n          return n[i].exports;\n        }\n        for (var u = typeof require == \"function\" && require, i = 0; i < t.length; i++) o(t[i]);\n        return o;\n      }\n      return r;\n    }()({\n      1: [function (require, module, exports) {}, {}],\n      2: [function (require, module, exports) {\n        var fs = require('fs');\n        var merge = require('lodash.merge');\n        var yaml = require('js-yaml');\n        var DEFAULT_LINT_OPTION = {\n          schema: 'DEFAULT_SAFE_SCHEMA'\n        };\n        function lint(content, opts, cb) {\n          var options = merge({}, DEFAULT_LINT_OPTION, opts);\n          try {\n            yaml.safeLoad(content, {\n              schema: yaml[options.schema]\n            });\n            cb();\n          } catch (e) {\n            cb(e);\n          }\n        }\n        module.exports = {\n          lint: lint\n        };\n      }, {\n        \"fs\": 1,\n        \"js-yaml\": 3,\n        \"lodash.merge\": 33\n      }],\n      3: [function (require, module, exports) {\n        'use strict';\n\n        var yaml = require('./lib/js-yaml.js');\n        module.exports = yaml;\n      }, {\n        \"./lib/js-yaml.js\": 4\n      }],\n      4: [function (require, module, exports) {\n        'use strict';\n\n        var loader = require('./js-yaml/loader');\n        var dumper = require('./js-yaml/dumper');\n        function deprecated(name) {\n          return function () {\n            throw new Error('Function ' + name + ' is deprecated and cannot be used.');\n          };\n        }\n        module.exports.Type = require('./js-yaml/type');\n        module.exports.Schema = require('./js-yaml/schema');\n        module.exports.FAILSAFE_SCHEMA = require('./js-yaml/schema/failsafe');\n        module.exports.JSON_SCHEMA = require('./js-yaml/schema/json');\n        module.exports.CORE_SCHEMA = require('./js-yaml/schema/core');\n        module.exports.DEFAULT_SAFE_SCHEMA = require('./js-yaml/schema/default_safe');\n        module.exports.DEFAULT_FULL_SCHEMA = require('./js-yaml/schema/default_full');\n        module.exports.load = loader.load;\n        module.exports.loadAll = loader.loadAll;\n        module.exports.safeLoad = loader.safeLoad;\n        module.exports.safeLoadAll = loader.safeLoadAll;\n        module.exports.dump = dumper.dump;\n        module.exports.safeDump = dumper.safeDump;\n        module.exports.YAMLException = require('./js-yaml/exception');\n        module.exports.MINIMAL_SCHEMA = require('./js-yaml/schema/failsafe');\n        module.exports.SAFE_SCHEMA = require('./js-yaml/schema/default_safe');\n        module.exports.DEFAULT_SCHEMA = require('./js-yaml/schema/default_full');\n        module.exports.scan = deprecated('scan');\n        module.exports.parse = deprecated('parse');\n        module.exports.compose = deprecated('compose');\n        module.exports.addConstructor = deprecated('addConstructor');\n      }, {\n        \"./js-yaml/dumper\": 6,\n        \"./js-yaml/exception\": 7,\n        \"./js-yaml/loader\": 8,\n        \"./js-yaml/schema\": 10,\n        \"./js-yaml/schema/core\": 11,\n        \"./js-yaml/schema/default_full\": 12,\n        \"./js-yaml/schema/default_safe\": 13,\n        \"./js-yaml/schema/failsafe\": 14,\n        \"./js-yaml/schema/json\": 15,\n        \"./js-yaml/type\": 16\n      }],\n      5: [function (require, module, exports) {\n        'use strict';\n\n        function isNothing(subject) {\n          return typeof subject === 'undefined' || subject === null;\n        }\n        function isObject(subject) {\n          return typeof subject === 'object' && subject !== null;\n        }\n        function toArray(sequence) {\n          if (Array.isArray(sequence)) return sequence;else if (isNothing(sequence)) return [];\n          return [sequence];\n        }\n        function extend(target, source) {\n          var index, length, key, sourceKeys;\n          if (source) {\n            sourceKeys = Object.keys(source);\n            for (index = 0, length = sourceKeys.length; index < length; index += 1) {\n              key = sourceKeys[index];\n              target[key] = source[key];\n            }\n          }\n          return target;\n        }\n        function repeat(string, count) {\n          var result = '',\n            cycle;\n          for (cycle = 0; cycle < count; cycle += 1) {\n            result += string;\n          }\n          return result;\n        }\n        function isNegativeZero(number) {\n          return number === 0 && Number.NEGATIVE_INFINITY === 1 / number;\n        }\n        module.exports.isNothing = isNothing;\n        module.exports.isObject = isObject;\n        module.exports.toArray = toArray;\n        module.exports.repeat = repeat;\n        module.exports.isNegativeZero = isNegativeZero;\n        module.exports.extend = extend;\n      }, {}],\n      6: [function (require, module, exports) {\n        'use strict';\n\n        var common = require('./common');\n        var YAMLException = require('./exception');\n        var DEFAULT_FULL_SCHEMA = require('./schema/default_full');\n        var DEFAULT_SAFE_SCHEMA = require('./schema/default_safe');\n        var _toString = Object.prototype.toString;\n        var _hasOwnProperty = Object.prototype.hasOwnProperty;\n        var CHAR_TAB = 0x09;\n        var CHAR_LINE_FEED = 0x0A;\n        var CHAR_SPACE = 0x20;\n        var CHAR_EXCLAMATION = 0x21;\n        var CHAR_DOUBLE_QUOTE = 0x22;\n        var CHAR_SHARP = 0x23;\n        var CHAR_PERCENT = 0x25;\n        var CHAR_AMPERSAND = 0x26;\n        var CHAR_SINGLE_QUOTE = 0x27;\n        var CHAR_ASTERISK = 0x2A;\n        var CHAR_COMMA = 0x2C;\n        var CHAR_MINUS = 0x2D;\n        var CHAR_COLON = 0x3A;\n        var CHAR_GREATER_THAN = 0x3E;\n        var CHAR_QUESTION = 0x3F;\n        var CHAR_COMMERCIAL_AT = 0x40;\n        var CHAR_LEFT_SQUARE_BRACKET = 0x5B;\n        var CHAR_RIGHT_SQUARE_BRACKET = 0x5D;\n        var CHAR_GRAVE_ACCENT = 0x60;\n        var CHAR_LEFT_CURLY_BRACKET = 0x7B;\n        var CHAR_VERTICAL_LINE = 0x7C;\n        var CHAR_RIGHT_CURLY_BRACKET = 0x7D;\n        var ESCAPE_SEQUENCES = {};\n        ESCAPE_SEQUENCES[0x00] = '\\\\0';\n        ESCAPE_SEQUENCES[0x07] = '\\\\a';\n        ESCAPE_SEQUENCES[0x08] = '\\\\b';\n        ESCAPE_SEQUENCES[0x09] = '\\\\t';\n        ESCAPE_SEQUENCES[0x0A] = '\\\\n';\n        ESCAPE_SEQUENCES[0x0B] = '\\\\v';\n        ESCAPE_SEQUENCES[0x0C] = '\\\\f';\n        ESCAPE_SEQUENCES[0x0D] = '\\\\r';\n        ESCAPE_SEQUENCES[0x1B] = '\\\\e';\n        ESCAPE_SEQUENCES[0x22] = '\\\\\"';\n        ESCAPE_SEQUENCES[0x5C] = '\\\\\\\\';\n        ESCAPE_SEQUENCES[0x85] = '\\\\N';\n        ESCAPE_SEQUENCES[0xA0] = '\\\\_';\n        ESCAPE_SEQUENCES[0x2028] = '\\\\L';\n        ESCAPE_SEQUENCES[0x2029] = '\\\\P';\n        var DEPRECATED_BOOLEANS_SYNTAX = ['y', 'Y', 'yes', 'Yes', 'YES', 'on', 'On', 'ON', 'n', 'N', 'no', 'No', 'NO', 'off', 'Off', 'OFF'];\n        function compileStyleMap(schema, map) {\n          var result, keys, index, length, tag, style, type;\n          if (map === null) return {};\n          result = {};\n          keys = Object.keys(map);\n          for (index = 0, length = keys.length; index < length; index += 1) {\n            tag = keys[index];\n            style = String(map[tag]);\n            if (tag.slice(0, 2) === '!!') {\n              tag = 'tag:yaml.org,2002:' + tag.slice(2);\n            }\n            type = schema.compiledTypeMap['fallback'][tag];\n            if (type && _hasOwnProperty.call(type.styleAliases, style)) {\n              style = type.styleAliases[style];\n            }\n            result[tag] = style;\n          }\n          return result;\n        }\n        function encodeHex(character) {\n          var string, handle, length;\n          string = character.toString(16).toUpperCase();\n          if (character <= 0xFF) {\n            handle = 'x';\n            length = 2;\n          } else if (character <= 0xFFFF) {\n            handle = 'u';\n            length = 4;\n          } else if (character <= 0xFFFFFFFF) {\n            handle = 'U';\n            length = 8;\n          } else {\n            throw new YAMLException('code point within a string may not be greater than 0xFFFFFFFF');\n          }\n          return '\\\\' + handle + common.repeat('0', length - string.length) + string;\n        }\n        function State(options) {\n          this.schema = options['schema'] || DEFAULT_FULL_SCHEMA;\n          this.indent = Math.max(1, options['indent'] || 2);\n          this.noArrayIndent = options['noArrayIndent'] || false;\n          this.skipInvalid = options['skipInvalid'] || false;\n          this.flowLevel = common.isNothing(options['flowLevel']) ? -1 : options['flowLevel'];\n          this.styleMap = compileStyleMap(this.schema, options['styles'] || null);\n          this.sortKeys = options['sortKeys'] || false;\n          this.lineWidth = options['lineWidth'] || 80;\n          this.noRefs = options['noRefs'] || false;\n          this.noCompatMode = options['noCompatMode'] || false;\n          this.condenseFlow = options['condenseFlow'] || false;\n          this.implicitTypes = this.schema.compiledImplicit;\n          this.explicitTypes = this.schema.compiledExplicit;\n          this.tag = null;\n          this.result = '';\n          this.duplicates = [];\n          this.usedDuplicates = null;\n        }\n        function indentString(string, spaces) {\n          var ind = common.repeat(' ', spaces),\n            position = 0,\n            next = -1,\n            result = '',\n            line,\n            length = string.length;\n          while (position < length) {\n            next = string.indexOf('\\n', position);\n            if (next === -1) {\n              line = string.slice(position);\n              position = length;\n            } else {\n              line = string.slice(position, next + 1);\n              position = next + 1;\n            }\n            if (line.length && line !== '\\n') result += ind;\n            result += line;\n          }\n          return result;\n        }\n        function generateNextLine(state, level) {\n          return '\\n' + common.repeat(' ', state.indent * level);\n        }\n        function testImplicitResolving(state, str) {\n          var index, length, type;\n          for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {\n            type = state.implicitTypes[index];\n            if (type.resolve(str)) {\n              return true;\n            }\n          }\n          return false;\n        }\n        function isWhitespace(c) {\n          return c === CHAR_SPACE || c === CHAR_TAB;\n        }\n        function isPrintable(c) {\n          return c >= 0x00020 && c <= 0x00007E || c >= 0x000A1 && c <= 0x00D7FF && c !== 0x2028 && c !== 0x2029 || c >= 0x0E000 && c <= 0x00FFFD && c !== 0xFEFF /* BOM */ || c >= 0x10000 && c <= 0x10FFFF;\n        }\n        function isPlainSafe(c) {\n          return isPrintable(c) && c !== 0xFEFF && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET && c !== CHAR_COLON && c !== CHAR_SHARP;\n        }\n        function isPlainSafeFirst(c) {\n          return isPrintable(c) && c !== 0xFEFF && !isWhitespace(c) // - s-white\n          && c !== CHAR_MINUS && c !== CHAR_QUESTION && c !== CHAR_COLON && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET && c !== CHAR_SHARP && c !== CHAR_AMPERSAND && c !== CHAR_ASTERISK && c !== CHAR_EXCLAMATION && c !== CHAR_VERTICAL_LINE && c !== CHAR_GREATER_THAN && c !== CHAR_SINGLE_QUOTE && c !== CHAR_DOUBLE_QUOTE && c !== CHAR_PERCENT && c !== CHAR_COMMERCIAL_AT && c !== CHAR_GRAVE_ACCENT;\n        }\n        function needIndentIndicator(string) {\n          var leadingSpaceRe = /^\\n* /;\n          return leadingSpaceRe.test(string);\n        }\n        var STYLE_PLAIN = 1,\n          STYLE_SINGLE = 2,\n          STYLE_LITERAL = 3,\n          STYLE_FOLDED = 4,\n          STYLE_DOUBLE = 5;\n        function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType) {\n          var i;\n          var char;\n          var hasLineBreak = false;\n          var hasFoldableLine = false; // only checked if shouldTrackWidth\n          var shouldTrackWidth = lineWidth !== -1;\n          var previousLineBreak = -1; // count the first line correctly\n          var plain = isPlainSafeFirst(string.charCodeAt(0)) && !isWhitespace(string.charCodeAt(string.length - 1));\n          if (singleLineOnly) {\n            for (i = 0; i < string.length; i++) {\n              char = string.charCodeAt(i);\n              if (!isPrintable(char)) {\n                return STYLE_DOUBLE;\n              }\n              plain = plain && isPlainSafe(char);\n            }\n          } else {\n            for (i = 0; i < string.length; i++) {\n              char = string.charCodeAt(i);\n              if (char === CHAR_LINE_FEED) {\n                hasLineBreak = true;\n                if (shouldTrackWidth) {\n                  hasFoldableLine = hasFoldableLine || i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== ' ';\n                  previousLineBreak = i;\n                }\n              } else if (!isPrintable(char)) {\n                return STYLE_DOUBLE;\n              }\n              plain = plain && isPlainSafe(char);\n            }\n            hasFoldableLine = hasFoldableLine || shouldTrackWidth && i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== ' ';\n          }\n          if (!hasLineBreak && !hasFoldableLine) {\n            return plain && !testAmbiguousType(string) ? STYLE_PLAIN : STYLE_SINGLE;\n          }\n          if (indentPerLevel > 9 && needIndentIndicator(string)) {\n            return STYLE_DOUBLE;\n          }\n          return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;\n        }\n        function writeScalar(state, string, level, iskey) {\n          state.dump = function () {\n            if (string.length === 0) {\n              return \"''\";\n            }\n            if (!state.noCompatMode && DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1) {\n              return \"'\" + string + \"'\";\n            }\n            var indent = state.indent * Math.max(1, level); // no 0-indent scalars\n            var lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);\n            var singleLineOnly = iskey || state.flowLevel > -1 && level >= state.flowLevel;\n            function testAmbiguity(string) {\n              return testImplicitResolving(state, string);\n            }\n            switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth, testAmbiguity)) {\n              case STYLE_PLAIN:\n                return string;\n              case STYLE_SINGLE:\n                return \"'\" + string.replace(/'/g, \"''\") + \"'\";\n              case STYLE_LITERAL:\n                return '|' + blockHeader(string, state.indent) + dropEndingNewline(indentString(string, indent));\n              case STYLE_FOLDED:\n                return '>' + blockHeader(string, state.indent) + dropEndingNewline(indentString(foldString(string, lineWidth), indent));\n              case STYLE_DOUBLE:\n                return '\"' + escapeString(string, lineWidth) + '\"';\n              default:\n                throw new YAMLException('impossible error: invalid scalar style');\n            }\n          }();\n        }\n        function blockHeader(string, indentPerLevel) {\n          var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : '';\n          var clip = string[string.length - 1] === '\\n';\n          var keep = clip && (string[string.length - 2] === '\\n' || string === '\\n');\n          var chomp = keep ? '+' : clip ? '' : '-';\n          return indentIndicator + chomp + '\\n';\n        }\n        function dropEndingNewline(string) {\n          return string[string.length - 1] === '\\n' ? string.slice(0, -1) : string;\n        }\n        function foldString(string, width) {\n          var lineRe = /(\\n+)([^\\n]*)/g;\n          var result = function () {\n            var nextLF = string.indexOf('\\n');\n            nextLF = nextLF !== -1 ? nextLF : string.length;\n            lineRe.lastIndex = nextLF;\n            return foldLine(string.slice(0, nextLF), width);\n          }();\n          var prevMoreIndented = string[0] === '\\n' || string[0] === ' ';\n          var moreIndented;\n          var match;\n          while (match = lineRe.exec(string)) {\n            var prefix = match[1],\n              line = match[2];\n            moreIndented = line[0] === ' ';\n            result += prefix + (!prevMoreIndented && !moreIndented && line !== '' ? '\\n' : '') + foldLine(line, width);\n            prevMoreIndented = moreIndented;\n          }\n          return result;\n        }\n        function foldLine(line, width) {\n          if (line === '' || line[0] === ' ') return line;\n          var breakRe = / [^ ]/g; // note: the match index will always be <= length-2.\n          var match;\n          var start = 0,\n            end,\n            curr = 0,\n            next = 0;\n          var result = '';\n          while (match = breakRe.exec(line)) {\n            next = match.index;\n            if (next - start > width) {\n              end = curr > start ? curr : next; // derive end <= length-2\n              result += '\\n' + line.slice(start, end);\n              start = end + 1; // derive start <= length-1\n            }\n\n            curr = next;\n          }\n          result += '\\n';\n          if (line.length - start > width && curr > start) {\n            result += line.slice(start, curr) + '\\n' + line.slice(curr + 1);\n          } else {\n            result += line.slice(start);\n          }\n          return result.slice(1); // drop extra \\n joiner\n        }\n\n        function escapeString(string) {\n          var result = '';\n          var char, nextChar;\n          var escapeSeq;\n          for (var i = 0; i < string.length; i++) {\n            char = string.charCodeAt(i);\n            if (char >= 0xD800 && char <= 0xDBFF /* high surrogate */) {\n              nextChar = string.charCodeAt(i + 1);\n              if (nextChar >= 0xDC00 && nextChar <= 0xDFFF /* low surrogate */) {\n                result += encodeHex((char - 0xD800) * 0x400 + nextChar - 0xDC00 + 0x10000);\n                i++;\n                continue;\n              }\n            }\n            escapeSeq = ESCAPE_SEQUENCES[char];\n            result += !escapeSeq && isPrintable(char) ? string[i] : escapeSeq || encodeHex(char);\n          }\n          return result;\n        }\n        function writeFlowSequence(state, level, object) {\n          var _result = '',\n            _tag = state.tag,\n            index,\n            length;\n          for (index = 0, length = object.length; index < length; index += 1) {\n            if (writeNode(state, level, object[index], false, false)) {\n              if (index !== 0) _result += ',' + (!state.condenseFlow ? ' ' : '');\n              _result += state.dump;\n            }\n          }\n          state.tag = _tag;\n          state.dump = '[' + _result + ']';\n        }\n        function writeBlockSequence(state, level, object, compact) {\n          var _result = '',\n            _tag = state.tag,\n            index,\n            length;\n          for (index = 0, length = object.length; index < length; index += 1) {\n            if (writeNode(state, level + 1, object[index], true, true)) {\n              if (!compact || index !== 0) {\n                _result += generateNextLine(state, level);\n              }\n              if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n                _result += '-';\n              } else {\n                _result += '- ';\n              }\n              _result += state.dump;\n            }\n          }\n          state.tag = _tag;\n          state.dump = _result || '[]'; // Empty sequence if no valid values.\n        }\n\n        function writeFlowMapping(state, level, object) {\n          var _result = '',\n            _tag = state.tag,\n            objectKeyList = Object.keys(object),\n            index,\n            length,\n            objectKey,\n            objectValue,\n            pairBuffer;\n          for (index = 0, length = objectKeyList.length; index < length; index += 1) {\n            pairBuffer = state.condenseFlow ? '\"' : '';\n            if (index !== 0) pairBuffer += ', ';\n            objectKey = objectKeyList[index];\n            objectValue = object[objectKey];\n            if (!writeNode(state, level, objectKey, false, false)) {\n              continue; // Skip this pair because of invalid key;\n            }\n\n            if (state.dump.length > 1024) pairBuffer += '? ';\n            pairBuffer += state.dump + (state.condenseFlow ? '\"' : '') + ':' + (state.condenseFlow ? '' : ' ');\n            if (!writeNode(state, level, objectValue, false, false)) {\n              continue; // Skip this pair because of invalid value.\n            }\n\n            pairBuffer += state.dump;\n            _result += pairBuffer;\n          }\n          state.tag = _tag;\n          state.dump = '{' + _result + '}';\n        }\n        function writeBlockMapping(state, level, object, compact) {\n          var _result = '',\n            _tag = state.tag,\n            objectKeyList = Object.keys(object),\n            index,\n            length,\n            objectKey,\n            objectValue,\n            explicitPair,\n            pairBuffer;\n          if (state.sortKeys === true) {\n            objectKeyList.sort();\n          } else if (typeof state.sortKeys === 'function') {\n            objectKeyList.sort(state.sortKeys);\n          } else if (state.sortKeys) {\n            throw new YAMLException('sortKeys must be a boolean or a function');\n          }\n          for (index = 0, length = objectKeyList.length; index < length; index += 1) {\n            pairBuffer = '';\n            if (!compact || index !== 0) {\n              pairBuffer += generateNextLine(state, level);\n            }\n            objectKey = objectKeyList[index];\n            objectValue = object[objectKey];\n            if (!writeNode(state, level + 1, objectKey, true, true, true)) {\n              continue; // Skip this pair because of invalid key.\n            }\n\n            explicitPair = state.tag !== null && state.tag !== '?' || state.dump && state.dump.length > 1024;\n            if (explicitPair) {\n              if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n                pairBuffer += '?';\n              } else {\n                pairBuffer += '? ';\n              }\n            }\n            pairBuffer += state.dump;\n            if (explicitPair) {\n              pairBuffer += generateNextLine(state, level);\n            }\n            if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {\n              continue; // Skip this pair because of invalid value.\n            }\n\n            if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n              pairBuffer += ':';\n            } else {\n              pairBuffer += ': ';\n            }\n            pairBuffer += state.dump;\n            _result += pairBuffer;\n          }\n          state.tag = _tag;\n          state.dump = _result || '{}'; // Empty mapping if no valid pairs.\n        }\n\n        function detectType(state, object, explicit) {\n          var _result, typeList, index, length, type, style;\n          typeList = explicit ? state.explicitTypes : state.implicitTypes;\n          for (index = 0, length = typeList.length; index < length; index += 1) {\n            type = typeList[index];\n            if ((type.instanceOf || type.predicate) && (!type.instanceOf || typeof object === 'object' && object instanceof type.instanceOf) && (!type.predicate || type.predicate(object))) {\n              state.tag = explicit ? type.tag : '?';\n              if (type.represent) {\n                style = state.styleMap[type.tag] || type.defaultStyle;\n                if (_toString.call(type.represent) === '[object Function]') {\n                  _result = type.represent(object, style);\n                } else if (_hasOwnProperty.call(type.represent, style)) {\n                  _result = type.represent[style](object, style);\n                } else {\n                  throw new YAMLException('!<' + type.tag + '> tag resolver accepts not \"' + style + '\" style');\n                }\n                state.dump = _result;\n              }\n              return true;\n            }\n          }\n          return false;\n        }\n        function writeNode(state, level, object, block, compact, iskey) {\n          state.tag = null;\n          state.dump = object;\n          if (!detectType(state, object, false)) {\n            detectType(state, object, true);\n          }\n          var type = _toString.call(state.dump);\n          if (block) {\n            block = state.flowLevel < 0 || state.flowLevel > level;\n          }\n          var objectOrArray = type === '[object Object]' || type === '[object Array]',\n            duplicateIndex,\n            duplicate;\n          if (objectOrArray) {\n            duplicateIndex = state.duplicates.indexOf(object);\n            duplicate = duplicateIndex !== -1;\n          }\n          if (state.tag !== null && state.tag !== '?' || duplicate || state.indent !== 2 && level > 0) {\n            compact = false;\n          }\n          if (duplicate && state.usedDuplicates[duplicateIndex]) {\n            state.dump = '*ref_' + duplicateIndex;\n          } else {\n            if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {\n              state.usedDuplicates[duplicateIndex] = true;\n            }\n            if (type === '[object Object]') {\n              if (block && Object.keys(state.dump).length !== 0) {\n                writeBlockMapping(state, level, state.dump, compact);\n                if (duplicate) {\n                  state.dump = '&ref_' + duplicateIndex + state.dump;\n                }\n              } else {\n                writeFlowMapping(state, level, state.dump);\n                if (duplicate) {\n                  state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;\n                }\n              }\n            } else if (type === '[object Array]') {\n              var arrayLevel = state.noArrayIndent && level > 0 ? level - 1 : level;\n              if (block && state.dump.length !== 0) {\n                writeBlockSequence(state, arrayLevel, state.dump, compact);\n                if (duplicate) {\n                  state.dump = '&ref_' + duplicateIndex + state.dump;\n                }\n              } else {\n                writeFlowSequence(state, arrayLevel, state.dump);\n                if (duplicate) {\n                  state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;\n                }\n              }\n            } else if (type === '[object String]') {\n              if (state.tag !== '?') {\n                writeScalar(state, state.dump, level, iskey);\n              }\n            } else {\n              if (state.skipInvalid) return false;\n              throw new YAMLException('unacceptable kind of an object to dump ' + type);\n            }\n            if (state.tag !== null && state.tag !== '?') {\n              state.dump = '!<' + state.tag + '> ' + state.dump;\n            }\n          }\n          return true;\n        }\n        function getDuplicateReferences(object, state) {\n          var objects = [],\n            duplicatesIndexes = [],\n            index,\n            length;\n          inspectNode(object, objects, duplicatesIndexes);\n          for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {\n            state.duplicates.push(objects[duplicatesIndexes[index]]);\n          }\n          state.usedDuplicates = new Array(length);\n        }\n        function inspectNode(object, objects, duplicatesIndexes) {\n          var objectKeyList, index, length;\n          if (object !== null && typeof object === 'object') {\n            index = objects.indexOf(object);\n            if (index !== -1) {\n              if (duplicatesIndexes.indexOf(index) === -1) {\n                duplicatesIndexes.push(index);\n              }\n            } else {\n              objects.push(object);\n              if (Array.isArray(object)) {\n                for (index = 0, length = object.length; index < length; index += 1) {\n                  inspectNode(object[index], objects, duplicatesIndexes);\n                }\n              } else {\n                objectKeyList = Object.keys(object);\n                for (index = 0, length = objectKeyList.length; index < length; index += 1) {\n                  inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);\n                }\n              }\n            }\n          }\n        }\n        function dump(input, options) {\n          options = options || {};\n          var state = new State(options);\n          if (!state.noRefs) getDuplicateReferences(input, state);\n          if (writeNode(state, 0, input, true, true)) return state.dump + '\\n';\n          return '';\n        }\n        function safeDump(input, options) {\n          return dump(input, common.extend({\n            schema: DEFAULT_SAFE_SCHEMA\n          }, options));\n        }\n        module.exports.dump = dump;\n        module.exports.safeDump = safeDump;\n      }, {\n        \"./common\": 5,\n        \"./exception\": 7,\n        \"./schema/default_full\": 12,\n        \"./schema/default_safe\": 13\n      }],\n      7: [function (require, module, exports) {\n        'use strict';\n\n        function YAMLException(reason, mark) {\n          Error.call(this);\n          this.name = 'YAMLException';\n          this.reason = reason;\n          this.mark = mark;\n          this.message = (this.reason || '(unknown reason)') + (this.mark ? ' ' + this.mark.toString() : '');\n          if (Error.captureStackTrace) {\n            Error.captureStackTrace(this, this.constructor);\n          } else {\n            this.stack = new Error().stack || '';\n          }\n        }\n        YAMLException.prototype = Object.create(Error.prototype);\n        YAMLException.prototype.constructor = YAMLException;\n        YAMLException.prototype.toString = function toString(compact) {\n          var result = this.name + ': ';\n          result += this.reason || '(unknown reason)';\n          if (!compact && this.mark) {\n            result += ' ' + this.mark.toString();\n          }\n          return result;\n        };\n        module.exports = YAMLException;\n      }, {}],\n      8: [function (require, module, exports) {\n        'use strict';\n\n        var common = require('./common');\n        var YAMLException = require('./exception');\n        var Mark = require('./mark');\n        var DEFAULT_SAFE_SCHEMA = require('./schema/default_safe');\n        var DEFAULT_FULL_SCHEMA = require('./schema/default_full');\n        var _hasOwnProperty = Object.prototype.hasOwnProperty;\n        var CONTEXT_FLOW_IN = 1;\n        var CONTEXT_FLOW_OUT = 2;\n        var CONTEXT_BLOCK_IN = 3;\n        var CONTEXT_BLOCK_OUT = 4;\n        var CHOMPING_CLIP = 1;\n        var CHOMPING_STRIP = 2;\n        var CHOMPING_KEEP = 3;\n        var PATTERN_NON_PRINTABLE = /[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F-\\x84\\x86-\\x9F\\uFFFE\\uFFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]/;\n        var PATTERN_NON_ASCII_LINE_BREAKS = /[\\x85\\u2028\\u2029]/;\n        var PATTERN_FLOW_INDICATORS = /[,\\[\\]\\{\\}]/;\n        var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\\-]+!)$/i;\n        var PATTERN_TAG_URI = /^(?:!|[^,\\[\\]\\{\\}])(?:%[0-9a-f]{2}|[0-9a-z\\-#;\\/\\?:@&=\\+\\$,_\\.!~\\*'\\(\\)\\[\\]])*$/i;\n        function is_EOL(c) {\n          return c === 0x0A /* LF */ || c === 0x0D /* CR */;\n        }\n\n        function is_WHITE_SPACE(c) {\n          return c === 0x09 /* Tab */ || c === 0x20 /* Space */;\n        }\n\n        function is_WS_OR_EOL(c) {\n          return c === 0x09 /* Tab */ || c === 0x20 /* Space */ || c === 0x0A /* LF */ || c === 0x0D /* CR */;\n        }\n\n        function is_FLOW_INDICATOR(c) {\n          return c === 0x2C /* , */ || c === 0x5B /* [ */ || c === 0x5D /* ] */ || c === 0x7B /* { */ || c === 0x7D /* } */;\n        }\n\n        function fromHexCode(c) {\n          var lc;\n          if (c /* 0 */ >= 0x30 && c <= 0x39 /* 9 */) {\n            return c - 0x30;\n          }\n          lc = c | 0x20;\n          if (lc /* a */ >= 0x61 && lc <= 0x66 /* f */) {\n            return lc - 0x61 + 10;\n          }\n          return -1;\n        }\n        function escapedHexLen(c) {\n          if (c === 0x78 /* x */) {\n            return 2;\n          }\n          if (c === 0x75 /* u */) {\n            return 4;\n          }\n          if (c === 0x55 /* U */) {\n            return 8;\n          }\n          return 0;\n        }\n        function fromDecimalCode(c) {\n          if (c /* 0 */ >= 0x30 && c <= 0x39 /* 9 */) {\n            return c - 0x30;\n          }\n          return -1;\n        }\n        function simpleEscapeSequence(c) {\n          return c === 0x30 /* 0 */ ? '\\x00' : c === 0x61 /* a */ ? '\\x07' : c === 0x62 /* b */ ? '\\x08' : c === 0x74 /* t */ ? '\\x09' : c === 0x09 /* Tab */ ? '\\x09' : c === 0x6E /* n */ ? '\\x0A' : c === 0x76 /* v */ ? '\\x0B' : c === 0x66 /* f */ ? '\\x0C' : c === 0x72 /* r */ ? '\\x0D' : c === 0x65 /* e */ ? '\\x1B' : c === 0x20 /* Space */ ? ' ' : c === 0x22 /* \" */ ? '\\x22' : c === 0x2F /* / */ ? '/' : c === 0x5C /* \\ */ ? '\\x5C' : c === 0x4E /* N */ ? '\\x85' : c === 0x5F /* _ */ ? '\\xA0' : c === 0x4C /* L */ ? \"\\u2028\" : c === 0x50 /* P */ ? \"\\u2029\" : '';\n        }\n        function charFromCodepoint(c) {\n          if (c <= 0xFFFF) {\n            return String.fromCharCode(c);\n          }\n          return String.fromCharCode((c - 0x010000 >> 10) + 0xD800, (c - 0x010000 & 0x03FF) + 0xDC00);\n        }\n        var simpleEscapeCheck = new Array(256); // integer, for fast access\n        var simpleEscapeMap = new Array(256);\n        for (var i = 0; i < 256; i++) {\n          simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;\n          simpleEscapeMap[i] = simpleEscapeSequence(i);\n        }\n        function State(input, options) {\n          this.input = input;\n          this.filename = options['filename'] || null;\n          this.schema = options['schema'] || DEFAULT_FULL_SCHEMA;\n          this.onWarning = options['onWarning'] || null;\n          this.legacy = options['legacy'] || false;\n          this.json = options['json'] || false;\n          this.listener = options['listener'] || null;\n          this.implicitTypes = this.schema.compiledImplicit;\n          this.typeMap = this.schema.compiledTypeMap;\n          this.length = input.length;\n          this.position = 0;\n          this.line = 0;\n          this.lineStart = 0;\n          this.lineIndent = 0;\n          this.documents = [];\n        }\n        function generateError(state, message) {\n          return new YAMLException(message, new Mark(state.filename, state.input, state.position, state.line, state.position - state.lineStart));\n        }\n        function throwError(state, message) {\n          throw generateError(state, message);\n        }\n        function throwWarning(state, message) {\n          if (state.onWarning) {\n            state.onWarning.call(null, generateError(state, message));\n          }\n        }\n        var directiveHandlers = {\n          YAML: function handleYamlDirective(state, name, args) {\n            var match, major, minor;\n            if (state.version !== null) {\n              throwError(state, 'duplication of %YAML directive');\n            }\n            if (args.length !== 1) {\n              throwError(state, 'YAML directive accepts exactly one argument');\n            }\n            match = /^([0-9]+)\\.([0-9]+)$/.exec(args[0]);\n            if (match === null) {\n              throwError(state, 'ill-formed argument of the YAML directive');\n            }\n            major = parseInt(match[1], 10);\n            minor = parseInt(match[2], 10);\n            if (major !== 1) {\n              throwError(state, 'unacceptable YAML version of the document');\n            }\n            state.version = args[0];\n            state.checkLineBreaks = minor < 2;\n            if (minor !== 1 && minor !== 2) {\n              throwWarning(state, 'unsupported YAML version of the document');\n            }\n          },\n          TAG: function handleTagDirective(state, name, args) {\n            var handle, prefix;\n            if (args.length !== 2) {\n              throwError(state, 'TAG directive accepts exactly two arguments');\n            }\n            handle = args[0];\n            prefix = args[1];\n            if (!PATTERN_TAG_HANDLE.test(handle)) {\n              throwError(state, 'ill-formed tag handle (first argument) of the TAG directive');\n            }\n            if (_hasOwnProperty.call(state.tagMap, handle)) {\n              throwError(state, 'there is a previously declared suffix for \"' + handle + '\" tag handle');\n            }\n            if (!PATTERN_TAG_URI.test(prefix)) {\n              throwError(state, 'ill-formed tag prefix (second argument) of the TAG directive');\n            }\n            state.tagMap[handle] = prefix;\n          }\n        };\n        function captureSegment(state, start, end, checkJson) {\n          var _position, _length, _character, _result;\n          if (start < end) {\n            _result = state.input.slice(start, end);\n            if (checkJson) {\n              for (_position = 0, _length = _result.length; _position < _length; _position += 1) {\n                _character = _result.charCodeAt(_position);\n                if (!(_character === 0x09 || _character >= 0x20 && _character <= 0x10FFFF)) {\n                  throwError(state, 'expected valid JSON character');\n                }\n              }\n            } else if (PATTERN_NON_PRINTABLE.test(_result)) {\n              throwError(state, 'the stream contains non-printable characters');\n            }\n            state.result += _result;\n          }\n        }\n        function mergeMappings(state, destination, source, overridableKeys) {\n          var sourceKeys, key, index, quantity;\n          if (!common.isObject(source)) {\n            throwError(state, 'cannot merge mappings; the provided source object is unacceptable');\n          }\n          sourceKeys = Object.keys(source);\n          for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {\n            key = sourceKeys[index];\n            if (!_hasOwnProperty.call(destination, key)) {\n              destination[key] = source[key];\n              overridableKeys[key] = true;\n            }\n          }\n        }\n        function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startPos) {\n          var index, quantity;\n          keyNode = String(keyNode);\n          if (_result === null) {\n            _result = {};\n          }\n          if (keyTag === 'tag:yaml.org,2002:merge') {\n            if (Array.isArray(valueNode)) {\n              for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {\n                mergeMappings(state, _result, valueNode[index], overridableKeys);\n              }\n            } else {\n              mergeMappings(state, _result, valueNode, overridableKeys);\n            }\n          } else {\n            if (!state.json && !_hasOwnProperty.call(overridableKeys, keyNode) && _hasOwnProperty.call(_result, keyNode)) {\n              state.line = startLine || state.line;\n              state.position = startPos || state.position;\n              throwError(state, 'duplicated mapping key');\n            }\n            _result[keyNode] = valueNode;\n            delete overridableKeys[keyNode];\n          }\n          return _result;\n        }\n        function readLineBreak(state) {\n          var ch;\n          ch = state.input.charCodeAt(state.position);\n          if (ch === 0x0A /* LF */) {\n            state.position++;\n          } else if (ch === 0x0D /* CR */) {\n            state.position++;\n            if (state.input.charCodeAt(state.position) === 0x0A /* LF */) {\n              state.position++;\n            }\n          } else {\n            throwError(state, 'a line break is expected');\n          }\n          state.line += 1;\n          state.lineStart = state.position;\n        }\n        function skipSeparationSpace(state, allowComments, checkIndent) {\n          var lineBreaks = 0,\n            ch = state.input.charCodeAt(state.position);\n          while (ch !== 0) {\n            while (is_WHITE_SPACE(ch)) {\n              ch = state.input.charCodeAt(++state.position);\n            }\n            if (allowComments && ch === 0x23 /* # */) {\n              do {\n                ch = state.input.charCodeAt(++state.position);\n              } while (ch !== 0x0A /* LF */ && ch !== 0x0D /* CR */ && ch !== 0);\n            }\n            if (is_EOL(ch)) {\n              readLineBreak(state);\n              ch = state.input.charCodeAt(state.position);\n              lineBreaks++;\n              state.lineIndent = 0;\n              while (ch === 0x20 /* Space */) {\n                state.lineIndent++;\n                ch = state.input.charCodeAt(++state.position);\n              }\n            } else {\n              break;\n            }\n          }\n          if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {\n            throwWarning(state, 'deficient indentation');\n          }\n          return lineBreaks;\n        }\n        function testDocumentSeparator(state) {\n          var _position = state.position,\n            ch;\n          ch = state.input.charCodeAt(_position);\n          if ((ch === 0x2D /* - */ || ch === 0x2E /* . */) && ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2)) {\n            _position += 3;\n            ch = state.input.charCodeAt(_position);\n            if (ch === 0 || is_WS_OR_EOL(ch)) {\n              return true;\n            }\n          }\n          return false;\n        }\n        function writeFoldedLines(state, count) {\n          if (count === 1) {\n            state.result += ' ';\n          } else if (count > 1) {\n            state.result += common.repeat('\\n', count - 1);\n          }\n        }\n        function readPlainScalar(state, nodeIndent, withinFlowCollection) {\n          var preceding,\n            following,\n            captureStart,\n            captureEnd,\n            hasPendingContent,\n            _line,\n            _lineStart,\n            _lineIndent,\n            _kind = state.kind,\n            _result = state.result,\n            ch;\n          ch = state.input.charCodeAt(state.position);\n          if (is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 0x23 /* # */ || ch === 0x26 /* & */ || ch === 0x2A /* * */ || ch === 0x21 /* ! */ || ch === 0x7C /* | */ || ch === 0x3E /* > */ || ch === 0x27 /* ' */ || ch === 0x22 /* \" */ || ch === 0x25 /* % */ || ch === 0x40 /* @ */ || ch === 0x60 /* ` */) {\n            return false;\n          }\n          if (ch === 0x3F /* ? */ || ch === 0x2D /* - */) {\n            following = state.input.charCodeAt(state.position + 1);\n            if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {\n              return false;\n            }\n          }\n          state.kind = 'scalar';\n          state.result = '';\n          captureStart = captureEnd = state.position;\n          hasPendingContent = false;\n          while (ch !== 0) {\n            if (ch === 0x3A /* : */) {\n              following = state.input.charCodeAt(state.position + 1);\n              if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {\n                break;\n              }\n            } else if (ch === 0x23 /* # */) {\n              preceding = state.input.charCodeAt(state.position - 1);\n              if (is_WS_OR_EOL(preceding)) {\n                break;\n              }\n            } else if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch)) {\n              break;\n            } else if (is_EOL(ch)) {\n              _line = state.line;\n              _lineStart = state.lineStart;\n              _lineIndent = state.lineIndent;\n              skipSeparationSpace(state, false, -1);\n              if (state.lineIndent >= nodeIndent) {\n                hasPendingContent = true;\n                ch = state.input.charCodeAt(state.position);\n                continue;\n              } else {\n                state.position = captureEnd;\n                state.line = _line;\n                state.lineStart = _lineStart;\n                state.lineIndent = _lineIndent;\n                break;\n              }\n            }\n            if (hasPendingContent) {\n              captureSegment(state, captureStart, captureEnd, false);\n              writeFoldedLines(state, state.line - _line);\n              captureStart = captureEnd = state.position;\n              hasPendingContent = false;\n            }\n            if (!is_WHITE_SPACE(ch)) {\n              captureEnd = state.position + 1;\n            }\n            ch = state.input.charCodeAt(++state.position);\n          }\n          captureSegment(state, captureStart, captureEnd, false);\n          if (state.result) {\n            return true;\n          }\n          state.kind = _kind;\n          state.result = _result;\n          return false;\n        }\n        function readSingleQuotedScalar(state, nodeIndent) {\n          var ch, captureStart, captureEnd;\n          ch = state.input.charCodeAt(state.position);\n          if (ch !== 0x27 /* ' */) {\n            return false;\n          }\n          state.kind = 'scalar';\n          state.result = '';\n          state.position++;\n          captureStart = captureEnd = state.position;\n          while ((ch = state.input.charCodeAt(state.position)) !== 0) {\n            if (ch === 0x27 /* ' */) {\n              captureSegment(state, captureStart, state.position, true);\n              ch = state.input.charCodeAt(++state.position);\n              if (ch === 0x27 /* ' */) {\n                captureStart = state.position;\n                state.position++;\n                captureEnd = state.position;\n              } else {\n                return true;\n              }\n            } else if (is_EOL(ch)) {\n              captureSegment(state, captureStart, captureEnd, true);\n              writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));\n              captureStart = captureEnd = state.position;\n            } else if (state.position === state.lineStart && testDocumentSeparator(state)) {\n              throwError(state, 'unexpected end of the document within a single quoted scalar');\n            } else {\n              state.position++;\n              captureEnd = state.position;\n            }\n          }\n          throwError(state, 'unexpected end of the stream within a single quoted scalar');\n        }\n        function readDoubleQuotedScalar(state, nodeIndent) {\n          var captureStart, captureEnd, hexLength, hexResult, tmp, ch;\n          ch = state.input.charCodeAt(state.position);\n          if (ch !== 0x22 /* \" */) {\n            return false;\n          }\n          state.kind = 'scalar';\n          state.result = '';\n          state.position++;\n          captureStart = captureEnd = state.position;\n          while ((ch = state.input.charCodeAt(state.position)) !== 0) {\n            if (ch === 0x22 /* \" */) {\n              captureSegment(state, captureStart, state.position, true);\n              state.position++;\n              return true;\n            } else if (ch === 0x5C /* \\ */) {\n              captureSegment(state, captureStart, state.position, true);\n              ch = state.input.charCodeAt(++state.position);\n              if (is_EOL(ch)) {\n                skipSeparationSpace(state, false, nodeIndent);\n              } else if (ch < 256 && simpleEscapeCheck[ch]) {\n                state.result += simpleEscapeMap[ch];\n                state.position++;\n              } else if ((tmp = escapedHexLen(ch)) > 0) {\n                hexLength = tmp;\n                hexResult = 0;\n                for (; hexLength > 0; hexLength--) {\n                  ch = state.input.charCodeAt(++state.position);\n                  if ((tmp = fromHexCode(ch)) >= 0) {\n                    hexResult = (hexResult << 4) + tmp;\n                  } else {\n                    throwError(state, 'expected hexadecimal character');\n                  }\n                }\n                state.result += charFromCodepoint(hexResult);\n                state.position++;\n              } else {\n                throwError(state, 'unknown escape sequence');\n              }\n              captureStart = captureEnd = state.position;\n            } else if (is_EOL(ch)) {\n              captureSegment(state, captureStart, captureEnd, true);\n              writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));\n              captureStart = captureEnd = state.position;\n            } else if (state.position === state.lineStart && testDocumentSeparator(state)) {\n              throwError(state, 'unexpected end of the document within a double quoted scalar');\n            } else {\n              state.position++;\n              captureEnd = state.position;\n            }\n          }\n          throwError(state, 'unexpected end of the stream within a double quoted scalar');\n        }\n        function readFlowCollection(state, nodeIndent) {\n          var readNext = true,\n            _line,\n            _tag = state.tag,\n            _result,\n            _anchor = state.anchor,\n            following,\n            terminator,\n            isPair,\n            isExplicitPair,\n            isMapping,\n            overridableKeys = {},\n            keyNode,\n            keyTag,\n            valueNode,\n            ch;\n          ch = state.input.charCodeAt(state.position);\n          if (ch === 0x5B /* [ */) {\n            terminator = 0x5D;\n            isMapping = false;\n            _result = [];\n          } else if (ch === 0x7B /* { */) {\n            terminator = 0x7D;\n            isMapping = true;\n            _result = {};\n          } else {\n            return false;\n          }\n          if (state.anchor !== null) {\n            state.anchorMap[state.anchor] = _result;\n          }\n          ch = state.input.charCodeAt(++state.position);\n          while (ch !== 0) {\n            skipSeparationSpace(state, true, nodeIndent);\n            ch = state.input.charCodeAt(state.position);\n            if (ch === terminator) {\n              state.position++;\n              state.tag = _tag;\n              state.anchor = _anchor;\n              state.kind = isMapping ? 'mapping' : 'sequence';\n              state.result = _result;\n              return true;\n            } else if (!readNext) {\n              throwError(state, 'missed comma between flow collection entries');\n            }\n            keyTag = keyNode = valueNode = null;\n            isPair = isExplicitPair = false;\n            if (ch === 0x3F /* ? */) {\n              following = state.input.charCodeAt(state.position + 1);\n              if (is_WS_OR_EOL(following)) {\n                isPair = isExplicitPair = true;\n                state.position++;\n                skipSeparationSpace(state, true, nodeIndent);\n              }\n            }\n            _line = state.line;\n            composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);\n            keyTag = state.tag;\n            keyNode = state.result;\n            skipSeparationSpace(state, true, nodeIndent);\n            ch = state.input.charCodeAt(state.position);\n            if ((isExplicitPair || state.line === _line) && ch === 0x3A /* : */) {\n              isPair = true;\n              ch = state.input.charCodeAt(++state.position);\n              skipSeparationSpace(state, true, nodeIndent);\n              composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);\n              valueNode = state.result;\n            }\n            if (isMapping) {\n              storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode);\n            } else if (isPair) {\n              _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode));\n            } else {\n              _result.push(keyNode);\n            }\n            skipSeparationSpace(state, true, nodeIndent);\n            ch = state.input.charCodeAt(state.position);\n            if (ch === 0x2C /* , */) {\n              readNext = true;\n              ch = state.input.charCodeAt(++state.position);\n            } else {\n              readNext = false;\n            }\n          }\n          throwError(state, 'unexpected end of the stream within a flow collection');\n        }\n        function readBlockScalar(state, nodeIndent) {\n          var captureStart,\n            folding,\n            chomping = CHOMPING_CLIP,\n            didReadContent = false,\n            detectedIndent = false,\n            textIndent = nodeIndent,\n            emptyLines = 0,\n            atMoreIndented = false,\n            tmp,\n            ch;\n          ch = state.input.charCodeAt(state.position);\n          if (ch === 0x7C /* | */) {\n            folding = false;\n          } else if (ch === 0x3E /* > */) {\n            folding = true;\n          } else {\n            return false;\n          }\n          state.kind = 'scalar';\n          state.result = '';\n          while (ch !== 0) {\n            ch = state.input.charCodeAt(++state.position);\n            if (ch === 0x2B /* + */ || ch === 0x2D /* - */) {\n              if (CHOMPING_CLIP === chomping) {\n                chomping = ch === 0x2B /* + */ ? CHOMPING_KEEP : CHOMPING_STRIP;\n              } else {\n                throwError(state, 'repeat of a chomping mode identifier');\n              }\n            } else if ((tmp = fromDecimalCode(ch)) >= 0) {\n              if (tmp === 0) {\n                throwError(state, 'bad explicit indentation width of a block scalar; it cannot be less than one');\n              } else if (!detectedIndent) {\n                textIndent = nodeIndent + tmp - 1;\n                detectedIndent = true;\n              } else {\n                throwError(state, 'repeat of an indentation width identifier');\n              }\n            } else {\n              break;\n            }\n          }\n          if (is_WHITE_SPACE(ch)) {\n            do {\n              ch = state.input.charCodeAt(++state.position);\n            } while (is_WHITE_SPACE(ch));\n            if (ch === 0x23 /* # */) {\n              do {\n                ch = state.input.charCodeAt(++state.position);\n              } while (!is_EOL(ch) && ch !== 0);\n            }\n          }\n          while (ch !== 0) {\n            readLineBreak(state);\n            state.lineIndent = 0;\n            ch = state.input.charCodeAt(state.position);\n            while ((!detectedIndent || state.lineIndent < textIndent) && ch === 0x20 /* Space */) {\n              state.lineIndent++;\n              ch = state.input.charCodeAt(++state.position);\n            }\n            if (!detectedIndent && state.lineIndent > textIndent) {\n              textIndent = state.lineIndent;\n            }\n            if (is_EOL(ch)) {\n              emptyLines++;\n              continue;\n            }\n            if (state.lineIndent < textIndent) {\n              if (chomping === CHOMPING_KEEP) {\n                state.result += common.repeat('\\n', didReadContent ? 1 + emptyLines : emptyLines);\n              } else if (chomping === CHOMPING_CLIP) {\n                if (didReadContent) {\n                  // i.e. only if the scalar is not empty.\n                  state.result += '\\n';\n                }\n              }\n              break;\n            }\n            if (folding) {\n              if (is_WHITE_SPACE(ch)) {\n                atMoreIndented = true;\n                state.result += common.repeat('\\n', didReadContent ? 1 + emptyLines : emptyLines);\n              } else if (atMoreIndented) {\n                atMoreIndented = false;\n                state.result += common.repeat('\\n', emptyLines + 1);\n              } else if (emptyLines === 0) {\n                if (didReadContent) {\n                  // i.e. only if we have already read some scalar content.\n                  state.result += ' ';\n                }\n              } else {\n                state.result += common.repeat('\\n', emptyLines);\n              }\n            } else {\n              state.result += common.repeat('\\n', didReadContent ? 1 + emptyLines : emptyLines);\n            }\n            didReadContent = true;\n            detectedIndent = true;\n            emptyLines = 0;\n            captureStart = state.position;\n            while (!is_EOL(ch) && ch !== 0) {\n              ch = state.input.charCodeAt(++state.position);\n            }\n            captureSegment(state, captureStart, state.position, false);\n          }\n          return true;\n        }\n        function readBlockSequence(state, nodeIndent) {\n          var _line,\n            _tag = state.tag,\n            _anchor = state.anchor,\n            _result = [],\n            following,\n            detected = false,\n            ch;\n          if (state.anchor !== null) {\n            state.anchorMap[state.anchor] = _result;\n          }\n          ch = state.input.charCodeAt(state.position);\n          while (ch !== 0) {\n            if (ch !== 0x2D /* - */) {\n              break;\n            }\n            following = state.input.charCodeAt(state.position + 1);\n            if (!is_WS_OR_EOL(following)) {\n              break;\n            }\n            detected = true;\n            state.position++;\n            if (skipSeparationSpace(state, true, -1)) {\n              if (state.lineIndent <= nodeIndent) {\n                _result.push(null);\n                ch = state.input.charCodeAt(state.position);\n                continue;\n              }\n            }\n            _line = state.line;\n            composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);\n            _result.push(state.result);\n            skipSeparationSpace(state, true, -1);\n            ch = state.input.charCodeAt(state.position);\n            if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {\n              throwError(state, 'bad indentation of a sequence entry');\n            } else if (state.lineIndent < nodeIndent) {\n              break;\n            }\n          }\n          if (detected) {\n            state.tag = _tag;\n            state.anchor = _anchor;\n            state.kind = 'sequence';\n            state.result = _result;\n            return true;\n          }\n          return false;\n        }\n        function readBlockMapping(state, nodeIndent, flowIndent) {\n          var following,\n            allowCompact,\n            _line,\n            _pos,\n            _tag = state.tag,\n            _anchor = state.anchor,\n            _result = {},\n            overridableKeys = {},\n            keyTag = null,\n            keyNode = null,\n            valueNode = null,\n            atExplicitKey = false,\n            detected = false,\n            ch;\n          if (state.anchor !== null) {\n            state.anchorMap[state.anchor] = _result;\n          }\n          ch = state.input.charCodeAt(state.position);\n          while (ch !== 0) {\n            following = state.input.charCodeAt(state.position + 1);\n            _line = state.line; // Save the current line.\n            _pos = state.position;\n            if ((ch === 0x3F /* ? */ || ch === 0x3A /* : */) && is_WS_OR_EOL(following)) {\n              if (ch === 0x3F /* ? */) {\n                if (atExplicitKey) {\n                  storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);\n                  keyTag = keyNode = valueNode = null;\n                }\n                detected = true;\n                atExplicitKey = true;\n                allowCompact = true;\n              } else if (atExplicitKey) {\n                atExplicitKey = false;\n                allowCompact = true;\n              } else {\n                throwError(state, 'incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line');\n              }\n              state.position += 1;\n              ch = following;\n            } else if (composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {\n              if (state.line === _line) {\n                ch = state.input.charCodeAt(state.position);\n                while (is_WHITE_SPACE(ch)) {\n                  ch = state.input.charCodeAt(++state.position);\n                }\n                if (ch === 0x3A /* : */) {\n                  ch = state.input.charCodeAt(++state.position);\n                  if (!is_WS_OR_EOL(ch)) {\n                    throwError(state, 'a whitespace character is expected after the key-value separator within a block mapping');\n                  }\n                  if (atExplicitKey) {\n                    storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);\n                    keyTag = keyNode = valueNode = null;\n                  }\n                  detected = true;\n                  atExplicitKey = false;\n                  allowCompact = false;\n                  keyTag = state.tag;\n                  keyNode = state.result;\n                } else if (detected) {\n                  throwError(state, 'can not read an implicit mapping pair; a colon is missed');\n                } else {\n                  state.tag = _tag;\n                  state.anchor = _anchor;\n                  return true; // Keep the result of `composeNode`.\n                }\n              } else if (detected) {\n                throwError(state, 'can not read a block mapping entry; a multiline key may not be an implicit key');\n              } else {\n                state.tag = _tag;\n                state.anchor = _anchor;\n                return true; // Keep the result of `composeNode`.\n              }\n            } else {\n              break; // Reading is done. Go to the epilogue.\n            }\n\n            if (state.line === _line || state.lineIndent > nodeIndent) {\n              if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {\n                if (atExplicitKey) {\n                  keyNode = state.result;\n                } else {\n                  valueNode = state.result;\n                }\n              }\n              if (!atExplicitKey) {\n                storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _pos);\n                keyTag = keyNode = valueNode = null;\n              }\n              skipSeparationSpace(state, true, -1);\n              ch = state.input.charCodeAt(state.position);\n            }\n            if (state.lineIndent > nodeIndent && ch !== 0) {\n              throwError(state, 'bad indentation of a mapping entry');\n            } else if (state.lineIndent < nodeIndent) {\n              break;\n            }\n          }\n          if (atExplicitKey) {\n            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);\n          }\n          if (detected) {\n            state.tag = _tag;\n            state.anchor = _anchor;\n            state.kind = 'mapping';\n            state.result = _result;\n          }\n          return detected;\n        }\n        function readTagProperty(state) {\n          var _position,\n            isVerbatim = false,\n            isNamed = false,\n            tagHandle,\n            tagName,\n            ch;\n          ch = state.input.charCodeAt(state.position);\n          if (ch !== 0x21 /* ! */) return false;\n          if (state.tag !== null) {\n            throwError(state, 'duplication of a tag property');\n          }\n          ch = state.input.charCodeAt(++state.position);\n          if (ch === 0x3C /* < */) {\n            isVerbatim = true;\n            ch = state.input.charCodeAt(++state.position);\n          } else if (ch === 0x21 /* ! */) {\n            isNamed = true;\n            tagHandle = '!!';\n            ch = state.input.charCodeAt(++state.position);\n          } else {\n            tagHandle = '!';\n          }\n          _position = state.position;\n          if (isVerbatim) {\n            do {\n              ch = state.input.charCodeAt(++state.position);\n            } while (ch !== 0 && ch !== 0x3E /* > */);\n\n            if (state.position < state.length) {\n              tagName = state.input.slice(_position, state.position);\n              ch = state.input.charCodeAt(++state.position);\n            } else {\n              throwError(state, 'unexpected end of the stream within a verbatim tag');\n            }\n          } else {\n            while (ch !== 0 && !is_WS_OR_EOL(ch)) {\n              if (ch === 0x21 /* ! */) {\n                if (!isNamed) {\n                  tagHandle = state.input.slice(_position - 1, state.position + 1);\n                  if (!PATTERN_TAG_HANDLE.test(tagHandle)) {\n                    throwError(state, 'named tag handle cannot contain such characters');\n                  }\n                  isNamed = true;\n                  _position = state.position + 1;\n                } else {\n                  throwError(state, 'tag suffix cannot contain exclamation marks');\n                }\n              }\n              ch = state.input.charCodeAt(++state.position);\n            }\n            tagName = state.input.slice(_position, state.position);\n            if (PATTERN_FLOW_INDICATORS.test(tagName)) {\n              throwError(state, 'tag suffix cannot contain flow indicator characters');\n            }\n          }\n          if (tagName && !PATTERN_TAG_URI.test(tagName)) {\n            throwError(state, 'tag name cannot contain such characters: ' + tagName);\n          }\n          if (isVerbatim) {\n            state.tag = tagName;\n          } else if (_hasOwnProperty.call(state.tagMap, tagHandle)) {\n            state.tag = state.tagMap[tagHandle] + tagName;\n          } else if (tagHandle === '!') {\n            state.tag = '!' + tagName;\n          } else if (tagHandle === '!!') {\n            state.tag = 'tag:yaml.org,2002:' + tagName;\n          } else {\n            throwError(state, 'undeclared tag handle \"' + tagHandle + '\"');\n          }\n          return true;\n        }\n        function readAnchorProperty(state) {\n          var _position, ch;\n          ch = state.input.charCodeAt(state.position);\n          if (ch !== 0x26 /* & */) return false;\n          if (state.anchor !== null) {\n            throwError(state, 'duplication of an anchor property');\n          }\n          ch = state.input.charCodeAt(++state.position);\n          _position = state.position;\n          while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {\n            ch = state.input.charCodeAt(++state.position);\n          }\n          if (state.position === _position) {\n            throwError(state, 'name of an anchor node must contain at least one character');\n          }\n          state.anchor = state.input.slice(_position, state.position);\n          return true;\n        }\n        function readAlias(state) {\n          var _position, alias, ch;\n          ch = state.input.charCodeAt(state.position);\n          if (ch !== 0x2A /* * */) return false;\n          ch = state.input.charCodeAt(++state.position);\n          _position = state.position;\n          while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {\n            ch = state.input.charCodeAt(++state.position);\n          }\n          if (state.position === _position) {\n            throwError(state, 'name of an alias node must contain at least one character');\n          }\n          alias = state.input.slice(_position, state.position);\n          if (!state.anchorMap.hasOwnProperty(alias)) {\n            throwError(state, 'unidentified alias \"' + alias + '\"');\n          }\n          state.result = state.anchorMap[alias];\n          skipSeparationSpace(state, true, -1);\n          return true;\n        }\n        function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {\n          var allowBlockStyles,\n            allowBlockScalars,\n            allowBlockCollections,\n            indentStatus = 1,\n            // 1: this>parent, 0: this=parent, -1: this<parent\n            atNewLine = false,\n            hasContent = false,\n            typeIndex,\n            typeQuantity,\n            type,\n            flowIndent,\n            blockIndent;\n          if (state.listener !== null) {\n            state.listener('open', state);\n          }\n          state.tag = null;\n          state.anchor = null;\n          state.kind = null;\n          state.result = null;\n          allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;\n          if (allowToSeek) {\n            if (skipSeparationSpace(state, true, -1)) {\n              atNewLine = true;\n              if (state.lineIndent > parentIndent) {\n                indentStatus = 1;\n              } else if (state.lineIndent === parentIndent) {\n                indentStatus = 0;\n              } else if (state.lineIndent < parentIndent) {\n                indentStatus = -1;\n              }\n            }\n          }\n          if (indentStatus === 1) {\n            while (readTagProperty(state) || readAnchorProperty(state)) {\n              if (skipSeparationSpace(state, true, -1)) {\n                atNewLine = true;\n                allowBlockCollections = allowBlockStyles;\n                if (state.lineIndent > parentIndent) {\n                  indentStatus = 1;\n                } else if (state.lineIndent === parentIndent) {\n                  indentStatus = 0;\n                } else if (state.lineIndent < parentIndent) {\n                  indentStatus = -1;\n                }\n              } else {\n                allowBlockCollections = false;\n              }\n            }\n          }\n          if (allowBlockCollections) {\n            allowBlockCollections = atNewLine || allowCompact;\n          }\n          if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {\n            if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {\n              flowIndent = parentIndent;\n            } else {\n              flowIndent = parentIndent + 1;\n            }\n            blockIndent = state.position - state.lineStart;\n            if (indentStatus === 1) {\n              if (allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent)) {\n                hasContent = true;\n              } else {\n                if (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent)) {\n                  hasContent = true;\n                } else if (readAlias(state)) {\n                  hasContent = true;\n                  if (state.tag !== null || state.anchor !== null) {\n                    throwError(state, 'alias node should not have any properties');\n                  }\n                } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {\n                  hasContent = true;\n                  if (state.tag === null) {\n                    state.tag = '?';\n                  }\n                }\n                if (state.anchor !== null) {\n                  state.anchorMap[state.anchor] = state.result;\n                }\n              }\n            } else if (indentStatus === 0) {\n              hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);\n            }\n          }\n          if (state.tag !== null && state.tag !== '!') {\n            if (state.tag === '?') {\n              for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {\n                type = state.implicitTypes[typeIndex];\n                if (type.resolve(state.result)) {\n                  // `state.result` updated in resolver if matched\n                  state.result = type.construct(state.result);\n                  state.tag = type.tag;\n                  if (state.anchor !== null) {\n                    state.anchorMap[state.anchor] = state.result;\n                  }\n                  break;\n                }\n              }\n            } else if (_hasOwnProperty.call(state.typeMap[state.kind || 'fallback'], state.tag)) {\n              type = state.typeMap[state.kind || 'fallback'][state.tag];\n              if (state.result !== null && type.kind !== state.kind) {\n                throwError(state, 'unacceptable node kind for !<' + state.tag + '> tag; it should be \"' + type.kind + '\", not \"' + state.kind + '\"');\n              }\n              if (!type.resolve(state.result)) {\n                // `state.result` updated in resolver if matched\n                throwError(state, 'cannot resolve a node with !<' + state.tag + '> explicit tag');\n              } else {\n                state.result = type.construct(state.result);\n                if (state.anchor !== null) {\n                  state.anchorMap[state.anchor] = state.result;\n                }\n              }\n            } else {\n              throwError(state, 'unknown tag !<' + state.tag + '>');\n            }\n          }\n          if (state.listener !== null) {\n            state.listener('close', state);\n          }\n          return state.tag !== null || state.anchor !== null || hasContent;\n        }\n        function readDocument(state) {\n          var documentStart = state.position,\n            _position,\n            directiveName,\n            directiveArgs,\n            hasDirectives = false,\n            ch;\n          state.version = null;\n          state.checkLineBreaks = state.legacy;\n          state.tagMap = {};\n          state.anchorMap = {};\n          while ((ch = state.input.charCodeAt(state.position)) !== 0) {\n            skipSeparationSpace(state, true, -1);\n            ch = state.input.charCodeAt(state.position);\n            if (state.lineIndent > 0 || ch !== 0x25 /* % */) {\n              break;\n            }\n            hasDirectives = true;\n            ch = state.input.charCodeAt(++state.position);\n            _position = state.position;\n            while (ch !== 0 && !is_WS_OR_EOL(ch)) {\n              ch = state.input.charCodeAt(++state.position);\n            }\n            directiveName = state.input.slice(_position, state.position);\n            directiveArgs = [];\n            if (directiveName.length < 1) {\n              throwError(state, 'directive name must not be less than one character in length');\n            }\n            while (ch !== 0) {\n              while (is_WHITE_SPACE(ch)) {\n                ch = state.input.charCodeAt(++state.position);\n              }\n              if (ch === 0x23 /* # */) {\n                do {\n                  ch = state.input.charCodeAt(++state.position);\n                } while (ch !== 0 && !is_EOL(ch));\n                break;\n              }\n              if (is_EOL(ch)) break;\n              _position = state.position;\n              while (ch !== 0 && !is_WS_OR_EOL(ch)) {\n                ch = state.input.charCodeAt(++state.position);\n              }\n              directiveArgs.push(state.input.slice(_position, state.position));\n            }\n            if (ch !== 0) readLineBreak(state);\n            if (_hasOwnProperty.call(directiveHandlers, directiveName)) {\n              directiveHandlers[directiveName](state, directiveName, directiveArgs);\n            } else {\n              throwWarning(state, 'unknown document directive \"' + directiveName + '\"');\n            }\n          }\n          skipSeparationSpace(state, true, -1);\n          if (state.lineIndent === 0 && state.input.charCodeAt(state.position) === 0x2D /* - */ && state.input.charCodeAt(state.position + 1) === 0x2D /* - */ && state.input.charCodeAt(state.position + 2) === 0x2D /* - */) {\n            state.position += 3;\n            skipSeparationSpace(state, true, -1);\n          } else if (hasDirectives) {\n            throwError(state, 'directives end mark is expected');\n          }\n          composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);\n          skipSeparationSpace(state, true, -1);\n          if (state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {\n            throwWarning(state, 'non-ASCII line breaks are interpreted as content');\n          }\n          state.documents.push(state.result);\n          if (state.position === state.lineStart && testDocumentSeparator(state)) {\n            if (state.input.charCodeAt(state.position) === 0x2E /* . */) {\n              state.position += 3;\n              skipSeparationSpace(state, true, -1);\n            }\n            return;\n          }\n          if (state.position < state.length - 1) {\n            throwError(state, 'end of the stream or a document separator is expected');\n          } else {\n            return;\n          }\n        }\n        function loadDocuments(input, options) {\n          input = String(input);\n          options = options || {};\n          if (input.length !== 0) {\n            if (input.charCodeAt(input.length - 1) !== 0x0A /* LF */ && input.charCodeAt(input.length - 1) !== 0x0D /* CR */) {\n              input += '\\n';\n            }\n            if (input.charCodeAt(0) === 0xFEFF) {\n              input = input.slice(1);\n            }\n          }\n          var state = new State(input, options);\n          state.input += '\\0';\n          while (state.input.charCodeAt(state.position) === 0x20 /* Space */) {\n            state.lineIndent += 1;\n            state.position += 1;\n          }\n          while (state.position < state.length - 1) {\n            readDocument(state);\n          }\n          return state.documents;\n        }\n        function loadAll(input, iterator, options) {\n          var documents = loadDocuments(input, options),\n            index,\n            length;\n          if (typeof iterator !== 'function') {\n            return documents;\n          }\n          for (index = 0, length = documents.length; index < length; index += 1) {\n            iterator(documents[index]);\n          }\n        }\n        function load(input, options) {\n          var documents = loadDocuments(input, options);\n          if (documents.length === 0) {\n            return undefined;\n          } else if (documents.length === 1) {\n            return documents[0];\n          }\n          throw new YAMLException('expected a single document in the stream, but found more');\n        }\n        function safeLoadAll(input, output, options) {\n          if (typeof output === 'function') {\n            loadAll(input, output, common.extend({\n              schema: DEFAULT_SAFE_SCHEMA\n            }, options));\n          } else {\n            return loadAll(input, common.extend({\n              schema: DEFAULT_SAFE_SCHEMA\n            }, options));\n          }\n        }\n        function safeLoad(input, options) {\n          return load(input, common.extend({\n            schema: DEFAULT_SAFE_SCHEMA\n          }, options));\n        }\n        module.exports.loadAll = loadAll;\n        module.exports.load = load;\n        module.exports.safeLoadAll = safeLoadAll;\n        module.exports.safeLoad = safeLoad;\n      }, {\n        \"./common\": 5,\n        \"./exception\": 7,\n        \"./mark\": 9,\n        \"./schema/default_full\": 12,\n        \"./schema/default_safe\": 13\n      }],\n      9: [function (require, module, exports) {\n        'use strict';\n\n        var common = require('./common');\n        function Mark(name, buffer, position, line, column) {\n          this.name = name;\n          this.buffer = buffer;\n          this.position = position;\n          this.line = line;\n          this.column = column;\n        }\n        Mark.prototype.getSnippet = function getSnippet(indent, maxLength) {\n          var head, start, tail, end, snippet;\n          if (!this.buffer) return null;\n          indent = indent || 4;\n          maxLength = maxLength || 75;\n          head = '';\n          start = this.position;\n          while (start > 0 && \"\\0\\r\\n\\x85\\u2028\\u2029\".indexOf(this.buffer.charAt(start - 1)) === -1) {\n            start -= 1;\n            if (this.position - start > maxLength / 2 - 1) {\n              head = ' ... ';\n              start += 5;\n              break;\n            }\n          }\n          tail = '';\n          end = this.position;\n          while (end < this.buffer.length && \"\\0\\r\\n\\x85\\u2028\\u2029\".indexOf(this.buffer.charAt(end)) === -1) {\n            end += 1;\n            if (end - this.position > maxLength / 2 - 1) {\n              tail = ' ... ';\n              end -= 5;\n              break;\n            }\n          }\n          snippet = this.buffer.slice(start, end);\n          return common.repeat(' ', indent) + head + snippet + tail + '\\n' + common.repeat(' ', indent + this.position - start + head.length) + '^';\n        };\n        Mark.prototype.toString = function toString(compact) {\n          var snippet,\n            where = '';\n          if (this.name) {\n            where += 'in \"' + this.name + '\" ';\n          }\n          where += 'at line ' + (this.line + 1) + ', column ' + (this.column + 1);\n          if (!compact) {\n            snippet = this.getSnippet();\n            if (snippet) {\n              where += ':\\n' + snippet;\n            }\n          }\n          return where;\n        };\n        module.exports = Mark;\n      }, {\n        \"./common\": 5\n      }],\n      10: [function (require, module, exports) {\n        'use strict';\n\n        var common = require('./common');\n        var YAMLException = require('./exception');\n        var Type = require('./type');\n        function compileList(schema, name, result) {\n          var exclude = [];\n          schema.include.forEach(function (includedSchema) {\n            result = compileList(includedSchema, name, result);\n          });\n          schema[name].forEach(function (currentType) {\n            result.forEach(function (previousType, previousIndex) {\n              if (previousType.tag === currentType.tag && previousType.kind === currentType.kind) {\n                exclude.push(previousIndex);\n              }\n            });\n            result.push(currentType);\n          });\n          return result.filter(function (type, index) {\n            return exclude.indexOf(index) === -1;\n          });\n        }\n        function compileMap( /* lists... */\n        ) {\n          var result = {\n              scalar: {},\n              sequence: {},\n              mapping: {},\n              fallback: {}\n            },\n            index,\n            length;\n          function collectType(type) {\n            result[type.kind][type.tag] = result['fallback'][type.tag] = type;\n          }\n          for (index = 0, length = arguments.length; index < length; index += 1) {\n            arguments[index].forEach(collectType);\n          }\n          return result;\n        }\n        function Schema(definition) {\n          this.include = definition.include || [];\n          this.implicit = definition.implicit || [];\n          this.explicit = definition.explicit || [];\n          this.implicit.forEach(function (type) {\n            if (type.loadKind && type.loadKind !== 'scalar') {\n              throw new YAMLException('There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.');\n            }\n          });\n          this.compiledImplicit = compileList(this, 'implicit', []);\n          this.compiledExplicit = compileList(this, 'explicit', []);\n          this.compiledTypeMap = compileMap(this.compiledImplicit, this.compiledExplicit);\n        }\n        Schema.DEFAULT = null;\n        Schema.create = function createSchema() {\n          var schemas, types;\n          switch (arguments.length) {\n            case 1:\n              schemas = Schema.DEFAULT;\n              types = arguments[0];\n              break;\n            case 2:\n              schemas = arguments[0];\n              types = arguments[1];\n              break;\n            default:\n              throw new YAMLException('Wrong number of arguments for Schema.create function');\n          }\n          schemas = common.toArray(schemas);\n          types = common.toArray(types);\n          if (!schemas.every(function (schema) {\n            return schema instanceof Schema;\n          })) {\n            throw new YAMLException('Specified list of super schemas (or a single Schema object) contains a non-Schema object.');\n          }\n          if (!types.every(function (type) {\n            return type instanceof Type;\n          })) {\n            throw new YAMLException('Specified list of YAML types (or a single Type object) contains a non-Type object.');\n          }\n          return new Schema({\n            include: schemas,\n            explicit: types\n          });\n        };\n        module.exports = Schema;\n      }, {\n        \"./common\": 5,\n        \"./exception\": 7,\n        \"./type\": 16\n      }],\n      11: [function (require, module, exports) {\n        'use strict';\n\n        var Schema = require('../schema');\n        module.exports = new Schema({\n          include: [require('./json')]\n        });\n      }, {\n        \"../schema\": 10,\n        \"./json\": 15\n      }],\n      12: [function (require, module, exports) {\n        'use strict';\n\n        var Schema = require('../schema');\n        module.exports = Schema.DEFAULT = new Schema({\n          include: [require('./default_safe')],\n          explicit: [require('../type/js/undefined'), require('../type/js/regexp'), require('../type/js/function')]\n        });\n      }, {\n        \"../schema\": 10,\n        \"../type/js/function\": 21,\n        \"../type/js/regexp\": 22,\n        \"../type/js/undefined\": 23,\n        \"./default_safe\": 13\n      }],\n      13: [function (require, module, exports) {\n        'use strict';\n\n        var Schema = require('../schema');\n        module.exports = new Schema({\n          include: [require('./core')],\n          implicit: [require('../type/timestamp'), require('../type/merge')],\n          explicit: [require('../type/binary'), require('../type/omap'), require('../type/pairs'), require('../type/set')]\n        });\n      }, {\n        \"../schema\": 10,\n        \"../type/binary\": 17,\n        \"../type/merge\": 25,\n        \"../type/omap\": 27,\n        \"../type/pairs\": 28,\n        \"../type/set\": 30,\n        \"../type/timestamp\": 32,\n        \"./core\": 11\n      }],\n      14: [function (require, module, exports) {\n        'use strict';\n\n        var Schema = require('../schema');\n        module.exports = new Schema({\n          explicit: [require('../type/str'), require('../type/seq'), require('../type/map')]\n        });\n      }, {\n        \"../schema\": 10,\n        \"../type/map\": 24,\n        \"../type/seq\": 29,\n        \"../type/str\": 31\n      }],\n      15: [function (require, module, exports) {\n        'use strict';\n\n        var Schema = require('../schema');\n        module.exports = new Schema({\n          include: [require('./failsafe')],\n          implicit: [require('../type/null'), require('../type/bool'), require('../type/int'), require('../type/float')]\n        });\n      }, {\n        \"../schema\": 10,\n        \"../type/bool\": 18,\n        \"../type/float\": 19,\n        \"../type/int\": 20,\n        \"../type/null\": 26,\n        \"./failsafe\": 14\n      }],\n      16: [function (require, module, exports) {\n        'use strict';\n\n        var YAMLException = require('./exception');\n        var TYPE_CONSTRUCTOR_OPTIONS = ['kind', 'resolve', 'construct', 'instanceOf', 'predicate', 'represent', 'defaultStyle', 'styleAliases'];\n        var YAML_NODE_KINDS = ['scalar', 'sequence', 'mapping'];\n        function compileStyleAliases(map) {\n          var result = {};\n          if (map !== null) {\n            Object.keys(map).forEach(function (style) {\n              map[style].forEach(function (alias) {\n                result[String(alias)] = style;\n              });\n            });\n          }\n          return result;\n        }\n        function Type(tag, options) {\n          options = options || {};\n          Object.keys(options).forEach(function (name) {\n            if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {\n              throw new YAMLException('Unknown option \"' + name + '\" is met in definition of \"' + tag + '\" YAML type.');\n            }\n          });\n          this.tag = tag;\n          this.kind = options['kind'] || null;\n          this.resolve = options['resolve'] || function () {\n            return true;\n          };\n          this.construct = options['construct'] || function (data) {\n            return data;\n          };\n          this.instanceOf = options['instanceOf'] || null;\n          this.predicate = options['predicate'] || null;\n          this.represent = options['represent'] || null;\n          this.defaultStyle = options['defaultStyle'] || null;\n          this.styleAliases = compileStyleAliases(options['styleAliases'] || null);\n          if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {\n            throw new YAMLException('Unknown kind \"' + this.kind + '\" is specified for \"' + tag + '\" YAML type.');\n          }\n        }\n        module.exports = Type;\n      }, {\n        \"./exception\": 7\n      }],\n      17: [function (require, module, exports) {\n        'use strict';\n\n        var NodeBuffer;\n        try {\n          var _require = require;\n          NodeBuffer = _require('buffer').Buffer;\n        } catch (__) {}\n        var Type = require('../type');\n        var BASE64_MAP = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\\n\\r';\n        function resolveYamlBinary(data) {\n          if (data === null) return false;\n          var code,\n            idx,\n            bitlen = 0,\n            max = data.length,\n            map = BASE64_MAP;\n          for (idx = 0; idx < max; idx++) {\n            code = map.indexOf(data.charAt(idx));\n            if (code > 64) continue;\n            if (code < 0) return false;\n            bitlen += 6;\n          }\n          return bitlen % 8 === 0;\n        }\n        function constructYamlBinary(data) {\n          var idx,\n            tailbits,\n            input = data.replace(/[\\r\\n=]/g, ''),\n            // remove CR/LF & padding to simplify scan\n            max = input.length,\n            map = BASE64_MAP,\n            bits = 0,\n            result = [];\n          for (idx = 0; idx < max; idx++) {\n            if (idx % 4 === 0 && idx) {\n              result.push(bits >> 16 & 0xFF);\n              result.push(bits >> 8 & 0xFF);\n              result.push(bits & 0xFF);\n            }\n            bits = bits << 6 | map.indexOf(input.charAt(idx));\n          }\n          tailbits = max % 4 * 6;\n          if (tailbits === 0) {\n            result.push(bits >> 16 & 0xFF);\n            result.push(bits >> 8 & 0xFF);\n            result.push(bits & 0xFF);\n          } else if (tailbits === 18) {\n            result.push(bits >> 10 & 0xFF);\n            result.push(bits >> 2 & 0xFF);\n          } else if (tailbits === 12) {\n            result.push(bits >> 4 & 0xFF);\n          }\n          if (NodeBuffer) {\n            return NodeBuffer.from ? NodeBuffer.from(result) : new NodeBuffer(result);\n          }\n          return result;\n        }\n        function representYamlBinary(object /*, style*/) {\n          var result = '',\n            bits = 0,\n            idx,\n            tail,\n            max = object.length,\n            map = BASE64_MAP;\n          for (idx = 0; idx < max; idx++) {\n            if (idx % 3 === 0 && idx) {\n              result += map[bits >> 18 & 0x3F];\n              result += map[bits >> 12 & 0x3F];\n              result += map[bits >> 6 & 0x3F];\n              result += map[bits & 0x3F];\n            }\n            bits = (bits << 8) + object[idx];\n          }\n          tail = max % 3;\n          if (tail === 0) {\n            result += map[bits >> 18 & 0x3F];\n            result += map[bits >> 12 & 0x3F];\n            result += map[bits >> 6 & 0x3F];\n            result += map[bits & 0x3F];\n          } else if (tail === 2) {\n            result += map[bits >> 10 & 0x3F];\n            result += map[bits >> 4 & 0x3F];\n            result += map[bits << 2 & 0x3F];\n            result += map[64];\n          } else if (tail === 1) {\n            result += map[bits >> 2 & 0x3F];\n            result += map[bits << 4 & 0x3F];\n            result += map[64];\n            result += map[64];\n          }\n          return result;\n        }\n        function isBinary(object) {\n          return NodeBuffer && NodeBuffer.isBuffer(object);\n        }\n        module.exports = new Type('tag:yaml.org,2002:binary', {\n          kind: 'scalar',\n          resolve: resolveYamlBinary,\n          construct: constructYamlBinary,\n          predicate: isBinary,\n          represent: representYamlBinary\n        });\n      }, {\n        \"../type\": 16\n      }],\n      18: [function (require, module, exports) {\n        'use strict';\n\n        var Type = require('../type');\n        function resolveYamlBoolean(data) {\n          if (data === null) return false;\n          var max = data.length;\n          return max === 4 && (data === 'true' || data === 'True' || data === 'TRUE') || max === 5 && (data === 'false' || data === 'False' || data === 'FALSE');\n        }\n        function constructYamlBoolean(data) {\n          return data === 'true' || data === 'True' || data === 'TRUE';\n        }\n        function isBoolean(object) {\n          return Object.prototype.toString.call(object) === '[object Boolean]';\n        }\n        module.exports = new Type('tag:yaml.org,2002:bool', {\n          kind: 'scalar',\n          resolve: resolveYamlBoolean,\n          construct: constructYamlBoolean,\n          predicate: isBoolean,\n          represent: {\n            lowercase: function lowercase(object) {\n              return object ? 'true' : 'false';\n            },\n            uppercase: function uppercase(object) {\n              return object ? 'TRUE' : 'FALSE';\n            },\n            camelcase: function camelcase(object) {\n              return object ? 'True' : 'False';\n            }\n          },\n          defaultStyle: 'lowercase'\n        });\n      }, {\n        \"../type\": 16\n      }],\n      19: [function (require, module, exports) {\n        'use strict';\n\n        var common = require('../common');\n        var Type = require('../type');\n        var YAML_FLOAT_PATTERN = new RegExp('^(?:[-+]?(?:0|[1-9][0-9_]*)(?:\\\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?' + '|\\\\.[0-9_]+(?:[eE][-+]?[0-9]+)?' + '|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\\\.[0-9_]*' + '|[-+]?\\\\.(?:inf|Inf|INF)' + '|\\\\.(?:nan|NaN|NAN))$');\n        function resolveYamlFloat(data) {\n          if (data === null) return false;\n          if (!YAML_FLOAT_PATTERN.test(data) || data[data.length - 1] === '_') {\n            return false;\n          }\n          return true;\n        }\n        function constructYamlFloat(data) {\n          var value, sign, base, digits;\n          value = data.replace(/_/g, '').toLowerCase();\n          sign = value[0] === '-' ? -1 : 1;\n          digits = [];\n          if ('+-'.indexOf(value[0]) >= 0) {\n            value = value.slice(1);\n          }\n          if (value === '.inf') {\n            return sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;\n          } else if (value === '.nan') {\n            return NaN;\n          } else if (value.indexOf(':') >= 0) {\n            value.split(':').forEach(function (v) {\n              digits.unshift(parseFloat(v, 10));\n            });\n            value = 0.0;\n            base = 1;\n            digits.forEach(function (d) {\n              value += d * base;\n              base *= 60;\n            });\n            return sign * value;\n          }\n          return sign * parseFloat(value, 10);\n        }\n        var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;\n        function representYamlFloat(object, style) {\n          var res;\n          if (isNaN(object)) {\n            switch (style) {\n              case 'lowercase':\n                return '.nan';\n              case 'uppercase':\n                return '.NAN';\n              case 'camelcase':\n                return '.NaN';\n            }\n          } else if (Number.POSITIVE_INFINITY === object) {\n            switch (style) {\n              case 'lowercase':\n                return '.inf';\n              case 'uppercase':\n                return '.INF';\n              case 'camelcase':\n                return '.Inf';\n            }\n          } else if (Number.NEGATIVE_INFINITY === object) {\n            switch (style) {\n              case 'lowercase':\n                return '-.inf';\n              case 'uppercase':\n                return '-.INF';\n              case 'camelcase':\n                return '-.Inf';\n            }\n          } else if (common.isNegativeZero(object)) {\n            return '-0.0';\n          }\n          res = object.toString(10);\n          return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace('e', '.e') : res;\n        }\n        function isFloat(object) {\n          return Object.prototype.toString.call(object) === '[object Number]' && (object % 1 !== 0 || common.isNegativeZero(object));\n        }\n        module.exports = new Type('tag:yaml.org,2002:float', {\n          kind: 'scalar',\n          resolve: resolveYamlFloat,\n          construct: constructYamlFloat,\n          predicate: isFloat,\n          represent: representYamlFloat,\n          defaultStyle: 'lowercase'\n        });\n      }, {\n        \"../common\": 5,\n        \"../type\": 16\n      }],\n      20: [function (require, module, exports) {\n        'use strict';\n\n        var common = require('../common');\n        var Type = require('../type');\n        function isHexCode(c) {\n          return c /* 0 */ >= 0x30 && c <= 0x39 /* 9 */ || c /* A */ >= 0x41 && c <= 0x46 /* F */ || c /* a */ >= 0x61 && c <= 0x66 /* f */;\n        }\n\n        function isOctCode(c) {\n          return c /* 0 */ >= 0x30 && c <= 0x37 /* 7 */;\n        }\n\n        function isDecCode(c) {\n          return c /* 0 */ >= 0x30 && c <= 0x39 /* 9 */;\n        }\n\n        function resolveYamlInteger(data) {\n          if (data === null) return false;\n          var max = data.length,\n            index = 0,\n            hasDigits = false,\n            ch;\n          if (!max) return false;\n          ch = data[index];\n          if (ch === '-' || ch === '+') {\n            ch = data[++index];\n          }\n          if (ch === '0') {\n            if (index + 1 === max) return true;\n            ch = data[++index];\n            if (ch === 'b') {\n              index++;\n              for (; index < max; index++) {\n                ch = data[index];\n                if (ch === '_') continue;\n                if (ch !== '0' && ch !== '1') return false;\n                hasDigits = true;\n              }\n              return hasDigits && ch !== '_';\n            }\n            if (ch === 'x') {\n              index++;\n              for (; index < max; index++) {\n                ch = data[index];\n                if (ch === '_') continue;\n                if (!isHexCode(data.charCodeAt(index))) return false;\n                hasDigits = true;\n              }\n              return hasDigits && ch !== '_';\n            }\n            for (; index < max; index++) {\n              ch = data[index];\n              if (ch === '_') continue;\n              if (!isOctCode(data.charCodeAt(index))) return false;\n              hasDigits = true;\n            }\n            return hasDigits && ch !== '_';\n          }\n          if (ch === '_') return false;\n          for (; index < max; index++) {\n            ch = data[index];\n            if (ch === '_') continue;\n            if (ch === ':') break;\n            if (!isDecCode(data.charCodeAt(index))) {\n              return false;\n            }\n            hasDigits = true;\n          }\n          if (!hasDigits || ch === '_') return false;\n          if (ch !== ':') return true;\n          return /^(:[0-5]?[0-9])+$/.test(data.slice(index));\n        }\n        function constructYamlInteger(data) {\n          var value = data,\n            sign = 1,\n            ch,\n            base,\n            digits = [];\n          if (value.indexOf('_') !== -1) {\n            value = value.replace(/_/g, '');\n          }\n          ch = value[0];\n          if (ch === '-' || ch === '+') {\n            if (ch === '-') sign = -1;\n            value = value.slice(1);\n            ch = value[0];\n          }\n          if (value === '0') return 0;\n          if (ch === '0') {\n            if (value[1] === 'b') return sign * parseInt(value.slice(2), 2);\n            if (value[1] === 'x') return sign * parseInt(value, 16);\n            return sign * parseInt(value, 8);\n          }\n          if (value.indexOf(':') !== -1) {\n            value.split(':').forEach(function (v) {\n              digits.unshift(parseInt(v, 10));\n            });\n            value = 0;\n            base = 1;\n            digits.forEach(function (d) {\n              value += d * base;\n              base *= 60;\n            });\n            return sign * value;\n          }\n          return sign * parseInt(value, 10);\n        }\n        function isInteger(object) {\n          return Object.prototype.toString.call(object) === '[object Number]' && object % 1 === 0 && !common.isNegativeZero(object);\n        }\n        module.exports = new Type('tag:yaml.org,2002:int', {\n          kind: 'scalar',\n          resolve: resolveYamlInteger,\n          construct: constructYamlInteger,\n          predicate: isInteger,\n          represent: {\n            binary: function binary(obj) {\n              return obj >= 0 ? '0b' + obj.toString(2) : '-0b' + obj.toString(2).slice(1);\n            },\n            octal: function octal(obj) {\n              return obj >= 0 ? '0' + obj.toString(8) : '-0' + obj.toString(8).slice(1);\n            },\n            decimal: function decimal(obj) {\n              return obj.toString(10);\n            },\n            hexadecimal: function hexadecimal(obj) {\n              return obj >= 0 ? '0x' + obj.toString(16).toUpperCase() : '-0x' + obj.toString(16).toUpperCase().slice(1);\n            }\n          },\n          defaultStyle: 'decimal',\n          styleAliases: {\n            binary: [2, 'bin'],\n            octal: [8, 'oct'],\n            decimal: [10, 'dec'],\n            hexadecimal: [16, 'hex']\n          }\n        });\n      }, {\n        \"../common\": 5,\n        \"../type\": 16\n      }],\n      21: [function (require, module, exports) {\n        'use strict';\n\n        var esprima;\n        try {\n          var _require = require;\n          esprima = _require('esprima');\n        } catch (_) {\n          if (typeof window !== 'undefined') esprima = window.esprima;\n        }\n        var Type = require('../../type');\n        function resolveJavascriptFunction(data) {\n          if (data === null) return false;\n          try {\n            var source = '(' + data + ')',\n              ast = esprima.parse(source, {\n                range: true\n              });\n            if (ast.type !== 'Program' || ast.body.length !== 1 || ast.body[0].type !== 'ExpressionStatement' || ast.body[0].expression.type !== 'ArrowFunctionExpression' && ast.body[0].expression.type !== 'FunctionExpression') {\n              return false;\n            }\n            return true;\n          } catch (err) {\n            return false;\n          }\n        }\n        function constructJavascriptFunction(data) {\n          var source = '(' + data + ')',\n            ast = esprima.parse(source, {\n              range: true\n            }),\n            params = [],\n            body;\n          if (ast.type !== 'Program' || ast.body.length !== 1 || ast.body[0].type !== 'ExpressionStatement' || ast.body[0].expression.type !== 'ArrowFunctionExpression' && ast.body[0].expression.type !== 'FunctionExpression') {\n            throw new Error('Failed to resolve function');\n          }\n          ast.body[0].expression.params.forEach(function (param) {\n            params.push(param.name);\n          });\n          body = ast.body[0].expression.body.range;\n          if (ast.body[0].expression.body.type === 'BlockStatement') {\n            return new Function(params, source.slice(body[0] + 1, body[1] - 1));\n          }\n          return new Function(params, 'return ' + source.slice(body[0], body[1]));\n        }\n        function representJavascriptFunction(object /*, style*/) {\n          return object.toString();\n        }\n        function isFunction(object) {\n          return Object.prototype.toString.call(object) === '[object Function]';\n        }\n        module.exports = new Type('tag:yaml.org,2002:js/function', {\n          kind: 'scalar',\n          resolve: resolveJavascriptFunction,\n          construct: constructJavascriptFunction,\n          predicate: isFunction,\n          represent: representJavascriptFunction\n        });\n      }, {\n        \"../../type\": 16\n      }],\n      22: [function (require, module, exports) {\n        'use strict';\n\n        var Type = require('../../type');\n        function resolveJavascriptRegExp(data) {\n          if (data === null) return false;\n          if (data.length === 0) return false;\n          var regexp = data,\n            tail = /\\/([gim]*)$/.exec(data),\n            modifiers = '';\n          if (regexp[0] === '/') {\n            if (tail) modifiers = tail[1];\n            if (modifiers.length > 3) return false;\n            if (regexp[regexp.length - modifiers.length - 1] !== '/') return false;\n          }\n          return true;\n        }\n        function constructJavascriptRegExp(data) {\n          var regexp = data,\n            tail = /\\/([gim]*)$/.exec(data),\n            modifiers = '';\n          if (regexp[0] === '/') {\n            if (tail) modifiers = tail[1];\n            regexp = regexp.slice(1, regexp.length - modifiers.length - 1);\n          }\n          return new RegExp(regexp, modifiers);\n        }\n        function representJavascriptRegExp(object /*, style*/) {\n          var result = '/' + object.source + '/';\n          if (object.global) result += 'g';\n          if (object.multiline) result += 'm';\n          if (object.ignoreCase) result += 'i';\n          return result;\n        }\n        function isRegExp(object) {\n          return Object.prototype.toString.call(object) === '[object RegExp]';\n        }\n        module.exports = new Type('tag:yaml.org,2002:js/regexp', {\n          kind: 'scalar',\n          resolve: resolveJavascriptRegExp,\n          construct: constructJavascriptRegExp,\n          predicate: isRegExp,\n          represent: representJavascriptRegExp\n        });\n      }, {\n        \"../../type\": 16\n      }],\n      23: [function (require, module, exports) {\n        'use strict';\n\n        var Type = require('../../type');\n        function resolveJavascriptUndefined() {\n          return true;\n        }\n        function constructJavascriptUndefined() {\n          return undefined;\n        }\n        function representJavascriptUndefined() {\n          return '';\n        }\n        function isUndefined(object) {\n          return typeof object === 'undefined';\n        }\n        module.exports = new Type('tag:yaml.org,2002:js/undefined', {\n          kind: 'scalar',\n          resolve: resolveJavascriptUndefined,\n          construct: constructJavascriptUndefined,\n          predicate: isUndefined,\n          represent: representJavascriptUndefined\n        });\n      }, {\n        \"../../type\": 16\n      }],\n      24: [function (require, module, exports) {\n        'use strict';\n\n        var Type = require('../type');\n        module.exports = new Type('tag:yaml.org,2002:map', {\n          kind: 'mapping',\n          construct: function construct(data) {\n            return data !== null ? data : {};\n          }\n        });\n      }, {\n        \"../type\": 16\n      }],\n      25: [function (require, module, exports) {\n        'use strict';\n\n        var Type = require('../type');\n        function resolveYamlMerge(data) {\n          return data === '<<' || data === null;\n        }\n        module.exports = new Type('tag:yaml.org,2002:merge', {\n          kind: 'scalar',\n          resolve: resolveYamlMerge\n        });\n      }, {\n        \"../type\": 16\n      }],\n      26: [function (require, module, exports) {\n        'use strict';\n\n        var Type = require('../type');\n        function resolveYamlNull(data) {\n          if (data === null) return true;\n          var max = data.length;\n          return max === 1 && data === '~' || max === 4 && (data === 'null' || data === 'Null' || data === 'NULL');\n        }\n        function constructYamlNull() {\n          return null;\n        }\n        function isNull(object) {\n          return object === null;\n        }\n        module.exports = new Type('tag:yaml.org,2002:null', {\n          kind: 'scalar',\n          resolve: resolveYamlNull,\n          construct: constructYamlNull,\n          predicate: isNull,\n          represent: {\n            canonical: function canonical() {\n              return '~';\n            },\n            lowercase: function lowercase() {\n              return 'null';\n            },\n            uppercase: function uppercase() {\n              return 'NULL';\n            },\n            camelcase: function camelcase() {\n              return 'Null';\n            }\n          },\n          defaultStyle: 'lowercase'\n        });\n      }, {\n        \"../type\": 16\n      }],\n      27: [function (require, module, exports) {\n        'use strict';\n\n        var Type = require('../type');\n        var _hasOwnProperty = Object.prototype.hasOwnProperty;\n        var _toString = Object.prototype.toString;\n        function resolveYamlOmap(data) {\n          if (data === null) return true;\n          var objectKeys = [],\n            index,\n            length,\n            pair,\n            pairKey,\n            pairHasKey,\n            object = data;\n          for (index = 0, length = object.length; index < length; index += 1) {\n            pair = object[index];\n            pairHasKey = false;\n            if (_toString.call(pair) !== '[object Object]') return false;\n            for (pairKey in pair) {\n              if (_hasOwnProperty.call(pair, pairKey)) {\n                if (!pairHasKey) pairHasKey = true;else return false;\n              }\n            }\n            if (!pairHasKey) return false;\n            if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);else return false;\n          }\n          return true;\n        }\n        function constructYamlOmap(data) {\n          return data !== null ? data : [];\n        }\n        module.exports = new Type('tag:yaml.org,2002:omap', {\n          kind: 'sequence',\n          resolve: resolveYamlOmap,\n          construct: constructYamlOmap\n        });\n      }, {\n        \"../type\": 16\n      }],\n      28: [function (require, module, exports) {\n        'use strict';\n\n        var Type = require('../type');\n        var _toString = Object.prototype.toString;\n        function resolveYamlPairs(data) {\n          if (data === null) return true;\n          var index,\n            length,\n            pair,\n            keys,\n            result,\n            object = data;\n          result = new Array(object.length);\n          for (index = 0, length = object.length; index < length; index += 1) {\n            pair = object[index];\n            if (_toString.call(pair) !== '[object Object]') return false;\n            keys = Object.keys(pair);\n            if (keys.length !== 1) return false;\n            result[index] = [keys[0], pair[keys[0]]];\n          }\n          return true;\n        }\n        function constructYamlPairs(data) {\n          if (data === null) return [];\n          var index,\n            length,\n            pair,\n            keys,\n            result,\n            object = data;\n          result = new Array(object.length);\n          for (index = 0, length = object.length; index < length; index += 1) {\n            pair = object[index];\n            keys = Object.keys(pair);\n            result[index] = [keys[0], pair[keys[0]]];\n          }\n          return result;\n        }\n        module.exports = new Type('tag:yaml.org,2002:pairs', {\n          kind: 'sequence',\n          resolve: resolveYamlPairs,\n          construct: constructYamlPairs\n        });\n      }, {\n        \"../type\": 16\n      }],\n      29: [function (require, module, exports) {\n        'use strict';\n\n        var Type = require('../type');\n        module.exports = new Type('tag:yaml.org,2002:seq', {\n          kind: 'sequence',\n          construct: function construct(data) {\n            return data !== null ? data : [];\n          }\n        });\n      }, {\n        \"../type\": 16\n      }],\n      30: [function (require, module, exports) {\n        'use strict';\n\n        var Type = require('../type');\n        var _hasOwnProperty = Object.prototype.hasOwnProperty;\n        function resolveYamlSet(data) {\n          if (data === null) return true;\n          var key,\n            object = data;\n          for (key in object) {\n            if (_hasOwnProperty.call(object, key)) {\n              if (object[key] !== null) return false;\n            }\n          }\n          return true;\n        }\n        function constructYamlSet(data) {\n          return data !== null ? data : {};\n        }\n        module.exports = new Type('tag:yaml.org,2002:set', {\n          kind: 'mapping',\n          resolve: resolveYamlSet,\n          construct: constructYamlSet\n        });\n      }, {\n        \"../type\": 16\n      }],\n      31: [function (require, module, exports) {\n        'use strict';\n\n        var Type = require('../type');\n        module.exports = new Type('tag:yaml.org,2002:str', {\n          kind: 'scalar',\n          construct: function construct(data) {\n            return data !== null ? data : '';\n          }\n        });\n      }, {\n        \"../type\": 16\n      }],\n      32: [function (require, module, exports) {\n        'use strict';\n\n        var Type = require('../type');\n        var YAML_DATE_REGEXP = new RegExp('^([0-9][0-9][0-9][0-9])' +\n        // [1] year\n        '-([0-9][0-9])' +\n        // [2] month\n        '-([0-9][0-9])$'); // [3] day\n\n        var YAML_TIMESTAMP_REGEXP = new RegExp('^([0-9][0-9][0-9][0-9])' +\n        // [1] year\n        '-([0-9][0-9]?)' +\n        // [2] month\n        '-([0-9][0-9]?)' +\n        // [3] day\n        '(?:[Tt]|[ \\\\t]+)' +\n        // ...\n        '([0-9][0-9]?)' +\n        // [4] hour\n        ':([0-9][0-9])' +\n        // [5] minute\n        ':([0-9][0-9])' +\n        // [6] second\n        '(?:\\\\.([0-9]*))?' +\n        // [7] fraction\n        '(?:[ \\\\t]*(Z|([-+])([0-9][0-9]?)' +\n        // [8] tz [9] tz_sign [10] tz_hour\n        '(?::([0-9][0-9]))?))?$'); // [11] tz_minute\n\n        function resolveYamlTimestamp(data) {\n          if (data === null) return false;\n          if (YAML_DATE_REGEXP.exec(data) !== null) return true;\n          if (YAML_TIMESTAMP_REGEXP.exec(data) !== null) return true;\n          return false;\n        }\n        function constructYamlTimestamp(data) {\n          var match,\n            year,\n            month,\n            day,\n            hour,\n            minute,\n            second,\n            fraction = 0,\n            delta = null,\n            tz_hour,\n            tz_minute,\n            date;\n          match = YAML_DATE_REGEXP.exec(data);\n          if (match === null) match = YAML_TIMESTAMP_REGEXP.exec(data);\n          if (match === null) throw new Error('Date resolve error');\n          year = +match[1];\n          month = +match[2] - 1; // JS month starts with 0\n          day = +match[3];\n          if (!match[4]) {\n            // no hour\n            return new Date(Date.UTC(year, month, day));\n          }\n          hour = +match[4];\n          minute = +match[5];\n          second = +match[6];\n          if (match[7]) {\n            fraction = match[7].slice(0, 3);\n            while (fraction.length < 3) {\n              // milli-seconds\n              fraction += '0';\n            }\n            fraction = +fraction;\n          }\n          if (match[9]) {\n            tz_hour = +match[10];\n            tz_minute = +(match[11] || 0);\n            delta = (tz_hour * 60 + tz_minute) * 60000; // delta in mili-seconds\n            if (match[9] === '-') delta = -delta;\n          }\n          date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));\n          if (delta) date.setTime(date.getTime() - delta);\n          return date;\n        }\n        function representYamlTimestamp(object /*, style*/) {\n          return object.toISOString();\n        }\n        module.exports = new Type('tag:yaml.org,2002:timestamp', {\n          kind: 'scalar',\n          resolve: resolveYamlTimestamp,\n          construct: constructYamlTimestamp,\n          instanceOf: Date,\n          represent: representYamlTimestamp\n        });\n      }, {\n        \"../type\": 16\n      }],\n      33: [function (require, module, exports) {\n        (function (global) {\n          var LARGE_ARRAY_SIZE = 200;\n          var HASH_UNDEFINED = '__lodash_hash_undefined__';\n          var HOT_COUNT = 800,\n            HOT_SPAN = 16;\n          var MAX_SAFE_INTEGER = 9007199254740991;\n          var argsTag = '[object Arguments]',\n            arrayTag = '[object Array]',\n            asyncTag = '[object AsyncFunction]',\n            boolTag = '[object Boolean]',\n            dateTag = '[object Date]',\n            errorTag = '[object Error]',\n            funcTag = '[object Function]',\n            genTag = '[object GeneratorFunction]',\n            mapTag = '[object Map]',\n            numberTag = '[object Number]',\n            nullTag = '[object Null]',\n            objectTag = '[object Object]',\n            proxyTag = '[object Proxy]',\n            regexpTag = '[object RegExp]',\n            setTag = '[object Set]',\n            stringTag = '[object String]',\n            undefinedTag = '[object Undefined]',\n            weakMapTag = '[object WeakMap]';\n          var arrayBufferTag = '[object ArrayBuffer]',\n            dataViewTag = '[object DataView]',\n            float32Tag = '[object Float32Array]',\n            float64Tag = '[object Float64Array]',\n            int8Tag = '[object Int8Array]',\n            int16Tag = '[object Int16Array]',\n            int32Tag = '[object Int32Array]',\n            uint8Tag = '[object Uint8Array]',\n            uint8ClampedTag = '[object Uint8ClampedArray]',\n            uint16Tag = '[object Uint16Array]',\n            uint32Tag = '[object Uint32Array]';\n          var reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n          var reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n          var reIsUint = /^(?:0|[1-9]\\d*)$/;\n          var typedArrayTags = {};\n          typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;\n          typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;\n          var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n          var freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n          var root = freeGlobal || freeSelf || Function('return this')();\n          var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n          var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n          var moduleExports = freeModule && freeModule.exports === freeExports;\n          var freeProcess = moduleExports && freeGlobal.process;\n          var nodeUtil = function () {\n            try {\n              return freeProcess && freeProcess.binding && freeProcess.binding('util');\n            } catch (e) {}\n          }();\n          var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n          function apply(func, thisArg, args) {\n            switch (args.length) {\n              case 0:\n                return func.call(thisArg);\n              case 1:\n                return func.call(thisArg, args[0]);\n              case 2:\n                return func.call(thisArg, args[0], args[1]);\n              case 3:\n                return func.call(thisArg, args[0], args[1], args[2]);\n            }\n            return func.apply(thisArg, args);\n          }\n          function baseTimes(n, iteratee) {\n            var index = -1,\n              result = Array(n);\n            while (++index < n) {\n              result[index] = iteratee(index);\n            }\n            return result;\n          }\n          function baseUnary(func) {\n            return function (value) {\n              return func(value);\n            };\n          }\n          function getValue(object, key) {\n            return object == null ? undefined : object[key];\n          }\n          function overArg(func, transform) {\n            return function (arg) {\n              return func(transform(arg));\n            };\n          }\n          function safeGet(object, key) {\n            return key == '__proto__' ? undefined : object[key];\n          }\n          var arrayProto = Array.prototype,\n            funcProto = Function.prototype,\n            objectProto = Object.prototype;\n          var coreJsData = root['__core-js_shared__'];\n          var funcToString = funcProto.toString;\n          var hasOwnProperty = objectProto.hasOwnProperty;\n          var maskSrcKey = function () {\n            var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n            return uid ? 'Symbol(src)_1.' + uid : '';\n          }();\n          var nativeObjectToString = objectProto.toString;\n          var objectCtorString = funcToString.call(Object);\n          var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&').replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$');\n          var Buffer = moduleExports ? root.Buffer : undefined,\n            Symbol = root.Symbol,\n            Uint8Array = root.Uint8Array,\n            allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined,\n            getPrototype = overArg(Object.getPrototypeOf, Object),\n            objectCreate = Object.create,\n            propertyIsEnumerable = objectProto.propertyIsEnumerable,\n            splice = arrayProto.splice,\n            symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n          var defineProperty = function () {\n            try {\n              var func = getNative(Object, 'defineProperty');\n              func({}, '', {});\n              return func;\n            } catch (e) {}\n          }();\n          var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,\n            nativeMax = Math.max,\n            nativeNow = Date.now;\n          var Map = getNative(root, 'Map'),\n            nativeCreate = getNative(Object, 'create');\n          var baseCreate = function () {\n            function object() {}\n            return function (proto) {\n              if (!isObject(proto)) {\n                return {};\n              }\n              if (objectCreate) {\n                return objectCreate(proto);\n              }\n              object.prototype = proto;\n              var result = new object();\n              object.prototype = undefined;\n              return result;\n            };\n          }();\n          function Hash(entries) {\n            var index = -1,\n              length = entries == null ? 0 : entries.length;\n            this.clear();\n            while (++index < length) {\n              var entry = entries[index];\n              this.set(entry[0], entry[1]);\n            }\n          }\n          function hashClear() {\n            this.__data__ = nativeCreate ? nativeCreate(null) : {};\n            this.size = 0;\n          }\n          function hashDelete(key) {\n            var result = this.has(key) && delete this.__data__[key];\n            this.size -= result ? 1 : 0;\n            return result;\n          }\n          function hashGet(key) {\n            var data = this.__data__;\n            if (nativeCreate) {\n              var result = data[key];\n              return result === HASH_UNDEFINED ? undefined : result;\n            }\n            return hasOwnProperty.call(data, key) ? data[key] : undefined;\n          }\n          function hashHas(key) {\n            var data = this.__data__;\n            return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);\n          }\n          function hashSet(key, value) {\n            var data = this.__data__;\n            this.size += this.has(key) ? 0 : 1;\n            data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;\n            return this;\n          }\n          Hash.prototype.clear = hashClear;\n          Hash.prototype['delete'] = hashDelete;\n          Hash.prototype.get = hashGet;\n          Hash.prototype.has = hashHas;\n          Hash.prototype.set = hashSet;\n          function ListCache(entries) {\n            var index = -1,\n              length = entries == null ? 0 : entries.length;\n            this.clear();\n            while (++index < length) {\n              var entry = entries[index];\n              this.set(entry[0], entry[1]);\n            }\n          }\n          function listCacheClear() {\n            this.__data__ = [];\n            this.size = 0;\n          }\n          function listCacheDelete(key) {\n            var data = this.__data__,\n              index = assocIndexOf(data, key);\n            if (index < 0) {\n              return false;\n            }\n            var lastIndex = data.length - 1;\n            if (index == lastIndex) {\n              data.pop();\n            } else {\n              splice.call(data, index, 1);\n            }\n            --this.size;\n            return true;\n          }\n          function listCacheGet(key) {\n            var data = this.__data__,\n              index = assocIndexOf(data, key);\n            return index < 0 ? undefined : data[index][1];\n          }\n          function listCacheHas(key) {\n            return assocIndexOf(this.__data__, key) > -1;\n          }\n          function listCacheSet(key, value) {\n            var data = this.__data__,\n              index = assocIndexOf(data, key);\n            if (index < 0) {\n              ++this.size;\n              data.push([key, value]);\n            } else {\n              data[index][1] = value;\n            }\n            return this;\n          }\n          ListCache.prototype.clear = listCacheClear;\n          ListCache.prototype['delete'] = listCacheDelete;\n          ListCache.prototype.get = listCacheGet;\n          ListCache.prototype.has = listCacheHas;\n          ListCache.prototype.set = listCacheSet;\n          function MapCache(entries) {\n            var index = -1,\n              length = entries == null ? 0 : entries.length;\n            this.clear();\n            while (++index < length) {\n              var entry = entries[index];\n              this.set(entry[0], entry[1]);\n            }\n          }\n          function mapCacheClear() {\n            this.size = 0;\n            this.__data__ = {\n              'hash': new Hash(),\n              'map': new (Map || ListCache)(),\n              'string': new Hash()\n            };\n          }\n          function mapCacheDelete(key) {\n            var result = getMapData(this, key)['delete'](key);\n            this.size -= result ? 1 : 0;\n            return result;\n          }\n          function mapCacheGet(key) {\n            return getMapData(this, key).get(key);\n          }\n          function mapCacheHas(key) {\n            return getMapData(this, key).has(key);\n          }\n          function mapCacheSet(key, value) {\n            var data = getMapData(this, key),\n              size = data.size;\n            data.set(key, value);\n            this.size += data.size == size ? 0 : 1;\n            return this;\n          }\n          MapCache.prototype.clear = mapCacheClear;\n          MapCache.prototype['delete'] = mapCacheDelete;\n          MapCache.prototype.get = mapCacheGet;\n          MapCache.prototype.has = mapCacheHas;\n          MapCache.prototype.set = mapCacheSet;\n          function Stack(entries) {\n            var data = this.__data__ = new ListCache(entries);\n            this.size = data.size;\n          }\n          function stackClear() {\n            this.__data__ = new ListCache();\n            this.size = 0;\n          }\n          function stackDelete(key) {\n            var data = this.__data__,\n              result = data['delete'](key);\n            this.size = data.size;\n            return result;\n          }\n          function stackGet(key) {\n            return this.__data__.get(key);\n          }\n          function stackHas(key) {\n            return this.__data__.has(key);\n          }\n          function stackSet(key, value) {\n            var data = this.__data__;\n            if (data instanceof ListCache) {\n              var pairs = data.__data__;\n              if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {\n                pairs.push([key, value]);\n                this.size = ++data.size;\n                return this;\n              }\n              data = this.__data__ = new MapCache(pairs);\n            }\n            data.set(key, value);\n            this.size = data.size;\n            return this;\n          }\n          Stack.prototype.clear = stackClear;\n          Stack.prototype['delete'] = stackDelete;\n          Stack.prototype.get = stackGet;\n          Stack.prototype.has = stackHas;\n          Stack.prototype.set = stackSet;\n          function arrayLikeKeys(value, inherited) {\n            var isArr = isArray(value),\n              isArg = !isArr && isArguments(value),\n              isBuff = !isArr && !isArg && isBuffer(value),\n              isType = !isArr && !isArg && !isBuff && isTypedArray(value),\n              skipIndexes = isArr || isArg || isBuff || isType,\n              result = skipIndexes ? baseTimes(value.length, String) : [],\n              length = result.length;\n            for (var key in value) {\n              if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == 'length' || isBuff && (key == 'offset' || key == 'parent') || isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset') || isIndex(key, length)))) {\n                result.push(key);\n              }\n            }\n            return result;\n          }\n          function assignMergeValue(object, key, value) {\n            if (value !== undefined && !eq(object[key], value) || value === undefined && !(key in object)) {\n              baseAssignValue(object, key, value);\n            }\n          }\n          function assignValue(object, key, value) {\n            var objValue = object[key];\n            if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined && !(key in object)) {\n              baseAssignValue(object, key, value);\n            }\n          }\n          function assocIndexOf(array, key) {\n            var length = array.length;\n            while (length--) {\n              if (eq(array[length][0], key)) {\n                return length;\n              }\n            }\n            return -1;\n          }\n          function baseAssignValue(object, key, value) {\n            if (key == '__proto__' && defineProperty) {\n              defineProperty(object, key, {\n                'configurable': true,\n                'enumerable': true,\n                'value': value,\n                'writable': true\n              });\n            } else {\n              object[key] = value;\n            }\n          }\n          var baseFor = createBaseFor();\n          function baseGetTag(value) {\n            if (value == null) {\n              return value === undefined ? undefinedTag : nullTag;\n            }\n            return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);\n          }\n          function baseIsArguments(value) {\n            return isObjectLike(value) && baseGetTag(value) == argsTag;\n          }\n          function baseIsNative(value) {\n            if (!isObject(value) || isMasked(value)) {\n              return false;\n            }\n            var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n            return pattern.test(toSource(value));\n          }\n          function baseIsTypedArray(value) {\n            return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\n          }\n          function baseKeysIn(object) {\n            if (!isObject(object)) {\n              return nativeKeysIn(object);\n            }\n            var isProto = isPrototype(object),\n              result = [];\n            for (var key in object) {\n              if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {\n                result.push(key);\n              }\n            }\n            return result;\n          }\n          function baseMerge(object, source, srcIndex, customizer, stack) {\n            if (object === source) {\n              return;\n            }\n            baseFor(source, function (srcValue, key) {\n              if (isObject(srcValue)) {\n                stack || (stack = new Stack());\n                baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);\n              } else {\n                var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + '', object, source, stack) : undefined;\n                if (newValue === undefined) {\n                  newValue = srcValue;\n                }\n                assignMergeValue(object, key, newValue);\n              }\n            }, keysIn);\n          }\n          function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {\n            var objValue = safeGet(object, key),\n              srcValue = safeGet(source, key),\n              stacked = stack.get(srcValue);\n            if (stacked) {\n              assignMergeValue(object, key, stacked);\n              return;\n            }\n            var newValue = customizer ? customizer(objValue, srcValue, key + '', object, source, stack) : undefined;\n            var isCommon = newValue === undefined;\n            if (isCommon) {\n              var isArr = isArray(srcValue),\n                isBuff = !isArr && isBuffer(srcValue),\n                isTyped = !isArr && !isBuff && isTypedArray(srcValue);\n              newValue = srcValue;\n              if (isArr || isBuff || isTyped) {\n                if (isArray(objValue)) {\n                  newValue = objValue;\n                } else if (isArrayLikeObject(objValue)) {\n                  newValue = copyArray(objValue);\n                } else if (isBuff) {\n                  isCommon = false;\n                  newValue = cloneBuffer(srcValue, true);\n                } else if (isTyped) {\n                  isCommon = false;\n                  newValue = cloneTypedArray(srcValue, true);\n                } else {\n                  newValue = [];\n                }\n              } else if (isPlainObject(srcValue) || isArguments(srcValue)) {\n                newValue = objValue;\n                if (isArguments(objValue)) {\n                  newValue = toPlainObject(objValue);\n                } else if (!isObject(objValue) || srcIndex && isFunction(objValue)) {\n                  newValue = initCloneObject(srcValue);\n                }\n              } else {\n                isCommon = false;\n              }\n            }\n            if (isCommon) {\n              stack.set(srcValue, newValue);\n              mergeFunc(newValue, srcValue, srcIndex, customizer, stack);\n              stack['delete'](srcValue);\n            }\n            assignMergeValue(object, key, newValue);\n          }\n          function baseRest(func, start) {\n            return setToString(overRest(func, start, identity), func + '');\n          }\n          var baseSetToString = !defineProperty ? identity : function (func, string) {\n            return defineProperty(func, 'toString', {\n              'configurable': true,\n              'enumerable': false,\n              'value': constant(string),\n              'writable': true\n            });\n          };\n          function cloneBuffer(buffer, isDeep) {\n            if (isDeep) {\n              return buffer.slice();\n            }\n            var length = buffer.length,\n              result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);\n            buffer.copy(result);\n            return result;\n          }\n          function cloneArrayBuffer(arrayBuffer) {\n            var result = new arrayBuffer.constructor(arrayBuffer.byteLength);\n            new Uint8Array(result).set(new Uint8Array(arrayBuffer));\n            return result;\n          }\n          function cloneTypedArray(typedArray, isDeep) {\n            var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;\n            return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);\n          }\n          function copyArray(source, array) {\n            var index = -1,\n              length = source.length;\n            array || (array = Array(length));\n            while (++index < length) {\n              array[index] = source[index];\n            }\n            return array;\n          }\n          function copyObject(source, props, object, customizer) {\n            var isNew = !object;\n            object || (object = {});\n            var index = -1,\n              length = props.length;\n            while (++index < length) {\n              var key = props[index];\n              var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined;\n              if (newValue === undefined) {\n                newValue = source[key];\n              }\n              if (isNew) {\n                baseAssignValue(object, key, newValue);\n              } else {\n                assignValue(object, key, newValue);\n              }\n            }\n            return object;\n          }\n          function createAssigner(assigner) {\n            return baseRest(function (object, sources) {\n              var index = -1,\n                length = sources.length,\n                customizer = length > 1 ? sources[length - 1] : undefined,\n                guard = length > 2 ? sources[2] : undefined;\n              customizer = assigner.length > 3 && typeof customizer == 'function' ? (length--, customizer) : undefined;\n              if (guard && isIterateeCall(sources[0], sources[1], guard)) {\n                customizer = length < 3 ? undefined : customizer;\n                length = 1;\n              }\n              object = Object(object);\n              while (++index < length) {\n                var source = sources[index];\n                if (source) {\n                  assigner(object, source, index, customizer);\n                }\n              }\n              return object;\n            });\n          }\n          function createBaseFor(fromRight) {\n            return function (object, iteratee, keysFunc) {\n              var index = -1,\n                iterable = Object(object),\n                props = keysFunc(object),\n                length = props.length;\n              while (length--) {\n                var key = props[fromRight ? length : ++index];\n                if (iteratee(iterable[key], key, iterable) === false) {\n                  break;\n                }\n              }\n              return object;\n            };\n          }\n          function getMapData(map, key) {\n            var data = map.__data__;\n            return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;\n          }\n          function getNative(object, key) {\n            var value = getValue(object, key);\n            return baseIsNative(value) ? value : undefined;\n          }\n          function getRawTag(value) {\n            var isOwn = hasOwnProperty.call(value, symToStringTag),\n              tag = value[symToStringTag];\n            try {\n              value[symToStringTag] = undefined;\n              var unmasked = true;\n            } catch (e) {}\n            var result = nativeObjectToString.call(value);\n            if (unmasked) {\n              if (isOwn) {\n                value[symToStringTag] = tag;\n              } else {\n                delete value[symToStringTag];\n              }\n            }\n            return result;\n          }\n          function initCloneObject(object) {\n            return typeof object.constructor == 'function' && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};\n          }\n          function isIndex(value, length) {\n            var type = typeof value;\n            length = length == null ? MAX_SAFE_INTEGER : length;\n            return !!length && (type == 'number' || type != 'symbol' && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;\n          }\n          function isIterateeCall(value, index, object) {\n            if (!isObject(object)) {\n              return false;\n            }\n            var type = typeof index;\n            if (type == 'number' ? isArrayLike(object) && isIndex(index, object.length) : type == 'string' && index in object) {\n              return eq(object[index], value);\n            }\n            return false;\n          }\n          function isKeyable(value) {\n            var type = typeof value;\n            return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;\n          }\n          function isMasked(func) {\n            return !!maskSrcKey && maskSrcKey in func;\n          }\n          function isPrototype(value) {\n            var Ctor = value && value.constructor,\n              proto = typeof Ctor == 'function' && Ctor.prototype || objectProto;\n            return value === proto;\n          }\n          function nativeKeysIn(object) {\n            var result = [];\n            if (object != null) {\n              for (var key in Object(object)) {\n                result.push(key);\n              }\n            }\n            return result;\n          }\n          function objectToString(value) {\n            return nativeObjectToString.call(value);\n          }\n          function overRest(func, start, transform) {\n            start = nativeMax(start === undefined ? func.length - 1 : start, 0);\n            return function () {\n              var args = arguments,\n                index = -1,\n                length = nativeMax(args.length - start, 0),\n                array = Array(length);\n              while (++index < length) {\n                array[index] = args[start + index];\n              }\n              index = -1;\n              var otherArgs = Array(start + 1);\n              while (++index < start) {\n                otherArgs[index] = args[index];\n              }\n              otherArgs[start] = transform(array);\n              return apply(func, this, otherArgs);\n            };\n          }\n          var setToString = shortOut(baseSetToString);\n          function shortOut(func) {\n            var count = 0,\n              lastCalled = 0;\n            return function () {\n              var stamp = nativeNow(),\n                remaining = HOT_SPAN - (stamp - lastCalled);\n              lastCalled = stamp;\n              if (remaining > 0) {\n                if (++count >= HOT_COUNT) {\n                  return arguments[0];\n                }\n              } else {\n                count = 0;\n              }\n              return func.apply(undefined, arguments);\n            };\n          }\n          function toSource(func) {\n            if (func != null) {\n              try {\n                return funcToString.call(func);\n              } catch (e) {}\n              try {\n                return func + '';\n              } catch (e) {}\n            }\n            return '';\n          }\n          function eq(value, other) {\n            return value === other || value !== value && other !== other;\n          }\n          var isArguments = baseIsArguments(function () {\n            return arguments;\n          }()) ? baseIsArguments : function (value) {\n            return isObjectLike(value) && hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');\n          };\n          var isArray = Array.isArray;\n          function isArrayLike(value) {\n            return value != null && isLength(value.length) && !isFunction(value);\n          }\n          function isArrayLikeObject(value) {\n            return isObjectLike(value) && isArrayLike(value);\n          }\n          var isBuffer = nativeIsBuffer || stubFalse;\n          function isFunction(value) {\n            if (!isObject(value)) {\n              return false;\n            }\n            var tag = baseGetTag(value);\n            return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n          }\n          function isLength(value) {\n            return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n          }\n          function isObject(value) {\n            var type = typeof value;\n            return value != null && (type == 'object' || type == 'function');\n          }\n          function isObjectLike(value) {\n            return value != null && typeof value == 'object';\n          }\n          function isPlainObject(value) {\n            if (!isObjectLike(value) || baseGetTag(value) != objectTag) {\n              return false;\n            }\n            var proto = getPrototype(value);\n            if (proto === null) {\n              return true;\n            }\n            var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;\n            return typeof Ctor == 'function' && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;\n          }\n          var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n          function toPlainObject(value) {\n            return copyObject(value, keysIn(value));\n          }\n          function keysIn(object) {\n            return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);\n          }\n          var merge = createAssigner(function (object, source, srcIndex) {\n            baseMerge(object, source, srcIndex);\n          });\n          function constant(value) {\n            return function () {\n              return value;\n            };\n          }\n          function identity(value) {\n            return value;\n          }\n          function stubFalse() {\n            return false;\n          }\n          module.exports = merge;\n        }).call(this, typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {});\n      }, {}]\n    }, {}, [2])(2);\n  });\n});\nace.define(\"ace/mode/yaml_worker\", [], function (require, exports) {\n  \"use strict\";\n\n  var oop = require(\"../lib/oop\");\n  var Mirror = require(\"../worker/mirror\").Mirror;\n  var lint = require(\"./yaml/yaml-lint\").lint;\n  var YamlWorker = exports.YamlWorker = function (sender) {\n    Mirror.call(this, sender);\n    this.setTimeout(500);\n    this.setOptions();\n  };\n  oop.inherits(YamlWorker, Mirror);\n  (function () {\n    this.setOptions = function () {\n      this.doc.getValue() && this.deferredUpdate.schedule(100);\n    };\n    this.changeOptions = function (newOptions) {\n      oop.mixin(this.options, newOptions);\n      this.doc.getValue() && this.deferredUpdate.schedule(100);\n    };\n    this.onUpdate = function () {\n      var _this = this;\n      var value = this.doc.getValue();\n      var errors = [];\n      lint(value, {}, function (error) {\n        if (!error) {\n          _this.sender.emit(\"annotate\", errors);\n          return;\n        }\n        errors.push({\n          row: error.mark.line,\n          column: error.mark.column,\n          text: error.reason,\n          type: 'error',\n          raw: error\n        });\n        _this.sender.emit(\"annotate\", errors);\n      });\n    };\n  }).call(YamlWorker.prototype);\n});","map":null,"metadata":{},"sourceType":"script"}